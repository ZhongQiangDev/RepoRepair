Let me analyze the problem description and break down the issues:

### Answer 1
**Wrong Behavior**: WebGL alpha blending is inconsistent with the 2D renderer's behavior
**Cause**: The default WebGL alpha setting is set to true, which makes the canvas transparent and allows blending with elements behind it (in this case, the blue background), instead of blending with the canvas's own background color (black)

### Answer 2
**Wrong Behavior**: Unexpected visual results when using opacity in WebGL mode
**Cause**: When alpha is enabled in WebGL mode, the transparency calculations consider the entire rendering stack including elements behind the canvas, rather than just the layers within the canvas itself

### Answer 3
**Wrong Behavior**: Inconsistency between CSS opacity behavior and WebGL alpha blending
**Cause**: CSS opacity works within its own containment hierarchy (the black outer div), while WebGL's default alpha behavior extends beyond its immediate container, creating different visual results for what should be equivalent opacity settings

### Conclusion
**Summary**: The core issue stems from WebGL's default alpha setting being true, which creates three main problems: inconsistency with the 2D renderer, unexpected transparency behavior, and deviation from CSS-style opacity containment. All these issues can be resolved by changing the default WebGL alpha setting to false, making it behave more like the 2D renderer and CSS opacity. While this would require explicit opt-in for transparent canvas backgrounds, it would provide more intuitive and consistent behavior for most use cases.