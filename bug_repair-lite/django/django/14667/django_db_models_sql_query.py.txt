Based on the issue description, the bug is in the deferred field handling in Django's query.py. When chaining .only() and .defer(), the deferred fields are not being properly cleared, causing all fields to be selected.

The issue occurs in the `add_deferred_loading()` method where it's not properly handling the interaction between .only() and .defer(). The method needs to be modified to properly handle the case when .defer() is called after .only().

Here's the fix:

```python
### django/db/models/sql/query.py
<<<<<<< SEARCH
    def add_deferred_loading(self, field_names):
        """
        Add the given list of model field names to the set of fields to
        exclude from loading from the database when automatic column selection
        is done. Add the new field names to any existing field names that
        are deferred (or removed from any existing field names that are marked
        as the only ones for immediate loading).
        """
        # Fields on related models are stored in the literal double-underscore
        # format, so that we can use a set datastructure. We do the foo__bar
        # splitting and handling when computing the SQL column names (as part of
        # get_columns()).
        existing, defer = self.deferred_loading
        if defer:
            # Add to existing deferred names.
            self.deferred_loading = existing.union(field_names), True
        else:
            # Remove names from the set of any existing "immediate load" names.
            self.deferred_loading = existing.difference(field_names), False
=======
    def add_deferred_loading(self, field_names):
        """
        Add the given list of model field names to the set of fields to
        exclude from loading from the database when automatic column selection
        is done. Add the new field names to any existing field names that
        are deferred (or removed from any existing field names that are marked
        as the only ones for immediate loading).
        """
        # Fields on related models are stored in the literal double-underscore
        # format, so that we can use a set datastructure. We do the foo__bar
        # splitting and handling when computing the SQL column names (as part of
        # get_columns()).
        existing, defer = self.deferred_loading
        if defer:
            # Add to existing deferred names.
            self.deferred_loading = existing.union(field_names), True
        else:
            # When .only() has been called, we need to add these fields
            # to be deferred and switch to defer mode
            self.deferred_loading = existing.union(field_names), True
>>>>>>> REPLACE
```

This fix changes the behavior when .defer() is called after .only() (when defer=False). Instead of removing the deferred fields from the "immediate load" set, it adds them to the deferred set and switches to defer mode. This ensures that when .only("name").defer("name") is called, it properly defers the "name" field rather than loading all fields.

The change makes the deferred loading system properly handle the case where .defer() is called after .only(), fixing the issue described where all fields were being selected instead of being properly deferred.
