Based on the issue description, the bug is in the `parse_http_date` function where it handles two-digit years. The current logic hardcodes years 0-69 to 2000-2069 and 70-99 to 1970-1999, but according to RFC 7231, it should interpret dates more than 50 years in the future as being in the past century.

Here's the fix that compares against the current year:

```python
### django/utils/http.py
<<<<<<< SEARCH
        year = int(m.group('year'))
        if year < 100:
            if year < 70:
                year += 2000
            else:
                year += 1900
=======
        year = int(m.group('year'))
        if year < 100:
            current_year = datetime.datetime.now().year
            current_century = current_year // 100 * 100
            full_year = current_century + year
            if full_year - current_year > 50:
                full_year -= 100
            year = full_year
>>>>>>> REPLACE
```

This fix:
1. Gets the current year
2. Calculates the current century (e.g., 2000 for years 2000-2099)
3. Creates a full year by combining the century with the 2-digit year
4. If that full year is more than 50 years in the future compared to the current year, subtracts 100 years to get the most recent year in the past with those same last two digits
5. Uses the resulting year

For example:
- If current year is 2023 and input is "23", full_year will be 2023 (no adjustment needed)
- If current year is 2023 and input is "95", full_year will be 2095, which is >50 years in future, so becomes 1995
- If current year is 2023 and input is "45", full_year will be 2045, which is <50 years in future, so stays 2045

This implements the RFC 7231 specification correctly by making the year calculation relative to the current date rather than using hardcoded ranges.
