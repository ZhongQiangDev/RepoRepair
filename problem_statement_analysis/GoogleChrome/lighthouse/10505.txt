Let me analyze the GitHub problem description and break down the wrong behaviors and their causes.

### Answer 1
**Wrong Behavior**: Lighthouse reports no performance score when testing a page with slow First Contentful Paint (FCP) but immediate idle period afterwards
**Cause**: The timing issue between FCP and CPU idle period appears to trigger a validation error in Lighthouse's Time to Interactive (TTI) metric calculation. When the page has a delayed FCP (1700ms) but becomes idle immediately after, Lighthouse's algorithm seems unable to properly determine the TTI, resulting in the NO_TTI_CPU_IDLE_PERIOD error.

### Answer 2
**Wrong Behavior**: The error is inconsistent between DevTools and CLI execution
**Cause**: The timing sensitivity of the issue makes it more reproducible in DevTools (with disabled simulated throttling) compared to CLI execution (roughly 25% occurrence rate). This suggests that the different execution environments and throttling implementations between DevTools and CLI affect how the timing measurements are captured and processed.

### Answer 3
**Wrong Behavior**: The error disappears when adding artificial CPU work (400ms loop) after setting body HTML
**Cause**: This workaround suggests that Lighthouse's TTI calculation expects some minimum CPU activity period between FCP and the idle state. When the page transitions too quickly from FCP to idle, it triggers the validation error. Adding artificial CPU work creates a more "expected" performance profile that Lighthouse can properly measure.

### Conclusion
**Summary**: The core issue revolves around Lighthouse's handling of edge cases in performance timing, specifically when a page has a delayed First Contentful Paint but becomes immediately idle afterwards. The problem manifests as a NO_TTI_CPU_IDLE_PERIOD error, preventing Lighthouse from calculating a performance score. The issue appears to be more prevalent in DevTools than CLI execution, and can be artificially resolved by adding CPU work after FCP. This suggests that Lighthouse's TTI metric calculation may need adjustment to better handle rapid transitions between FCP and idle states, particularly in cases where there is minimal CPU activity between these events.