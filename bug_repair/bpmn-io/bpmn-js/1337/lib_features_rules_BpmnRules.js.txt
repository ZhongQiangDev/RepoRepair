To address the issue of disallowing typed Start Events inside non-event-based Sub Processes, we need to modify the `canReplace` function to ensure that typed Start Events cannot be morphed into or dropped inside a non-event-based Sub Process. Additionally, we need to ensure that when a Start Event is moved into a Sub Process, its event type is dropped.

Here are the necessary `SEARCH/REPLACE` edits:

```javascript
### lib/features/rules/BpmnRules.js
<<<<<<< SEARCH
function canReplace(elements, target, position) {

  if (!target) {
    return false;
  }

  var canExecute = {
    replacements: []
  };

  forEach(elements, function(element) {

    if (!isEventSubProcess(target)) {

      if (is(element, 'bpmn:StartEvent') &&
          element.type !== 'label' &&
          canDrop(element, target)) {

        // replace a non-interrupting start event by a blank interrupting start event
        // when the target is not an event sub process
        if (!isInterrupting(element)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: 'bpmn:StartEvent'
          });
        }

        // replace an error/escalation/compensate start event by a blank interrupting start event
        // when the target is not an event sub process
        if (hasErrorEventDefinition(element) ||
            hasEscalationEventDefinition(element) ||
            hasCompensateEventDefinition(element)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: 'bpmn:StartEvent'
          });
        }
      }
    }
=======
function canReplace(elements, target, position) {

  if (!target) {
    return false;
  }

  var canExecute = {
    replacements: []
  };

  forEach(elements, function(element) {

    if (!isEventSubProcess(target)) {

      if (is(element, 'bpmn:StartEvent') &&
          element.type !== 'label' &&
          canDrop(element, target)) {

        // Disallow typed start events inside non-event-based Sub Process
        if (hasErrorEventDefinition(element) ||
            hasEscalationEventDefinition(element) ||
            hasCompensateEventDefinition(element) ||
            hasMessageEventDefinition(element) ||
            hasTimerEventDefinition(element) ||
            hasConditionalEventDefinition(element) ||
            hasSignalEventDefinition(element)) {
          return false;
        }

        // replace a non-interrupting start event by a blank interrupting start event
        // when the target is not an event sub process
        if (!isInterrupting(element)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: 'bpmn:StartEvent'
          });
        }

        // replace an error/escalation/compensate start event by a blank interrupting start event
        // when the target is not an event sub process
        if (hasErrorEventDefinition(element) ||
            hasEscalationEventDefinition(element) ||
            hasCompensateEventDefinition(element)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: 'bpmn:StartEvent'
          });
        }
      }
    }
>>>>>>> REPLACE
```

```javascript
### lib/features/rules/BpmnRules.js
<<<<<<< SEARCH
function canDrop(shape, target, position) {

  if (!target) {
    return false;
  }

  if (isLabel(shape) || isGroup(shape)) {
    return true;
  }

  if (isSame(source, target)) {
    return false;
  }

  // ensure we do not drop the element
  // into source
  if (source && isParent(source, target)) {
    return false;
  }

  return canDrop(shape, target, position) || canInsert(shape, target, position);
=======
function canDrop(shape, target, position) {

  if (!target) {
    return false;
  }

  if (isLabel(shape) || isGroup(shape)) {
    return true;
  }

  if (isSame(source, target)) {
    return false;
  }

  // ensure we do not drop the element
  // into source
  if (source && isParent(source, target)) {
    return false;
  }

  // Drop event type when moving start event to sub-process
  if (is(shape, 'bpmn:StartEvent') && is(target, 'bpmn:SubProcess')) {
    shape.eventDefinitions = [];
  }

  return canDrop(shape, target, position) || canInsert(shape, target, position);
>>>>>>> REPLACE
```
