The issue described involves two main problems:

1. **Incorrect Pixel Value Reading**: The R value of the pixel is not being read correctly.
2. **Incorrect Pixel Update**: When decreasing the level, the pixels do not change as expected.

To address these issues, we need to ensure that the pixel values are correctly read and updated. Here are the necessary changes:

### Fixing Pixel Value Reading

The issue with reading the pixel value might be due to the way the pixel data is being accessed. We need to ensure that the pixel data is correctly indexed and read.

### Fixing Pixel Update

When decreasing the level, the pixels should be updated correctly. This might involve ensuring that the raster operation is correctly triggered and that the pixel values are updated based on the new level.

Here are the necessary changes:

```javascript
###examples/sea-level.js
<<<<<<< SEARCH
function floodRegion(inputs, data) {
	const image = inputs[0];
	const inputData = image.data;
	const width = image.width;
	const height = image.height;
	let seed = data.pixel;

	if (seed) {
		seed = seed.map(Math.round);
		const seedIdx = (seed[1] * width + seed[0]) * 4;
		console.log("Value: " + inputData[seedIdx]);
	}

	return { data: image.data, width: width, height: height };
}
=======
function floodRegion(inputs, data) {
	const image = inputs[0];
	const inputData = image.data;
	const width = image.width;
	const height = image.height;
	let seed = data.pixel;

	if (seed) {
		seed = seed.map(Math.round);
		const seedIdx = (seed[1] * width + seed[0]) * 4;
		// Ensure correct indexing for R value
		const rValue = inputData[seedIdx];
		console.log("R Value: " + rValue);
	}

	// Update pixel values based on new level
	const level = parseFloat(control.value);
	for (let y = 0; y < height; y++) {
		for (let x = 0; x < width; x++) {
			const idx = (y * width + x) * 4;
			const elevationValue = inputData[idx];
			if (elevationValue <= level) {
				inputData[idx] = 255; // R
				inputData[idx + 1] = 255; // G
				inputData[idx + 2] = 255; // B
				inputData[idx + 3] = 255; // A
			} else {
				inputData[idx] = 0; // R
				inputData[idx + 1] = 0; // G
				inputData[idx + 2] = 0; // B
				inputData[idx + 3] = 0; // A
			}
		}
	}

	return { data: inputData, width: width, height: height };
}
>>>>>>> REPLACE
```

### Additional Changes

Ensure that the raster source is correctly updated when the level changes:

```javascript
###examples/sea-level.js
<<<<<<< SEARCH
control.addEventListener('input', () => {
	outputLevel.innerText = control.value;
	elevationTile.updateStyleVariables({ level: parseFloat(control.value) });
	//raster.changed();
})
=======
control.addEventListener('input', () => {
	outputLevel.innerText = control.value;
	elevationTile.updateStyleVariables({ level: parseFloat(control.value) });
	raster.changed(); // Ensure raster is updated
})
>>>>>>> REPLACE
```

These changes should address the issues with incorrect pixel value reading and pixel update when decreasing the level.
