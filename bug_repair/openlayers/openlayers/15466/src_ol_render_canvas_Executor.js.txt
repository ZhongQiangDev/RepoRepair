```javascript
### src/ol/render/canvas/Executor.js
<<<<<<< SEARCH
/**
 * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel
 * @return {BBox} Declutter bbox.
 */
function getDeclutterBox(replayImageOrLabelArgs) {
  return replayImageOrLabelArgs[3].declutterBox;
}
=======
/**
 * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel
 * @return {BBox} Declutter bbox.
 */
function getDeclutterBox(replayImageOrLabelArgs) {
  const dimensions = replayImageOrLabelArgs[3];
  if (dimensions.ignorePlacement) {
    return null;
  }
  return dimensions.declutterBox;
}
>>>>>>> REPLACE
```

```javascript
### src/ol/render/canvas/Executor.js
<<<<<<< SEARCH
/**
 * @param {number} sheetWidth Width of the sprite sheet.
 * @param {number} sheetHeight Height of the sprite sheet.
 * @param {number} centerX X.
 * @param {number} centerY Y.
 * @param {number} width Width.
 * @param {number} height Height.
 * @param {number} anchorX Anchor X.
 * @param {number} anchorY Anchor Y.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} rotation Rotation.
 * @param {import("../../size.js").Size} scale Scale.
 * @param {boolean} snapToPixel Snap to pixel.
 * @param {Array<number>} padding Padding.
 * @param {boolean} fillStroke Background fill or stroke.
 * @param {import("../../Feature.js").FeatureLike} feature Feature.
 * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
 */
calculateImageOrLabelDimensions_(
  sheetWidth,
  sheetHeight,
  centerX,
  centerY,
  width,
  height,
  anchorX,
  anchorY,
  originX,
  originY,
  rotation,
  scale,
  snapToPixel,
  padding,
  fillStroke,
  feature,
) {
=======
/**
 * @param {number} sheetWidth Width of the sprite sheet.
 * @param {number} sheetHeight Height of the sprite sheet.
 * @param {number} centerX X.
 * @param {number} centerY Y.
 * @param {number} width Width.
 * @param {number} height Height.
 * @param {number} anchorX Anchor X.
 * @param {number} anchorY Anchor Y.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} rotation Rotation.
 * @param {import("../../size.js").Size} scale Scale.
 * @param {boolean} snapToPixel Snap to pixel.
 * @param {Array<number>} padding Padding.
 * @param {boolean} fillStroke Background fill or stroke.
 * @param {import("../../Feature.js").FeatureLike} feature Feature.
 * @param {boolean} ignorePlacement Ignore placement for decluttering.
 * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
 */
calculateImageOrLabelDimensions_(
  sheetWidth,
  sheetHeight,
  centerX,
  centerY,
  width,
  height,
  anchorX,
  anchorY,
  originX,
  originY,
  rotation,
  scale,
  snapToPixel,
  padding,
  fillStroke,
  feature,
  ignorePlacement,
) {
  const dimensions = {
    // ... existing code ...
    ignorePlacement: ignorePlacement,
  };
  return dimensions;
}
>>>>>>> REPLACE
```

```javascript
### src/ol/render/canvas/Executor.js
<<<<<<< SEARCH
case CanvasInstruction.DRAW_IMAGE:
  d = /** @type {number} */ (instruction[1]);
  dd = /** @type {number} */ (instruction[2]);
  image =
    /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (
      instruction[3]
    );
  // ... existing code ...
  let padding, backgroundFill, backgroundStroke;
  if (instruction.length > 17) {
    padding = /** @type {Array<number>} */ (instruction[16]);
    backgroundFill = /** @type {boolean} */ (instruction[17]);
    backgroundStroke = /** @type {boolean} */ (instruction[18]);
  } else {
    padding = defaultPadding;
    backgroundFill = false;
    backgroundStroke = false;
  }
  if (rotateWithView && viewRotationFromTransform) {
    // ... existing code ...
  }
  let widthIndex = 0;
  for (; d < dd; d += 2) {
    if (
      geometryWidths &&
      geometryWidths[widthIndex++] < width / this.pixelRatio
    ) {
      continue;
    }
    const dimensions = this.calculateImageOrLabelDimensions_(
      image.width,
      image.height,
      pixelCoordinates[d],
      pixelCoordinates[d + 1],
      width,
      height,
      anchorX,
      anchorY,
      originX,
      originY,
      rotation,
      scale,
      snapToPixel,
      padding,
      backgroundFill || backgroundStroke,
      feature,
    );
=======
case CanvasInstruction.DRAW_IMAGE:
  d = /** @type {number} */ (instruction[1]);
  dd = /** @type {number} */ (instruction[2]);
  image =
    /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (
      instruction[3]
    );
  // ... existing code ...
  let padding, backgroundFill, backgroundStroke, ignorePlacement;
  if (instruction.length > 17) {
    padding = /** @type {Array<number>} */ (instruction[16]);
    backgroundFill = /** @type {boolean} */ (instruction[17]);
    backgroundStroke = /** @type {boolean} */ (instruction[18]);
    ignorePlacement = /** @type {boolean} */ (instruction[26]);
  } else {
    padding = defaultPadding;
    backgroundFill = false;
    backgroundStroke = false;
    ignorePlacement = false;
  }
  if (rotateWithView && viewRotationFromTransform) {
    // ... existing code ...
  }
  let widthIndex = 0;
  for (; d < dd; d += 2) {
    if (
      geometryWidths &&
      geometryWidths[widthIndex++] < width / this.pixelRatio
    ) {
      continue;
    }
    const dimensions = this.calculateImageOrLabelDimensions_(
      image.width,
      image.height,
      pixelCoordinates[d],
      pixelCoordinates[d + 1],
      width,
      height,
      anchorX,
      anchorY,
      originX,
      originY,
      rotation,
      scale,
      snapToPixel,
      padding,
      backgroundFill || backgroundStroke,
      feature,
      ignorePlacement,
    );
>>>>>>> REPLACE
```
