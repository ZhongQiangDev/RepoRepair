The issue described is related to web workers created by the raster source not being terminated, leading to potential memory leaks. The provided code does not explicitly handle the termination of these workers. To address this, we need to ensure that the web workers are properly terminated when they are no longer needed.

Here's the proposed fix:

```javascript
### src/ol/source/Raster.js
<<<<<<< SEARCH
  /**
   * @param {Operation} operation New operation.
   * @param {Object=} opt_lib Functions that will be available to operations run
   *     in a worker.
   * @api
   */
  setOperation(operation, opt_lib) {
    this.worker_ = new Processor({
      operation: operation,
      imageOps: this.operationType_ === RasterOperationType.IMAGE,
      queue: 1,
      lib: opt_lib,
      threads: this.threads_,
    });
    this.changed();
  }
=======
  /**
   * @param {Operation} operation New operation.
   * @param {Object=} opt_lib Functions that will be available to operations run
   *     in a worker.
   * @api
   */
  setOperation(operation, opt_lib) {
    // Terminate the existing worker if it exists
    if (this.worker_) {
      this.worker_.terminate();
    }
    this.worker_ = new Processor({
      operation: operation,
      imageOps: this.operationType_ === RasterOperationType.IMAGE,
      queue: 1,
      lib: opt_lib,
      threads: this.threads_,
    });
    this.changed();
  }

  /**
   * Terminate the worker when the raster source is disposed.
   */
  disposeInternal() {
    if (this.worker_) {
      this.worker_.terminate();
      this.worker_ = null;
    }
  }
>>>>>>> REPLACE
```

This modification ensures that the worker is terminated when a new operation is set and when the raster source is disposed. This should help prevent memory leaks caused by lingering web workers.
