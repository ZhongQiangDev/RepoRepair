```javascript
### src/ol/webgl/Helper.js
<<<<<<< SEARCH
  /**
   * @param {string} canvasCacheKey The canvas cache key.
   * @return {boolean} The provided key matches the one this helper was constructed with.
   */
  canvasCacheKeyMatches(canvasCacheKey) {
    return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);
  }
=======
  /**
   * @param {string} canvasCacheKey The canvas cache key.
   * @return {boolean} The provided key matches the one this helper was constructed with.
   */
  canvasCacheKeyMatches(canvasCacheKey) {
    return this.canvasCacheKey_ === canvasCacheKey;
  }
>>>>>>> REPLACE
```

```javascript
### src/ol/webgl/Helper.js
<<<<<<< SEARCH
  /**
   * @param {string} key The cache key for the canvas.
   * @return {WebGLRenderingContext} The canvas.
   */
  function getOrCreateContext(key) {
    let cacheItem = canvasCache[key];
    if (!cacheItem) {
      const canvas = document.createElement('canvas');
      canvas.width = 1;
      canvas.height = 1;
      canvas.style.position = 'absolute';
      canvas.style.left = '0';
      const context = getContext(canvas);
      cacheItem = {users: 0, context};
      canvasCache[key] = cacheItem;
    }

    cacheItem.users += 1;
    return cacheItem.context;
  }
=======
  /**
   * @param {string} key The cache key for the canvas.
   * @return {WebGLRenderingContext} The canvas.
   */
  function getOrCreateContext(key) {
    let cacheItem = canvasCache[key];
    if (!cacheItem) {
      const canvas = document.createElement('canvas');
      canvas.width = 1;
      canvas.height = 1;
      canvas.style.position = 'absolute';
      canvas.style.left = '0';
      const context = getContext(canvas);
      cacheItem = {users: 0, context, canvas}; // Store the canvas reference
      canvasCache[key] = cacheItem;
    }

    cacheItem.users += 1;
    return cacheItem.context;
  }

  /**
   * @param {string} key The cache key for the canvas.
   */
  function releaseCanvas(key) {
    const cacheItem = canvasCache[key];
    if (!cacheItem) {
      return;
    }

    cacheItem.users -= 1;
    if (cacheItem.users > 0) {
      return;
    }

    const gl = cacheItem.context;
    const extension = gl.getExtension('WEBGL_lose_context');
    if (extension) {
      extension.loseContext();
    }
    const canvas = cacheItem.canvas; // Use the stored canvas reference
    canvas.width = 1;
    canvas.height = 1;

    delete canvasCache[key];
  }
>>>>>>> REPLACE
```

```javascript
### src/ol/webgl/Helper.js
<<<<<<< SEARCH
  /**
   * @param {string} canvasCacheKey The canvas cache key.
   * @return {boolean} The provided key matches the one this helper was constructed with.
   */
  canvasCacheKeyMatches(canvasCacheKey) {
    return this.canvasCacheKey_ === canvasCacheKey;
  }
=======
  /**
   * @param {string} canvasCacheKey The canvas cache key.
   * @return {boolean} The provided key matches the one this helper was constructed with.
   */
  canvasCacheKeyMatches(canvasCacheKey) {
    return this.canvasCacheKey_ === canvasCacheKey;
  }

  /**
   * @param {WebGLRenderingContext} gl The WebGL context.
   */
  resetContext(gl) {
    this.gl_ = gl;
    this.uniformLocationsByProgram_ = {};
    this.attribLocationsByProgram_ = {};
    this.currentProgram_ = null;
    this.needsToBeRecreated_ = false;
  }
>>>>>>> REPLACE
```

```javascript
### src/ol/webgl/Helper.js
<<<<<<< SEARCH
  /**
   * WebGL context was restored
   * @private
   */
  handleWebGLContextRestored() {
    this.needsToBeRecreated_ = true;
  }
=======
  /**
   * WebGL context was restored
   * @private
   */
  handleWebGLContextRestored() {
    const newContext = getOrCreateContext(this.canvasCacheKey_);
    this.resetContext(newContext);
  }
>>>>>>> REPLACE
```
