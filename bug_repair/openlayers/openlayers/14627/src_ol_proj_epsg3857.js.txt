The issue arises because `Math.tan` returns `NaN` when given `Infinity` as an input. To handle this, we need to check if the input values are `Infinity` or `-Infinity` and handle them appropriately before applying the transformation.

Here's the fix:

```javascript
### src/ol/proj/epsg3857.js
<<<<<<< SEARCH
export function fromEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += dimension) {
    output[i] = (HALF_SIZE * input[i]) / 180;
    let y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));
    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }
    output[i + 1] = y;
  }
  return output;
}
=======
export function fromEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += dimension) {
    output[i] = (HALF_SIZE * input[i]) / 180;
    let y = input[i + 1];
    if (y === Infinity) {
      y = MAX_SAFE_Y;
    } else if (y === -Infinity) {
      y = -MAX_SAFE_Y;
    } else {
      y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));
      if (y > MAX_SAFE_Y) {
        y = MAX_SAFE_Y;
      } else if (y < -MAX_SAFE_Y) {
        y = -MAX_SAFE_Y;
      }
    }
    output[i + 1] = y;
  }
  return output;
}
>>>>>>> REPLACE
```

This change ensures that if the input value is `Infinity` or `-Infinity`, it is directly assigned to `MAX_SAFE_Y` or `-MAX_SAFE_Y` respectively, avoiding the `NaN` issue.
