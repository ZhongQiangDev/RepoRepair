The issue described is that the ByteEfficiency audit reports no savings for animated GIF to video conversions, even though there are significant byte savings. The problem seems to be in how the `computeWasteWithTTIGraph` function calculates the impact on the Time To Interactive (TTI) metric. The function currently calculates the savings based on the last long task in the graph, which may not accurately reflect the savings when only a single request is affected.

To address this, we can modify the `computeWasteWithTTIGraph` function to calculate the impact on the end of the graph instead of the last long task. This should provide a more accurate representation of the savings.

Here is the proposed fix:

```javascript
###lighthouse-core/audits/byte-efficiency/byte-efficiency-audit.js
<<<<<<< SEARCH
  /**
   * Computes the estimated effect of all the byte savings on the last long task
   * in the provided graph.
   *
   * @param {Array<LH.Audit.ByteEfficiencyResult>} results The array of byte savings results per resource
   * @param {Node} graph
   * @param {Simulator} simulator
   * @return {number}
   */
  static computeWasteWithTTIGraph(results, graph, simulator) {
    const simulationBeforeChanges = simulator.simulate(graph);
    /** @type {Map<LH.Audit.ByteEfficiencyResult['url'], LH.Audit.ByteEfficiencyResult>} */
    const resultsByUrl = new Map();
    for (const result of results) {
      resultsByUrl.set(result.url, result);
    }

    // Update all the transfer sizes to reflect implementing our recommendations
    /** @type {Map<string, number>} */
    const originalTransferSizes = new Map();
    graph.traverse(node => {
      if (node.type !== 'network') return;
      const networkNode = /** @type {NetworkNode} */ (node);
      const result = resultsByUrl.get(networkNode.record.url);
      if (!result) return;
      const original = networkNode.record.transferSize;
      // cloning NetworkRequest objects is difficult, so just stash the original transfer size
      originalTransferSizes.set(networkNode.record.requestId, original);

      const wastedBytes = result.wastedBytes;
      networkNode.record._transferSize = Math.max(original - wastedBytes, 0);
    });

    const simulationAfterChanges = simulator.simulate(graph);

    // Restore the original transfer size after we've done our simulation
    graph.traverse(node => {
      if (node.type !== 'network') return;
      const networkNode = /** @type {NetworkNode} */ (node);
      const originalTransferSize = originalTransferSizes.get(networkNode.record.requestId);
      if (originalTransferSize === undefined) return;
      networkNode.record._transferSize = originalTransferSize;
    });

    const savingsOnTTI = Math.max(
      Interactive.getLastLongTaskEndTime(simulationBeforeChanges.nodeTimings) -
        Interactive.getLastLongTaskEndTime(simulationAfterChanges.nodeTimings),
      0
    );

    // Round waste to nearest 10ms
    return Math.round(savingsOnTTI / 10) * 10;
  }
=======
  /**
   * Computes the estimated effect of all the byte savings on the end of the graph.
   *
   * @param {Array<LH.Audit.ByteEfficiencyResult>} results The array of byte savings results per resource
   * @param {Node} graph
   * @param {Simulator} simulator
   * @return {number}
   */
  static computeWasteWithTTIGraph(results, graph, simulator) {
    const simulationBeforeChanges = simulator.simulate(graph);
    /** @type {Map<LH.Audit.ByteEfficiencyResult['url'], LH.Audit.ByteEfficiencyResult>} */
    const resultsByUrl = new Map();
    for (const result of results) {
      resultsByUrl.set(result.url, result);
    }

    // Update all the transfer sizes to reflect implementing our recommendations
    /** @type {Map<string, number>} */
    const originalTransferSizes = new Map();
    graph.traverse(node => {
      if (node.type !== 'network') return;
      const networkNode = /** @type {NetworkNode} */ (node);
      const result = resultsByUrl.get(networkNode.record.url);
      if (!result) return;
      const original = networkNode.record.transferSize;
      // cloning NetworkRequest objects is difficult, so just stash the original transfer size
      originalTransferSizes.set(networkNode.record.requestId, original);

      const wastedBytes = result.wastedBytes;
      networkNode.record._transferSize = Math.max(original - wastedBytes, 0);
    });

    const simulationAfterChanges = simulator.simulate(graph);

    // Restore the original transfer size after we've done our simulation
    graph.traverse(node => {
      if (node.type !== 'network') return;
      const networkNode = /** @type {NetworkNode} */ (node);
      const originalTransferSize = originalTransferSizes.get(networkNode.record.requestId);
      if (originalTransferSize === undefined) return;
      networkNode.record._transferSize = originalTransferSize;
    });

    const savingsOnEndOfGraph = Math.max(
      simulationBeforeChanges.endTime -
        simulationAfterChanges.endTime,
      0
    );

    // Round waste to nearest 10ms
    return Math.round(savingsOnEndOfGraph / 10) * 10;
  }
>>>>>>> REPLACE
```
