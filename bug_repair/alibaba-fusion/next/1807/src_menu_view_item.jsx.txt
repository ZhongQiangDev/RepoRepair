To address the issue described, we need to implement a solution that balances the need for accessibility with the concerns about redundant text and user preferences. The best approach seems to be **方案三**, which conditionally sets the `title` attribute based on the content of `Menu.Item`.

Here's how we can modify the code to implement this solution:

```javascript
### src/menu/view/item.jsx
<<<<<<< SEARCH
    getTitle(children) {
        let labelString = '';

        const loop = children => {
            Children.forEach(children, child => {
                if (isValidElement(child) && child.props.children) {
                    loop(child.props.children);
                } else if (typeof child === 'string') {
                    labelString += child;
                }
            });
        };

        loop(children);

        return labelString;
    }

    render() {
        const {
            inlineLevel,
            root,
            replaceClassName,
            groupIndent,
            component,
            disabled,
            className,
            children,
            needIndent,
            parentMode,
            _key,
        } = this.props;
        const others = pickOthers(Object.keys(Item.propTypes), this.props);

        const {
            prefix,
            focusable,
            inlineIndent,
            itemClassName,
            rtl,
        } = root.props;
        const focused = this.getFocused();

        const newClassName = replaceClassName
            ? className
            : cx({
                  [`${prefix}menu-item`]: true,
                  [`${prefix}disabled`]: disabled,
                  [`${prefix}focused`]: !focusable && focused,
                  [itemClassName]: !!itemClassName,
                  [className]: !!className,
              });
        if (disabled) {
            others['aria-disabled'] = true;
            others['aria-hidden'] = true;
        }

        others.tabIndex = root.state.tabbableKey === _key ? '0' : '-1';

        if (
            parentMode === 'inline' &&
            inlineLevel > 1 &&
            inlineIndent > 0 &&
            needIndent
        ) {
            const paddingProp = rtl ? 'paddingRight' : 'paddingLeft';
            others.style = {
                ...(others.style || {}),
                [paddingProp]: `${inlineLevel * inlineIndent -
                    (groupIndent || 0) * 0.4 * inlineIndent}px`,
            };
        }
        const TagName = component;

        let role = 'menuitem';
        if ('selectMode' in root.props) {
            role = 'option';
        }

        return (
            <TagName
                role={role}
                title={this.getTitle(children)}
                {...others}
                className={newClassName}
                onClick={this.handleClick}
                onKeyDown={this.handleKeyDown}
            >
                <div className={`${prefix}menu-item-inner`}>{children}</div>
            </TagName>
        );
    }
=======
    getTitle(children) {
        let labelString = '';

        const loop = children => {
            Children.forEach(children, child => {
                if (isValidElement(child) && child.props.children) {
                    loop(child.props.children);
                } else if (typeof child === 'string') {
                    labelString += child;
                }
            });
        };

        loop(children);

        return labelString;
    }

    isPureString(children) {
        let isPureString = true;

        const loop = children => {
            Children.forEach(children, child => {
                if (isValidElement(child)) {
                    isPureString = false;
                } else if (typeof child === 'string') {
                    loop(child);
                }
            });
        };

        loop(children);

        return isPureString;
    }

    render() {
        const {
            inlineLevel,
            root,
            replaceClassName,
            groupIndent,
            component,
            disabled,
            className,
            children,
            needIndent,
            parentMode,
            _key,
        } = this.props;
        const others = pickOthers(Object.keys(Item.propTypes), this.props);

        const {
            prefix,
            focusable,
            inlineIndent,
            itemClassName,
            rtl,
        } = root.props;
        const focused = this.getFocused();

        const newClassName = replaceClassName
            ? className
            : cx({
                  [`${prefix}menu-item`]: true,
                  [`${prefix}disabled`]: disabled,
                  [`${prefix}focused`]: !focusable && focused,
                  [itemClassName]: !!itemClassName,
                  [className]: !!className,
              });
        if (disabled) {
            others['aria-disabled'] = true;
            others['aria-hidden'] = true;
        }

        others.tabIndex = root.state.tabbableKey === _key ? '0' : '-1';

        if (
            parentMode === 'inline' &&
            inlineLevel > 1 &&
            inlineIndent > 0 &&
            needIndent
        ) {
            const paddingProp = rtl ? 'paddingRight' : 'paddingLeft';
            others.style = {
                ...(others.style || {}),
                [paddingProp]: `${inlineLevel * inlineIndent -
                    (groupIndent || 0) * 0.4 * inlineIndent}px`,
            };
        }
        const TagName = component;

        let role = 'menuitem';
        if ('selectMode' in root.props) {
            role = 'option';
        }

        const title = this.isPureString(children) ? this.getTitle(children) : undefined;

        return (
            <TagName
                role={role}
                title={title}
                {...others}
                className={newClassName}
                onClick={this.handleClick}
                onKeyDown={this.handleKeyDown}
            >
                <div className={`${prefix}menu-item-inner`}>{children}</div>
            </TagName>
        );
    }
>>>>>>> REPLACE
```

This modification introduces a new method `isPureString` to check if the `children` of `Menu.Item` are purely strings. If they are, it sets the `title` attribute; otherwise, it does not set the `title` attribute, thus avoiding the double hover issue and ensuring that only necessary `title` attributes are added.
