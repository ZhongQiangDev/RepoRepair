The issue described is that the `defaultValue` is not being displayed when using `fillProps` with an empty `dataSource`. The problem seems to be related to how the `defaultValue` is handled when the `dataSource` is empty.

To fix this, we need to ensure that the `defaultValue` is properly set and displayed even when the `dataSource` is empty. We can achieve this by modifying the `renderValues` method to handle the `defaultValue` correctly.

Here's the proposed fix:

```javascript
### src/select/select.jsx
<<<<<<< SEARCH
    renderValues() {
        const {
            mode,
            size,
            valueRender,
            fillProps,
            disabled,
            maxTagCount,
            maxTagTextLength,
        } = this.props;
        let value = this.state.value;

        if (isNull(value)) {
            return null;
        }

        // get detail value
        if (!this.useDetailValue()) {
            if (value === this.valueDataSource.value) {
                value = this.valueDataSource.valueDS;
            } else {
                value = getValueDataSource(
                    value,
                    this.valueDataSource.mapValueDS,
                    this.dataStore.getMapDS()
                ).valueDS;
            }
        }

        if (mode === 'single') {
            if (!value) {
                return null;
            }

            const retvalue = fillProps ? value[fillProps] : valueRender(value);
            // 0 => '0'
            return typeof retvalue === 'number'
                ? retvalue.toString()
                : retvalue;
        } else if (value) {
            let limitedCountValue = value;
            let maxTagPlaceholderEl;
            if (maxTagCount !== undefined && value.length > maxTagCount) {
                limitedCountValue = limitedCountValue.slice(0, maxTagCount);
                maxTagPlaceholderEl = (
                    <Tag
                        type="primary"
                        size={size === 'large' ? 'medium' : 'small'}
                        animation={false}
                    >
                        {`${value.length - maxTagCount}/${value.length}`}
                    </Tag>
                );
            }
            value = limitedCountValue;
            if (!Array.isArray(value)) {
                value = [value];
            }
            const selectedValueNodes = value.map(v => {
                if (!v) {
                    return null;
                }
                const labelNode = fillProps ? v[fillProps] : valueRender(v);
                let content = labelNode;
                if (
                    maxTagTextLength &&
                    typeof content === 'string' &&
                    content.length > maxTagTextLength
                ) {
                    content = `${content.slice(0, maxTagTextLength)}..`;
                }
                return (
                    <Tag
                        key={v.value}
                        disabled={disabled || v.disabled}
                        type="primary"
                        size={size === 'large' ? 'medium' : 'small'}
                        animation={false}
                        onClose={this.handleTagClose.bind(this, v)}
                        closable
                    >
                        {content}
                    </Tag>
                );
            });

            if (maxTagPlaceholderEl) {
                selectedValueNodes.push(maxTagPlaceholderEl);
            }
            return selectedValueNodes;
        }

        return null;
    }
=======
    renderValues() {
        const {
            mode,
            size,
            valueRender,
            fillProps,
            disabled,
            maxTagCount,
            maxTagTextLength,
            defaultValue,
        } = this.props;
        let value = this.state.value || defaultValue;

        if (isNull(value)) {
            return null;
        }

        // get detail value
        if (!this.useDetailValue()) {
            if (value === this.valueDataSource.value) {
                value = this.valueDataSource.valueDS;
            } else {
                value = getValueDataSource(
                    value,
                    this.valueDataSource.mapValueDS,
                    this.dataStore.getMapDS()
                ).valueDS;
            }
        }

        if (mode === 'single') {
            if (!value) {
                return null;
            }

            const retvalue = fillProps ? value[fillProps] : valueRender(value);
            // 0 => '0'
            return typeof retvalue === 'number'
                ? retvalue.toString()
                : retvalue;
        } else if (value) {
            let limitedCountValue = value;
            let maxTagPlaceholderEl;
            if (maxTagCount !== undefined && value.length > maxTagCount) {
                limitedCountValue = limitedCountValue.slice(0, maxTagCount);
                maxTagPlaceholderEl = (
                    <Tag
                        type="primary"
                        size={size === 'large' ? 'medium' : 'small'}
                        animation={false}
                    >
                        {`${value.length - maxTagCount}/${value.length}`}
                    </Tag>
                );
            }
            value = limitedCountValue;
            if (!Array.isArray(value)) {
                value = [value];
            }
            const selectedValueNodes = value.map(v => {
                if (!v) {
                    return null;
                }
                const labelNode = fillProps ? v[fillProps] : valueRender(v);
                let content = labelNode;
                if (
                    maxTagTextLength &&
                    typeof content === 'string' &&
                    content.length > maxTagTextLength
                ) {
                    content = `${content.slice(0, maxTagTextLength)}..`;
                }
                return (
                    <Tag
                        key={v.value}
                        disabled={disabled || v.disabled}
                        type="primary"
                        size={size === 'large' ? 'medium' : 'small'}
                        animation={false}
                        onClose={this.handleTagClose.bind(this, v)}
                        closable
                    >
                        {content}
                    </Tag>
                );
            });

            if (maxTagPlaceholderEl) {
                selectedValueNodes.push(maxTagPlaceholderEl);
            }
            return selectedValueNodes;
        }

        return null;
    }
>>>>>>> REPLACE
```

This change ensures that the `defaultValue` is considered when rendering the values, even if the `dataSource` is empty. This should resolve the issue where the `defaultValue` is not displayed as expected.
