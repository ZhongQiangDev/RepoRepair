{
    "repo/bpmn-io/bpmn-js/1011\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\rollup.config.js": {
        "function_1": {
            "signature": "",
            "content": "const configs = distros.reduce(function(configs, distro) {\n  const {\n    input,\n    output\n  } = distro;\n\n  return [\n    ...configs,\n    {\n      input: `./lib/${input}.js`,\n      output: {\n        name: 'BpmnJS',\n        file: `${outputDir}/${output}.development.js`,\n        format: 'umd'\n      },\n      plugins: pgl([\n        banner(output)\n      ])\n    },\n    {\n      input: `./lib/${input}.js`,\n      output: {\n        name: 'BpmnJS',\n        file: `${outputDir}/${output}.production.min.js`,\n        format: 'umd'\n      },\n      plugins: pgl([\n        banner(output, true),\n        uglify({\n          output: {\n            comments: /license|@preserve/\n          }\n        })\n      ])\n    }\n  ];\n}, []);",
            "name": "function_1",
            "parameters": [
                "configs",
                "distro"
            ],
            "start_line": 31,
            "end_line": 67,
            "return": true
        },
        "function_2": {
            "signature": "// helpers //////////////////////",
            "content": "function banner(bundleName, minified) {\n\n  const bannerName = (\n    minified\n      ? 'banner-min'\n      : 'banner'\n  );\n\n  const bannerTemplate = readFileSync(`${__dirname}/resources/${bannerName}.txt`, 'utf8');\n\n  const banner = processTemplate(bannerTemplate, {\n    version: pkg.version,\n    date: today(),\n    name: bundleName\n  });\n\n  return license({\n    banner\n  });\n}",
            "name": "banner",
            "parameters": [
                "bundleName",
                "minified"
            ],
            "start_line": 74,
            "end_line": 93,
            "return": true
        },
        "function_3": {
            "signature": "",
            "content": "function pgl(plugins=[]) {\n  return [\n    replace({\n      'process.env.NODE_ENV': JSON.stringify('production')\n    }),\n    nodeResolve({\n      module: true,\n      main: true,\n      browser: true\n    }),\n    commonjs(),\n    json(),\n    ...plugins\n  ];\n}",
            "name": "pgl",
            "parameters": [],
            "start_line": 95,
            "end_line": 109,
            "return": true
        },
        "function_4": {
            "signature": "",
            "content": "function pad(n) {\n  if (n < 10) {\n    return '0' + n;\n  } else {\n    return n;\n  }\n}",
            "name": "pad",
            "parameters": [
                "n"
            ],
            "start_line": 111,
            "end_line": 117,
            "return": true
        },
        "function_5": {
            "signature": "",
            "content": "function today() {\n  const d = new Date();\n\n  return [\n    d.getFullYear(),\n    pad(d.getMonth() + 1),\n    pad(d.getDate())\n  ].join('-');\n}",
            "name": "today",
            "parameters": [],
            "start_line": 119,
            "end_line": 127,
            "return": true
        },
        "function_6": {
            "signature": "",
            "content": "function processTemplate(str, args) {\n  return str.replace(/\\{\\{\\s*([^\\s]+)\\s*\\}\\}/g, function(_, n) {\n\n    var replacement = args[n];\n\n    if (!replacement) {\n      throw new Error('unknown template {{ ' + n + '}}');\n    }\n\n    return replacement;\n  });\n}",
            "name": "processTemplate",
            "parameters": [
                "str",
                "args"
            ],
            "start_line": 129,
            "end_line": 140,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\Modeler.js": {
        "function_1": {
            "signature": "/**\n* A modeler for BPMN 2.0 diagrams.\n*\n*\n* ## Extending the Modeler\n*\n* In order to extend the viewer pass extension modules to bootstrap via the\n* `additionalModules` option. An extension module is an object that exposes\n* named services.\n*\n* The following example depicts the integration of a simple\n* logging component that integrates with interaction events:\n*\n*\n* ```javascript\n*\n* // logging component\n* function InteractionLogger(eventBus) {\n*   eventBus.on('element.hover', function(event) {\n*     console.log()\n*   })\n* }\n*\n* InteractionLogger.$inject = [ 'eventBus' ]; // minification save\n*\n* // extension module\n* var extensionModule = {\n*   __init__: [ 'interactionLogger' ],\n*   interactionLogger: [ 'type', InteractionLogger ]\n* };\n*\n* // extend the viewer\n* var bpmnModeler = new Modeler({ additionalModules: [ extensionModule ] });\n* bpmnModeler.importXML(...);\n* ```\n*\n*\n* ## Customizing / Replacing Components\n*\n* You can replace individual diagram components by redefining them in override modules.\n* This works for all components, including those defined in the core.\n*\n* Pass in override modules via the `options.additionalModules` flag like this:\n*\n* ```javascript\n* function CustomContextPadProvider(contextPad) {\n*\n*   contextPad.registerProvider(this);\n*\n*   this.getContextPadEntries = function(element) {\n*     // no entries, effectively disable the context pad\n*     return {};\n*   };\n* }\n*\n* CustomContextPadProvider.$inject = [ 'contextPad' ];\n*\n* var overrideModule = {\n*   contextPadProvider: [ 'type', CustomContextPadProvider ]\n* };\n*\n* var bpmnModeler = new Modeler({ additionalModules: [ overrideModule ]});\n* ```\n*\n* @param {Object} [options] configuration options to pass to the viewer\n* @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.\n* @param {String|Number} [options.width] the width of the viewer\n* @param {String|Number} [options.height] the height of the viewer\n* @param {Object} [options.moddleExtensions] extension packages to provide\n* @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules\n* @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules\n*/",
            "content": "export default function Modeler(options) {\n  Viewer.call(this, options);\n\n  // hook ID collection into the modeler\n  this.on('import.parse.complete', function(event) {\n    if (!event.error) {\n      this._collectIds(event.definitions, event.context);\n    }\n  }, this);\n\n  this.on('diagram.destroy', function() {\n    this.get('moddle').ids.clear();\n  }, this);\n}",
            "name": "Modeler",
            "parameters": [
                "options"
            ],
            "start_line": 129,
            "end_line": 142,
            "return": false
        },
        "function_4": {
            "signature": "/**\n* Create a new diagram to start modeling.\n*\n* @param {Function} [done]\n*/",
            "content": "Modeler.prototype.createDiagram = function(done) {\n  return this.importXML(initialDiagram, done);\n};",
            "name": "function_4",
            "parameters": [
                "done"
            ],
            "start_line": 154,
            "end_line": 156,
            "return": true
        },
        "function_5": {
            "signature": "/**\n* Create a moddle instance, attaching ids to it.\n*\n* @param {Object} options\n*/",
            "content": "Modeler.prototype._createModdle = function(options) {\n  var moddle = Viewer.prototype._createModdle.call(this, options);\n\n  // attach ids to moddle to be able to track\n  // and validated ids in the BPMN 2.0 XML document\n  // tree\n  moddle.ids = new Ids([ 32, 36, 1 ]);\n\n  return moddle;\n};",
            "name": "function_5",
            "parameters": [
                "options"
            ],
            "start_line": 163,
            "end_line": 172,
            "return": true
        },
        "function_6": {
            "signature": "/**\n* Collect ids processed during parsing of the\n* definitions object.\n*\n* @param {ModdleElement} definitions\n* @param {Context} context\n*/",
            "content": "Modeler.prototype._collectIds = function(definitions, context) {\n\n  var moddle = definitions.$model,\n      ids = moddle.ids,\n      id;\n\n  // remove references from previous import\n  ids.clear();\n\n  for (id in context.elementsById) {\n    ids.claim(id, context.elementsById[id]);\n  }\n};",
            "name": "function_6",
            "parameters": [
                "definitions",
                "context"
            ],
            "start_line": 181,
            "end_line": 193,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\NavigatedViewer.js": {
        "function_1": {
            "signature": "/**\n* A viewer that includes mouse navigation facilities\n*\n* @param {Object} options\n*/",
            "content": "export default function NavigatedViewer(options) {\n  Viewer.call(this, options);\n}",
            "name": "NavigatedViewer",
            "parameters": [
                "options"
            ],
            "start_line": 14,
            "end_line": 16,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\Viewer.js": {
        "function_1": {
            "signature": "",
            "content": "function checkValidationError(err) {\n\n  // check if we can help the user by indicating wrong BPMN 2.0 xml\n  // (in case he or the exporting tool did not get that right)\n\n  var pattern = /unparsable content <([^>]+)> detected([\\s\\S]*)$/;\n  var match = pattern.exec(err.message);\n\n  if (match) {\n    err.message =\n      'unparsable content <' + match[1] + '> detected; ' +\n      'this may indicate an invalid BPMN 2.0 diagram file' + match[2];\n  }\n\n  return err;\n}",
            "name": "checkValidationError",
            "parameters": [
                "err"
            ],
            "start_line": 40,
            "end_line": 55,
            "return": true
        },
        "function_2": {
            "signature": "/**\n* Ensure the passed argument is a proper unit (defaulting to px)\n*/",
            "content": "function ensureUnit(val) {\n  return val + (isNumber(val) ? 'px' : '');\n}",
            "name": "ensureUnit",
            "parameters": [
                "val"
            ],
            "start_line": 67,
            "end_line": 69,
            "return": true
        },
        "function_3": {
            "signature": "/**\n* Find BPMNDiagram in definitions by ID\n*\n* @param {ModdleElement<Definitions>} definitions\n* @param {String} diagramId\n*\n* @return {ModdleElement<BPMNDiagram>|null}\n*/",
            "content": "function findBPMNDiagram(definitions, diagramId) {\n  if (!diagramId) {\n    return null;\n  }\n\n  return find(definitions.diagrams, function(element) {\n    return element.id === diagramId;\n  }) || null;\n}",
            "name": "findBPMNDiagram",
            "parameters": [
                "definitions",
                "diagramId"
            ],
            "start_line": 80,
            "end_line": 88,
            "return": true
        },
        "function_5": {
            "signature": "/**\n* A viewer for BPMN 2.0 diagrams.\n*\n* Have a look at {@link NavigatedViewer} or {@link Modeler} for bundles that include\n* additional features.\n*\n*\n* ## Extending the Viewer\n*\n* In order to extend the viewer pass extension modules to bootstrap via the\n* `additionalModules` option. An extension module is an object that exposes\n* named services.\n*\n* The following example depicts the integration of a simple\n* logging component that integrates with interaction events:\n*\n*\n* ```javascript\n*\n* // logging component\n* function InteractionLogger(eventBus) {\n*   eventBus.on('element.hover', function(event) {\n*     console.log()\n*   })\n* }\n*\n* InteractionLogger.$inject = [ 'eventBus' ]; // minification save\n*\n* // extension module\n* var extensionModule = {\n*   __init__: [ 'interactionLogger' ],\n*   interactionLogger: [ 'type', InteractionLogger ]\n* };\n*\n* // extend the viewer\n* var bpmnViewer = new Viewer({ additionalModules: [ extensionModule ] });\n* bpmnViewer.importXML(...);\n* ```\n*\n* @param {Object} [options] configuration options to pass to the viewer\n* @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.\n* @param {String|Number} [options.width] the width of the viewer\n* @param {String|Number} [options.height] the height of the viewer\n* @param {Object} [options.moddleExtensions] extension packages to provide\n* @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules\n* @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules\n*/",
            "content": "export default function Viewer(options) {\n\n  options = assign({}, DEFAULT_OPTIONS, options);\n\n  this._moddle = this._createModdle(options);\n\n  this._container = this._createContainer(options);\n\n  /* <project-logo> */\n\n  addProjectLogo(this._container);\n\n  /* </project-logo> */\n\n  this._init(this._container, this._moddle, options);\n}",
            "name": "Viewer",
            "parameters": [
                "options"
            ],
            "start_line": 137,
            "end_line": 152,
            "return": false
        },
        "function_6": {
            "signature": "/**\n* Parse and render a BPMN 2.0 diagram.\n*\n* Once finished the viewer reports back the result to the\n* provided callback function with (err, warnings).\n*\n* ## Life-Cycle Events\n*\n* During import the viewer will fire life-cycle events:\n*\n*   * import.parse.start (about to read model from xml)\n*   * import.parse.complete (model read; may have worked or not)\n*   * import.render.start (graphical import start)\n*   * import.render.complete (graphical import finished)\n*   * import.done (everything done)\n*\n* You can use these events to hook into the life-cycle.\n*\n* @param {String} xml the BPMN 2.0 xml\n* @param {ModdleElement<BPMNDiagram>|String} [bpmnDiagram] BPMN diagram or id of diagram to render (if not provided, the first one will be rendered)\n* @param {Function} [done] invoked with (err, warnings=[])\n*/",
            "content": "Viewer.prototype.importXML = function(xml, bpmnDiagram, done) {\n\n  if (isFunction(bpmnDiagram)) {\n    done = bpmnDiagram;\n    bpmnDiagram = null;\n  }\n\n  // done is optional\n  done = done || function() {};\n\n  var self = this;\n\n  // hook in pre-parse listeners +\n  // allow xml manipulation\n  xml = this._emit('import.parse.start', { xml: xml }) || xml;\n\n  this._moddle.fromXML(xml, 'bpmn:Definitions', function(err, definitions, context) {\n\n    // hook in post parse listeners +\n    // allow definitions manipulation\n    definitions = self._emit('import.parse.complete', {\n      error: err,\n      definitions: definitions,\n      context: context\n    }) || definitions;\n\n    var parseWarnings = context.warnings;\n\n    if (err) {\n      err = checkValidationError(err);\n\n      self._emit('import.done', { error: err, warnings: parseWarnings });\n\n      return done(err, parseWarnings);\n    }\n\n    self._setDefinitions(definitions);\n\n    self.open(bpmnDiagram, function(err, importWarnings) {\n      var allWarnings = [].concat(parseWarnings, importWarnings || []);\n\n      self._emit('import.done', { error: err, warnings: allWarnings });\n\n      done(err, allWarnings);\n    });\n  });\n};",
            "name": "function_6",
            "parameters": [
                "xml",
                "bpmnDiagram",
                "done"
            ],
            "start_line": 179,
            "end_line": 225,
            "return": true
        },
        "function_10": {
            "signature": "/**\n* Open diagram of previously imported XML.\n*\n* Once finished the viewer reports back the result to the\n* provided callback function with (err, warnings).\n*\n* ## Life-Cycle Events\n*\n* During switch the viewer will fire life-cycle events:\n*\n*   * import.render.start (graphical import start)\n*   * import.render.complete (graphical import finished)\n*\n* You can use these events to hook into the life-cycle.\n*\n* @param {String|ModdleElement<BPMNDiagram>} [bpmnDiagramOrId] id or the diagram to open\n* @param {Function} [done] invoked with (err, warnings=[])\n*/",
            "content": "Viewer.prototype.open = function(bpmnDiagramOrId, done) {\n\n  if (isFunction(bpmnDiagramOrId)) {\n    done = bpmnDiagramOrId;\n    bpmnDiagramOrId = null;\n  }\n\n  var definitions = this._definitions;\n  var bpmnDiagram = bpmnDiagramOrId;\n\n  // done is optional\n  done = done || function() {};\n\n  if (!definitions) {\n    return done(new Error('no XML imported'));\n  }\n\n  if (typeof bpmnDiagramOrId === 'string') {\n    bpmnDiagram = findBPMNDiagram(definitions, bpmnDiagramOrId);\n\n    if (!bpmnDiagram) {\n      return done(new Error('BPMNDiagram <' + bpmnDiagramOrId + '> not found'));\n    }\n  }\n\n  // clear existing rendered diagram\n  // catch synchronous exceptions during #clear()\n  try {\n    this.clear();\n  } catch (error) {\n    return done(error);\n  }\n\n  // perform graphical import\n  return importBpmnDiagram(this, definitions, bpmnDiagram, done);\n};",
            "name": "function_10",
            "parameters": [
                "bpmnDiagramOrId",
                "done"
            ],
            "start_line": 245,
            "end_line": 280,
            "return": true
        },
        "function_12": {
            "signature": "/**\n* Export the currently displayed BPMN 2.0 diagram as\n* a BPMN 2.0 XML document.\n*\n* ## Life-Cycle Events\n*\n* During XML saving the viewer will fire life-cycle events:\n*\n*   * saveXML.start (before serialization)\n*   * saveXML.serialized (after xml generation)\n*   * saveXML.done (everything done)\n*\n* You can use these events to hook into the life-cycle.\n*\n* @param {Object} [options] export options\n* @param {Boolean} [options.format=false] output formated XML\n* @param {Boolean} [options.preamble=true] output preamble\n*\n* @param {Function} done invoked with (err, xml)\n*/",
            "content": "Viewer.prototype.saveXML = function(options, done) {\n\n  if (!done) {\n    done = options;\n    options = {};\n  }\n\n  var self = this;\n\n  var definitions = this._definitions;\n\n  if (!definitions) {\n    return done(new Error('no definitions loaded'));\n  }\n\n  // allow to fiddle around with definitions\n  definitions = this._emit('saveXML.start', {\n    definitions: definitions\n  }) || definitions;\n\n  this._moddle.toXML(definitions, options, function(err, xml) {\n\n    try {\n      xml = self._emit('saveXML.serialized', {\n        error: err,\n        xml: xml\n      }) || xml;\n\n      self._emit('saveXML.done', {\n        error: err,\n        xml: xml\n      });\n    } catch (e) {\n      console.error('error in saveXML life-cycle listener', e);\n    }\n\n    done(err, xml);\n  });\n};",
            "name": "function_12",
            "parameters": [
                "options",
                "done"
            ],
            "start_line": 302,
            "end_line": 340,
            "return": true
        },
        "function_14": {
            "signature": "/**\n* Export the currently displayed BPMN 2.0 diagram as\n* an SVG image.\n*\n* ## Life-Cycle Events\n*\n* During SVG saving the viewer will fire life-cycle events:\n*\n*   * saveSVG.start (before serialization)\n*   * saveSVG.done (everything done)\n*\n* You can use these events to hook into the life-cycle.\n*\n* @param {Object} [options]\n* @param {Function} done invoked with (err, svgStr)\n*/",
            "content": "Viewer.prototype.saveSVG = function(options, done) {\n\n  if (!done) {\n    done = options;\n    options = {};\n  }\n\n  this._emit('saveSVG.start');\n\n  var svg, err;\n\n  try {\n    var canvas = this.get('canvas');\n\n    var contentNode = canvas.getDefaultLayer(),\n        defsNode = domQuery('defs', canvas._svg);\n\n    var contents = innerSVG(contentNode),\n        defs = defsNode ? '<defs>' + innerSVG(defsNode) + '</defs>' : '';\n\n    var bbox = contentNode.getBBox();\n\n    svg =\n      '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n' +\n      '<!-- created with bpmn-js / http://bpmn.io -->\\n' +\n      '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\\n' +\n      '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' +\n           'width=\"' + bbox.width + '\" height=\"' + bbox.height + '\" ' +\n           'viewBox=\"' + bbox.x + ' ' + bbox.y + ' ' + bbox.width + ' ' + bbox.height + '\" version=\"1.1\">' +\n        defs + contents +\n      '</svg>';\n  } catch (e) {\n    err = e;\n  }\n\n  this._emit('saveSVG.done', {\n    error: err,\n    svg: svg\n  });\n\n  done(err, svg);\n};",
            "name": "function_14",
            "parameters": [
                "options",
                "done"
            ],
            "start_line": 358,
            "end_line": 399,
            "return": false
        },
        "function_15": {
            "signature": "/**\n* Invoke a function in the context of this viewer.\n*\n* @example\n*\n* viewer.invoke(function(elementRegistry) {\n*   var startEventShape = elementRegistry.get('StartEvent_1');\n* });\n*\n* @param {Function} fn to be invoked\n*\n* @return {Object} the functions return value\n*\n* @method Viewer#invoke\n*/",
            "content": "Viewer.prototype._setDefinitions = function(definitions) {\n  this._definitions = definitions;\n};",
            "name": "function_15",
            "parameters": [
                "definitions"
            ],
            "start_line": 433,
            "end_line": 435,
            "return": false
        },
        "function_16": {
            "signature": "",
            "content": "Viewer.prototype.getModules = function() {\n  return this._modules;\n};",
            "name": "function_16",
            "parameters": [],
            "start_line": 437,
            "end_line": 439,
            "return": true
        },
        "function_17": {
            "signature": "/**\n* Remove all drawn elements from the viewer.\n*\n* After calling this method the viewer can still\n* be reused for opening another diagram.\n*\n* @method Viewer#clear\n*/",
            "content": "Viewer.prototype.clear = function() {\n\n  // remove businessObject#di binding\n  //\n  // this is necessary, as we establish the bindings\n  // in the BpmnTreeWalker (and assume none are given\n  // on reimport)\n  this.get('elementRegistry').forEach(function(element) {\n    var bo = element.businessObject;\n\n    if (bo && bo.di) {\n      delete bo.di;\n    }\n  });\n\n  // remove drawn elements\n  Diagram.prototype.clear.call(this);\n};",
            "name": "function_17",
            "parameters": [],
            "start_line": 449,
            "end_line": 466,
            "return": false
        },
        "function_19": {
            "signature": "/**\n* Destroy the viewer instance and remove all its\n* remainders from the document tree.\n*/",
            "content": "Viewer.prototype.destroy = function() {\n\n  // diagram destroy\n  Diagram.prototype.destroy.call(this);\n\n  // dom detach\n  domRemove(this._container);\n};",
            "name": "function_19",
            "parameters": [],
            "start_line": 472,
            "end_line": 479,
            "return": false
        },
        "function_20": {
            "signature": "/**\n* Register an event listener\n*\n* Remove a previously added listener via {@link #off(event, callback)}.\n*\n* @param {String} event\n* @param {Number} [priority]\n* @param {Function} callback\n* @param {Object} [that]\n*/",
            "content": "Viewer.prototype.on = function(event, priority, callback, target) {\n  return this.get('eventBus').on(event, priority, callback, target);\n};",
            "name": "function_20",
            "parameters": [
                "event",
                "priority",
                "callback",
                "target"
            ],
            "start_line": 491,
            "end_line": 493,
            "return": true
        },
        "function_21": {
            "signature": "/**\n* De-register an event listener\n*\n* @param {String} event\n* @param {Function} callback\n*/",
            "content": "Viewer.prototype.off = function(event, callback) {\n  this.get('eventBus').off(event, callback);\n};",
            "name": "function_21",
            "parameters": [
                "event",
                "callback"
            ],
            "start_line": 501,
            "end_line": 503,
            "return": false
        },
        "function_22": {
            "signature": "",
            "content": "Viewer.prototype.attachTo = function(parentNode) {\n\n  if (!parentNode) {\n    throw new Error('parentNode required');\n  }\n\n  // ensure we detach from the\n  // previous, old parent\n  this.detach();\n\n  // unwrap jQuery if provided\n  if (parentNode.get && parentNode.constructor.prototype.jquery) {\n    parentNode = parentNode.get(0);\n  }\n\n  if (typeof parentNode === 'string') {\n    parentNode = domQuery(parentNode);\n  }\n\n  parentNode.appendChild(this._container);\n\n  this._emit('attach', {});\n\n  this.get('canvas').resized();\n};",
            "name": "function_22",
            "parameters": [
                "parentNode"
            ],
            "start_line": 505,
            "end_line": 529,
            "return": false
        },
        "function_23": {
            "signature": "",
            "content": "Viewer.prototype.getDefinitions = function() {\n  return this._definitions;\n};",
            "name": "function_23",
            "parameters": [],
            "start_line": 531,
            "end_line": 533,
            "return": true
        },
        "function_24": {
            "signature": "",
            "content": "Viewer.prototype.detach = function() {\n\n  var container = this._container,\n      parentNode = container.parentNode;\n\n  if (!parentNode) {\n    return;\n  }\n\n  this._emit('detach', {});\n\n  parentNode.removeChild(container);\n};",
            "name": "function_24",
            "parameters": [],
            "start_line": 535,
            "end_line": 547,
            "return": true
        },
        "function_25": {
            "signature": "",
            "content": "Viewer.prototype._init = function(container, moddle, options) {\n\n  var baseModules = options.modules || this.getModules(),\n      additionalModules = options.additionalModules || [],\n      staticModules = [\n        {\n          bpmnjs: [ 'value', this ],\n          moddle: [ 'value', moddle ]\n        }\n      ];\n\n  var diagramModules = [].concat(staticModules, baseModules, additionalModules);\n\n  var diagramOptions = assign(omit(options, [ 'additionalModules' ]), {\n    canvas: assign({}, options.canvas, { container: container }),\n    modules: diagramModules\n  });\n\n  // invoke diagram constructor\n  Diagram.call(this, diagramOptions);\n\n  if (options && options.container) {\n    this.attachTo(options.container);\n  }\n};",
            "name": "function_25",
            "parameters": [
                "container",
                "moddle",
                "options"
            ],
            "start_line": 549,
            "end_line": 573,
            "return": false
        },
        "function_26": {
            "signature": "/**\n* Emit an event on the underlying {@link EventBus}\n*\n* @param  {String} type\n* @param  {Object} event\n*\n* @return {Object} event processing result (if any)\n*/",
            "content": "Viewer.prototype._emit = function(type, event) {\n  return this.get('eventBus').fire(type, event);\n};",
            "name": "function_26",
            "parameters": [
                "type",
                "event"
            ],
            "start_line": 583,
            "end_line": 585,
            "return": true
        },
        "function_27": {
            "signature": "",
            "content": "Viewer.prototype._createContainer = function(options) {\n\n  var container = domify('<div class=\"bjs-container\"></div>');\n\n  assign(container.style, {\n    width: ensureUnit(options.width),\n    height: ensureUnit(options.height),\n    position: options.position\n  });\n\n  return container;\n};",
            "name": "function_27",
            "parameters": [
                "options"
            ],
            "start_line": 587,
            "end_line": 598,
            "return": true
        },
        "function_28": {
            "signature": "",
            "content": "Viewer.prototype._createModdle = function(options) {\n  var moddleOptions = assign({}, this._moddleExtensions, options.moddleExtensions);\n\n  return new BpmnModdle(moddleOptions);\n};",
            "name": "function_28",
            "parameters": [
                "options"
            ],
            "start_line": 600,
            "end_line": 604,
            "return": true
        },
        "function_29": {
            "signature": "/**\n* Adds the project logo to the diagram container as\n* required by the bpmn.io license.\n*\n* @see http://bpmn.io/license\n*\n* @param {Element} container\n*/",
            "content": "function addProjectLogo(container) {\n  var img = BPMNIO_IMG;\n\n  var linkMarkup =\n    '<a href=\"http://bpmn.io\" ' +\n       'target=\"_blank\" ' +\n       'class=\"bjs-powered-by\" ' +\n       'title=\"Powered by bpmn.io\" ' +\n       'style=\"position: absolute; bottom: 15px; right: 15px; z-index: 100\">' +\n      img +\n    '</a>';\n\n  var linkElement = domify(linkMarkup);\n\n  container.appendChild(linkElement);\n\n  domEvent.bind(linkElement, 'click', function(event) {\n    openPoweredBy();\n\n    event.preventDefault();\n  });\n}",
            "name": "addProjectLogo",
            "parameters": [
                "container"
            ],
            "start_line": 636,
            "end_line": 657,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\core\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\draw\\BpmnRenderer.js": {
        "function_1": {
            "signature": "",
            "content": "export default function BpmnRenderer(\n    config, eventBus, styles, pathMap,\n    canvas, textRenderer, priority) {\n\n  BaseRenderer.call(this, eventBus, priority);\n\n  var defaultFillColor = config && config.defaultFillColor,\n      defaultStrokeColor = config && config.defaultStrokeColor;\n\n  var rendererId = RENDERER_IDS.next();\n\n  var markers = {};\n\n  var computeStyle = styles.computeStyle;\n\n  function addMarker(id, options) {\n    var attrs = assign({\n      fill: 'black',\n      strokeWidth: 1,\n      strokeLinecap: 'round',\n      strokeDasharray: 'none'\n    }, options.attrs);\n\n    var ref = options.ref || { x: 0, y: 0 };\n\n    var scale = options.scale || 1;\n\n    // fix for safari / chrome / firefox bug not correctly\n    // resetting stroke dash array\n    if (attrs.strokeDasharray === 'none') {\n      attrs.strokeDasharray = [10000, 1];\n    }\n\n    var marker = svgCreate('marker');\n\n    svgAttr(options.element, attrs);\n\n    svgAppend(marker, options.element);\n\n    svgAttr(marker, {\n      id: id,\n      viewBox: '0 0 20 20',\n      refX: ref.x,\n      refY: ref.y,\n      markerWidth: 20 * scale,\n      markerHeight: 20 * scale,\n      orient: 'auto'\n    });\n\n    var defs = domQuery('defs', canvas._svg);\n\n    if (!defs) {\n      defs = svgCreate('defs');\n\n      svgAppend(canvas._svg, defs);\n    }\n\n    svgAppend(defs, marker);\n\n    markers[id] = marker;\n  }\n\n  function colorEscape(str) {\n    return str.replace(/[()\\s,#]+/g, '_');\n  }\n\n  function marker(type, fill, stroke) {\n    var id = type + '-' + colorEscape(fill) + '-' + colorEscape(stroke) + '-' + rendererId;\n\n    if (!markers[id]) {\n      createMarker(id, type, fill, stroke);\n    }\n\n    return 'url(#' + id + ')';\n  }\n\n  function createMarker(id, type, fill, stroke) {\n\n    if (type === 'sequenceflow-end') {\n      var sequenceflowEnd = svgCreate('path');\n      svgAttr(sequenceflowEnd, { d: 'M 1 5 L 11 10 L 1 15 Z' });\n\n      addMarker(id, {\n        element: sequenceflowEnd,\n        ref: { x: 11, y: 10 },\n        scale: 0.5,\n        attrs: {\n          fill: stroke,\n          stroke: stroke\n        }\n      });\n    }\n\n    if (type === 'messageflow-start') {\n      var messageflowStart = svgCreate('circle');\n      svgAttr(messageflowStart, { cx: 6, cy: 6, r: 3.5 });\n\n      addMarker(id, {\n        element: messageflowStart,\n        attrs: {\n          fill: fill,\n          stroke: stroke\n        },\n        ref: { x: 6, y: 6 }\n      });\n    }\n\n    if (type === 'messageflow-end') {\n      var messageflowEnd = svgCreate('path');\n      svgAttr(messageflowEnd, { d: 'm 1 5 l 0 -3 l 7 3 l -7 3 z' });\n\n      addMarker(id, {\n        element: messageflowEnd,\n        attrs: {\n          fill: fill,\n          stroke: stroke,\n          strokeLinecap: 'butt'\n        },\n        ref: { x: 8.5, y: 5 }\n      });\n    }\n\n    if (type === 'association-start') {\n      var associationStart = svgCreate('path');\n      svgAttr(associationStart, { d: 'M 11 5 L 1 10 L 11 15' });\n\n      addMarker(id, {\n        element: associationStart,\n        attrs: {\n          fill: 'none',\n          stroke: stroke,\n          strokeWidth: 1.5\n        },\n        ref: { x: 1, y: 10 },\n        scale: 0.5\n      });\n    }\n\n    if (type === 'association-end') {\n      var associationEnd = svgCreate('path');\n      svgAttr(associationEnd, { d: 'M 1 5 L 11 10 L 1 15' });\n\n      addMarker(id, {\n        element: associationEnd,\n        attrs: {\n          fill: 'none',\n          stroke: stroke,\n          strokeWidth: 1.5\n        },\n        ref: { x: 12, y: 10 },\n        scale: 0.5\n      });\n    }\n\n    if (type === 'conditional-flow-marker') {\n      var conditionalflowMarker = svgCreate('path');\n      svgAttr(conditionalflowMarker, { d: 'M 0 10 L 8 6 L 16 10 L 8 14 Z' });\n\n      addMarker(id, {\n        element: conditionalflowMarker,\n        attrs: {\n          fill: fill,\n          stroke: stroke\n        },\n        ref: { x: -1, y: 10 },\n        scale: 0.5\n      });\n    }\n\n    if (type === 'conditional-default-flow-marker') {\n      var conditionaldefaultflowMarker = svgCreate('path');\n      svgAttr(conditionaldefaultflowMarker, { d: 'M 6 4 L 10 16' });\n\n      addMarker(id, {\n        element: conditionaldefaultflowMarker,\n        attrs: {\n          stroke: stroke\n        },\n        ref: { x: 0, y: 10 },\n        scale: 0.5\n      });\n    }\n  }\n\n  function drawCircle(parentGfx, width, height, offset, attrs) {\n\n    if (isObject(offset)) {\n      attrs = offset;\n      offset = 0;\n    }\n\n    offset = offset || 0;\n\n    attrs = computeStyle(attrs, {\n      stroke: 'black',\n      strokeWidth: 2,\n      fill: 'white'\n    });\n\n    if (attrs.fill === 'none') {\n      delete attrs.fillOpacity;\n    }\n\n    var cx = width / 2,\n        cy = height / 2;\n\n    var circle = svgCreate('circle');\n    svgAttr(circle, {\n      cx: cx,\n      cy: cy,\n      r: Math.round((width + height) / 4 - offset)\n    });\n    svgAttr(circle, attrs);\n\n    svgAppend(parentGfx, circle);\n\n    return circle;\n  }\n\n  function drawRect(parentGfx, width, height, r, offset, attrs) {\n\n    if (isObject(offset)) {\n      attrs = offset;\n      offset = 0;\n    }\n\n    offset = offset || 0;\n\n    attrs = computeStyle(attrs, {\n      stroke: 'black',\n      strokeWidth: 2,\n      fill: 'white'\n    });\n\n    var rect = svgCreate('rect');\n    svgAttr(rect, {\n      x: offset,\n      y: offset,\n      width: width - offset * 2,\n      height: height - offset * 2,\n      rx: r,\n      ry: r\n    });\n    svgAttr(rect, attrs);\n\n    svgAppend(parentGfx, rect);\n\n    return rect;\n  }\n\n  function drawDiamond(parentGfx, width, height, attrs) {\n\n    var x_2 = width / 2;\n    var y_2 = height / 2;\n\n    var points = [{ x: x_2, y: 0 }, { x: width, y: y_2 }, { x: x_2, y: height }, { x: 0, y: y_2 }];\n\n    var pointsString = points.map(function(point) {\n      return point.x + ',' + point.y;\n    }).join(' ');\n\n    attrs = computeStyle(attrs, {\n      stroke: 'black',\n      strokeWidth: 2,\n      fill: 'white'\n    });\n\n    var polygon = svgCreate('polygon');\n    svgAttr(polygon, {\n      points: pointsString\n    });\n    svgAttr(polygon, attrs);\n\n    svgAppend(parentGfx, polygon);\n\n    return polygon;\n  }\n\n  function drawLine(parentGfx, waypoints, attrs) {\n    attrs = computeStyle(attrs, [ 'no-fill' ], {\n      stroke: 'black',\n      strokeWidth: 2,\n      fill: 'none'\n    });\n\n    var line = createLine(waypoints, attrs);\n\n    svgAppend(parentGfx, line);\n\n    return line;\n  }\n\n  function drawPath(parentGfx, d, attrs) {\n\n    attrs = computeStyle(attrs, [ 'no-fill' ], {\n      strokeWidth: 2,\n      stroke: 'black'\n    });\n\n    var path = svgCreate('path');\n    svgAttr(path, { d: d });\n    svgAttr(path, attrs);\n\n    svgAppend(parentGfx, path);\n\n    return path;\n  }\n\n  function drawMarker(type, parentGfx, path, attrs) {\n    return drawPath(parentGfx, path, assign({ 'data-marker': type }, attrs));\n  }\n\n  function as(type) {\n    return function(parentGfx, element) {\n      return handlers[type](parentGfx, element);\n    };\n  }\n\n  function renderer(type) {\n    return handlers[type];\n  }\n\n  function renderEventContent(element, parentGfx) {\n\n    var event = getSemantic(element);\n    var isThrowing = isThrowEvent(event);\n\n    if (isTypedEvent(event, 'bpmn:MessageEventDefinition')) {\n      return renderer('bpmn:MessageEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:TimerEventDefinition')) {\n      return renderer('bpmn:TimerEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:ConditionalEventDefinition')) {\n      return renderer('bpmn:ConditionalEventDefinition')(parentGfx, element);\n    }\n\n    if (isTypedEvent(event, 'bpmn:SignalEventDefinition')) {\n      return renderer('bpmn:SignalEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:CancelEventDefinition') &&\n      isTypedEvent(event, 'bpmn:TerminateEventDefinition', { parallelMultiple: false })) {\n      return renderer('bpmn:MultipleEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:CancelEventDefinition') &&\n      isTypedEvent(event, 'bpmn:TerminateEventDefinition', { parallelMultiple: true })) {\n      return renderer('bpmn:ParallelMultipleEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:EscalationEventDefinition')) {\n      return renderer('bpmn:EscalationEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:LinkEventDefinition')) {\n      return renderer('bpmn:LinkEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:ErrorEventDefinition')) {\n      return renderer('bpmn:ErrorEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:CancelEventDefinition')) {\n      return renderer('bpmn:CancelEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:CompensateEventDefinition')) {\n      return renderer('bpmn:CompensateEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    if (isTypedEvent(event, 'bpmn:TerminateEventDefinition')) {\n      return renderer('bpmn:TerminateEventDefinition')(parentGfx, element, isThrowing);\n    }\n\n    return null;\n  }\n\n  function renderLabel(parentGfx, label, options) {\n\n    options = assign({\n      size: {\n        width: 100\n      }\n    }, options);\n\n    var text = textRenderer.createText(label || '', options);\n\n    svgClasses(text).add('djs-label');\n\n    svgAppend(parentGfx, text);\n\n    return text;\n  }\n\n  function renderEmbeddedLabel(parentGfx, element, align) {\n    var semantic = getSemantic(element);\n\n    return renderLabel(parentGfx, semantic.name, {\n      box: element,\n      align: align,\n      padding: 5,\n      style: {\n        fill: getStrokeColor(element, defaultStrokeColor)\n      }\n    });\n  }\n\n  function renderExternalLabel(parentGfx, element) {\n    var semantic = getSemantic(element);\n    var box = {\n      width: 90,\n      height: 30,\n      x: element.width / 2 + element.x,\n      y: element.height / 2 + element.y\n    };\n\n    return renderLabel(parentGfx, semantic.name, {\n      box: box,\n      fitBox: true,\n      style: assign(\n        {},\n        textRenderer.getExternalStyle(),\n        {\n          fill: getStrokeColor(element, defaultStrokeColor)\n        }\n      )\n    });\n  }\n\n  function renderLaneLabel(parentGfx, text, element) {\n    var textBox = renderLabel(parentGfx, text, {\n      box: {\n        height: 30,\n        width: element.height\n      },\n      align: 'center-middle',\n      style: {\n        fill: getStrokeColor(element, defaultStrokeColor)\n      }\n    });\n\n    var top = -1 * element.height;\n\n    transform(textBox, 0, -top, 270);\n  }\n\n  function createPathFromConnection(connection) {\n    var waypoints = connection.waypoints;\n\n    var pathData = 'm  ' + waypoints[0].x + ',' + waypoints[0].y;\n    for (var i = 1; i < waypoints.length; i++) {\n      pathData += 'L' + waypoints[i].x + ',' + waypoints[i].y + ' ';\n    }\n    return pathData;\n  }\n\n  var handlers = this.handlers = {\n    'bpmn:Event': function(parentGfx, element, attrs) {\n\n      if (!('fillOpacity' in attrs)) {\n        attrs.fillOpacity = DEFAULT_FILL_OPACITY;\n      }\n\n      return drawCircle(parentGfx, element.width, element.height, attrs);\n    },\n    'bpmn:StartEvent': function(parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      };\n\n      var semantic = getSemantic(element);\n\n      if (!semantic.isInterrupting) {\n        attrs = {\n          strokeDasharray: '6',\n          strokeLinecap: 'round',\n          fill: getFillColor(element, defaultFillColor),\n          stroke: getStrokeColor(element, defaultStrokeColor)\n        };\n      }\n\n      var circle = renderer('bpmn:Event')(parentGfx, element, attrs);\n\n      renderEventContent(element, parentGfx);\n\n      return circle;\n    },\n    'bpmn:MessageEventDefinition': function(parentGfx, element, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_MESSAGE', {\n        xScaleFactor: 0.9,\n        yScaleFactor: 0.9,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.235,\n          my: 0.315\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(element, defaultStrokeColor) : getFillColor(element, defaultFillColor);\n      var stroke = isThrowing ? getFillColor(element, defaultFillColor) : getStrokeColor(element, defaultStrokeColor);\n\n      var messagePath = drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: stroke\n      });\n\n      return messagePath;\n    },\n    'bpmn:TimerEventDefinition': function(parentGfx, element) {\n      var circle = drawCircle(parentGfx, element.width, element.height, 0.2 * element.height, {\n        strokeWidth: 2,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      var pathData = pathMap.getScaledPath('EVENT_TIMER_WH', {\n        xScaleFactor: 0.75,\n        yScaleFactor: 0.75,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.5,\n          my: 0.5\n        }\n      });\n\n      drawPath(parentGfx, pathData, {\n        strokeWidth: 2,\n        strokeLinecap: 'square',\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      for (var i = 0;i < 12; i++) {\n\n        var linePathData = pathMap.getScaledPath('EVENT_TIMER_LINE', {\n          xScaleFactor: 0.75,\n          yScaleFactor: 0.75,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0.5,\n            my: 0.5\n          }\n        });\n\n        var width = element.width / 2;\n        var height = element.height / 2;\n\n        drawPath(parentGfx, linePathData, {\n          strokeWidth: 1,\n          strokeLinecap: 'square',\n          transform: 'rotate(' + (i * 30) + ',' + height + ',' + width + ')',\n          stroke: getStrokeColor(element, defaultStrokeColor)\n        });\n      }\n\n      return circle;\n    },\n    'bpmn:EscalationEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_ESCALATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.5,\n          my: 0.2\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event, defaultStrokeColor) : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event, defaultStrokeColor)\n      });\n    },\n    'bpmn:ConditionalEventDefinition': function(parentGfx, event) {\n      var pathData = pathMap.getScaledPath('EVENT_CONDITIONAL', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.5,\n          my: 0.222\n        }\n      });\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        stroke: getStrokeColor(event, defaultStrokeColor)\n      });\n    },\n    'bpmn:LinkEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_LINK', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.57,\n          my: 0.263\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event, defaultStrokeColor) : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event, defaultStrokeColor)\n      });\n    },\n    'bpmn:ErrorEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_ERROR', {\n        xScaleFactor: 1.1,\n        yScaleFactor: 1.1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.2,\n          my: 0.722\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event, defaultStrokeColor) : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event, defaultStrokeColor)\n      });\n    },\n    'bpmn:CancelEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_CANCEL_45', {\n        xScaleFactor: 1.0,\n        yScaleFactor: 1.0,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.638,\n          my: -0.055\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event, defaultStrokeColor) : 'none';\n\n      var path = drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event, defaultStrokeColor)\n      });\n\n      rotate(path, 45);\n\n      return path;\n    },\n    'bpmn:CompensateEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_COMPENSATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.22,\n          my: 0.5\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event, defaultStrokeColor) : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event, defaultStrokeColor)\n      });\n    },\n    'bpmn:SignalEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_SIGNAL', {\n        xScaleFactor: 0.9,\n        yScaleFactor: 0.9,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.5,\n          my: 0.2\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event, defaultStrokeColor) : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill,\n        stroke: getStrokeColor(event, defaultStrokeColor)\n      });\n    },\n    'bpmn:MultipleEventDefinition': function(parentGfx, event, isThrowing) {\n      var pathData = pathMap.getScaledPath('EVENT_MULTIPLE', {\n        xScaleFactor: 1.1,\n        yScaleFactor: 1.1,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.222,\n          my: 0.36\n        }\n      });\n\n      var fill = isThrowing ? getStrokeColor(event, defaultStrokeColor) : 'none';\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: fill\n      });\n    },\n    'bpmn:ParallelMultipleEventDefinition': function(parentGfx, event) {\n      var pathData = pathMap.getScaledPath('EVENT_PARALLEL_MULTIPLE', {\n        xScaleFactor: 1.2,\n        yScaleFactor: 1.2,\n        containerWidth: event.width,\n        containerHeight: event.height,\n        position: {\n          mx: 0.458,\n          my: 0.194\n        }\n      });\n\n      return drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getStrokeColor(event, defaultStrokeColor),\n        stroke: getStrokeColor(event, defaultStrokeColor)\n      });\n    },\n    'bpmn:EndEvent': function(parentGfx, element) {\n      var circle = renderer('bpmn:Event')(parentGfx, element, {\n        strokeWidth: 4,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      renderEventContent(element, parentGfx, true);\n\n      return circle;\n    },\n    'bpmn:TerminateEventDefinition': function(parentGfx, element) {\n      var circle = drawCircle(parentGfx, element.width, element.height, 8, {\n        strokeWidth: 4,\n        fill: getStrokeColor(element, defaultStrokeColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      return circle;\n    },\n    'bpmn:IntermediateEvent': function(parentGfx, element) {\n      var outer = renderer('bpmn:Event')(parentGfx, element, {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      /* inner */\n      drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {\n        strokeWidth: 1,\n        fill: getFillColor(element, 'none'),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      renderEventContent(element, parentGfx);\n\n      return outer;\n    },\n    'bpmn:IntermediateCatchEvent': as('bpmn:IntermediateEvent'),\n    'bpmn:IntermediateThrowEvent': as('bpmn:IntermediateEvent'),\n\n    'bpmn:Activity': function(parentGfx, element, attrs) {\n\n      attrs = attrs || {};\n\n      if (!('fillOpacity' in attrs)) {\n        attrs.fillOpacity = DEFAULT_FILL_OPACITY;\n      }\n\n      return drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, attrs);\n    },\n\n    'bpmn:Task': function(parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      };\n\n      var rect = renderer('bpmn:Activity')(parentGfx, element, attrs);\n\n      renderEmbeddedLabel(parentGfx, element, 'center-middle');\n      attachTaskMarkers(parentGfx, element);\n\n      return rect;\n    },\n    'bpmn:ServiceTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var pathDataBG = pathMap.getScaledPath('TASK_TYPE_SERVICE', {\n        abspos: {\n          x: 12,\n          y: 18\n        }\n      });\n\n      /* service bg */ drawPath(parentGfx, pathDataBG, {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      var fillPathData = pathMap.getScaledPath('TASK_TYPE_SERVICE_FILL', {\n        abspos: {\n          x: 17.2,\n          y: 18\n        }\n      });\n\n      /* service fill */ drawPath(parentGfx, fillPathData, {\n        strokeWidth: 0,\n        fill: getFillColor(element, defaultFillColor)\n      });\n\n      var pathData = pathMap.getScaledPath('TASK_TYPE_SERVICE', {\n        abspos: {\n          x: 17,\n          y: 22\n        }\n      });\n\n      /* service */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      return task;\n    },\n    'bpmn:UserTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var x = 15;\n      var y = 12;\n\n      var pathData = pathMap.getScaledPath('TASK_TYPE_USER_1', {\n        abspos: {\n          x: x,\n          y: y\n        }\n      });\n\n      /* user path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 0.5,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      var pathData2 = pathMap.getScaledPath('TASK_TYPE_USER_2', {\n        abspos: {\n          x: x,\n          y: y\n        }\n      });\n\n      /* user2 path */ drawPath(parentGfx, pathData2, {\n        strokeWidth: 0.5,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      var pathData3 = pathMap.getScaledPath('TASK_TYPE_USER_3', {\n        abspos: {\n          x: x,\n          y: y\n        }\n      });\n\n      /* user3 path */ drawPath(parentGfx, pathData3, {\n        strokeWidth: 0.5,\n        fill: getStrokeColor(element, defaultStrokeColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      return task;\n    },\n    'bpmn:ManualTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var pathData = pathMap.getScaledPath('TASK_TYPE_MANUAL', {\n        abspos: {\n          x: 17,\n          y: 15\n        }\n      });\n\n      /* manual path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 0.5, // 0.25,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      return task;\n    },\n    'bpmn:SendTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: 21,\n        containerHeight: 14,\n        position: {\n          mx: 0.285,\n          my: 0.357\n        }\n      });\n\n      /* send path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getStrokeColor(element, defaultStrokeColor),\n        stroke: getFillColor(element, defaultFillColor)\n      });\n\n      return task;\n    },\n    'bpmn:ReceiveTask' : function(parentGfx, element) {\n      var semantic = getSemantic(element);\n\n      var task = renderer('bpmn:Task')(parentGfx, element);\n      var pathData;\n\n      if (semantic.instantiate) {\n        drawCircle(parentGfx, 28, 28, 20 * 0.22, { strokeWidth: 1 });\n\n        pathData = pathMap.getScaledPath('TASK_TYPE_INSTANTIATING_SEND', {\n          abspos: {\n            x: 7.77,\n            y: 9.52\n          }\n        });\n      } else {\n\n        pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {\n          xScaleFactor: 0.9,\n          yScaleFactor: 0.9,\n          containerWidth: 21,\n          containerHeight: 14,\n          position: {\n            mx: 0.3,\n            my: 0.4\n          }\n        });\n      }\n\n      /* receive path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      return task;\n    },\n    'bpmn:ScriptTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var pathData = pathMap.getScaledPath('TASK_TYPE_SCRIPT', {\n        abspos: {\n          x: 15,\n          y: 20\n        }\n      });\n\n      /* script path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      return task;\n    },\n    'bpmn:BusinessRuleTask': function(parentGfx, element) {\n      var task = renderer('bpmn:Task')(parentGfx, element);\n\n      var headerPathData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_HEADER', {\n        abspos: {\n          x: 8,\n          y: 8\n        }\n      });\n\n      var businessHeaderPath = drawPath(parentGfx, headerPathData);\n      svgAttr(businessHeaderPath, {\n        strokeWidth: 1,\n        fill: getFillColor(element, '#aaaaaa'),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      var headerData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_MAIN', {\n        abspos: {\n          x: 8,\n          y: 8\n        }\n      });\n\n      var businessPath = drawPath(parentGfx, headerData);\n      svgAttr(businessPath, {\n        strokeWidth: 1,\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      return task;\n    },\n    'bpmn:SubProcess': function(parentGfx, element, attrs) {\n      attrs = assign({\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      }, attrs);\n\n      var rect = renderer('bpmn:Activity')(parentGfx, element, attrs);\n\n      var expanded = isExpanded(element);\n\n      if (isEventSubProcess(element)) {\n        svgAttr(rect, {\n          strokeDasharray: '1,2'\n        });\n      }\n\n      renderEmbeddedLabel(parentGfx, element, expanded ? 'center-top' : 'center-middle');\n\n      if (expanded) {\n        attachTaskMarkers(parentGfx, element);\n      } else {\n        attachTaskMarkers(parentGfx, element, ['SubProcessMarker']);\n      }\n\n      return rect;\n    },\n    'bpmn:AdHocSubProcess': function(parentGfx, element) {\n      return renderer('bpmn:SubProcess')(parentGfx, element);\n    },\n    'bpmn:Transaction': function(parentGfx, element) {\n      var outer = renderer('bpmn:SubProcess')(parentGfx, element);\n\n      var innerAttrs = styles.style([ 'no-fill', 'no-events' ], {\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      /* inner path */ drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS - 2, INNER_OUTER_DIST, innerAttrs);\n\n      return outer;\n    },\n    'bpmn:CallActivity': function(parentGfx, element) {\n      return renderer('bpmn:SubProcess')(parentGfx, element, {\n        strokeWidth: 5\n      });\n    },\n    'bpmn:Participant': function(parentGfx, element) {\n\n      var attrs = {\n        fillOpacity: DEFAULT_FILL_OPACITY,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      };\n\n      var lane = renderer('bpmn:Lane')(parentGfx, element, attrs);\n\n      var expandedPool = isExpanded(element);\n\n      if (expandedPool) {\n        drawLine(parentGfx, [\n          { x: 30, y: 0 },\n          { x: 30, y: element.height }\n        ], {\n          stroke: getStrokeColor(element, defaultStrokeColor)\n        });\n        var text = getSemantic(element).name;\n        renderLaneLabel(parentGfx, text, element);\n      } else {\n        // Collapsed pool draw text inline\n        var text2 = getSemantic(element).name;\n        renderLabel(parentGfx, text2, {\n          box: element, align: 'center-middle',\n          style: {\n            fill: getStrokeColor(element, defaultStrokeColor)\n          }\n        });\n      }\n\n      var participantMultiplicity = !!(getSemantic(element).participantMultiplicity);\n\n      if (participantMultiplicity) {\n        renderer('ParticipantMultiplicityMarker')(parentGfx, element);\n      }\n\n      return lane;\n    },\n    'bpmn:Lane': function(parentGfx, element, attrs) {\n      var rect = drawRect(parentGfx, element.width, element.height, 0, assign({\n        fill: getFillColor(element, defaultFillColor),\n        fillOpacity: HIGH_FILL_OPACITY,\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      }, attrs));\n\n      var semantic = getSemantic(element);\n\n      if (semantic.$type === 'bpmn:Lane') {\n        var text = semantic.name;\n        renderLaneLabel(parentGfx, text, element);\n      }\n\n      return rect;\n    },\n    'bpmn:InclusiveGateway': function(parentGfx, element) {\n      var diamond = renderer('bpmn:Gateway')(parentGfx, element);\n\n      /* circle path */\n      drawCircle(parentGfx, element.width, element.height, element.height * 0.24, {\n        strokeWidth: 2.5,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      return diamond;\n    },\n    'bpmn:ExclusiveGateway': function(parentGfx, element) {\n      var diamond = renderer('bpmn:Gateway')(parentGfx, element);\n\n      var pathData = pathMap.getScaledPath('GATEWAY_EXCLUSIVE', {\n        xScaleFactor: 0.4,\n        yScaleFactor: 0.4,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.32,\n          my: 0.3\n        }\n      });\n\n      if ((getDi(element).isMarkerVisible)) {\n        drawPath(parentGfx, pathData, {\n          strokeWidth: 1,\n          fill: getStrokeColor(element, defaultStrokeColor),\n          stroke: getStrokeColor(element, defaultStrokeColor)\n        });\n      }\n\n      return diamond;\n    },\n    'bpmn:ComplexGateway': function(parentGfx, element) {\n      var diamond = renderer('bpmn:Gateway')(parentGfx, element);\n\n      var pathData = pathMap.getScaledPath('GATEWAY_COMPLEX', {\n        xScaleFactor: 0.5,\n        yScaleFactor:0.5,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.46,\n          my: 0.26\n        }\n      });\n\n      /* complex path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getStrokeColor(element, defaultStrokeColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      return diamond;\n    },\n    'bpmn:ParallelGateway': function(parentGfx, element) {\n      var diamond = renderer('bpmn:Gateway')(parentGfx, element);\n\n      var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {\n        xScaleFactor: 0.6,\n        yScaleFactor:0.6,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.46,\n          my: 0.2\n        }\n      });\n\n      /* parallel path */ drawPath(parentGfx, pathData, {\n        strokeWidth: 1,\n        fill: getStrokeColor(element, defaultStrokeColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      return diamond;\n    },\n    'bpmn:EventBasedGateway': function(parentGfx, element) {\n\n      var semantic = getSemantic(element);\n\n      var diamond = renderer('bpmn:Gateway')(parentGfx, element);\n\n      /* outer circle path */ drawCircle(parentGfx, element.width, element.height, element.height * 0.20, {\n        strokeWidth: 1,\n        fill: 'none',\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      var type = semantic.eventGatewayType;\n      var instantiate = !!semantic.instantiate;\n\n      function drawEvent() {\n\n        var pathData = pathMap.getScaledPath('GATEWAY_EVENT_BASED', {\n          xScaleFactor: 0.18,\n          yScaleFactor: 0.18,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0.36,\n            my: 0.44\n          }\n        });\n\n        var attrs = {\n          strokeWidth: 2,\n          fill: getFillColor(element, 'none'),\n          stroke: getStrokeColor(element, defaultStrokeColor)\n        };\n\n        /* event path */ drawPath(parentGfx, pathData, attrs);\n      }\n\n      if (type === 'Parallel') {\n\n        var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {\n          xScaleFactor: 0.4,\n          yScaleFactor:0.4,\n          containerWidth: element.width,\n          containerHeight: element.height,\n          position: {\n            mx: 0.474,\n            my: 0.296\n          }\n        });\n\n        var parallelPath = drawPath(parentGfx, pathData);\n        svgAttr(parallelPath, {\n          strokeWidth: 1,\n          fill: 'none'\n        });\n      } else if (type === 'Exclusive') {\n\n        if (!instantiate) {\n          var innerCircle = drawCircle(parentGfx, element.width, element.height, element.height * 0.26);\n          svgAttr(innerCircle, {\n            strokeWidth: 1,\n            fill: 'none',\n            stroke: getStrokeColor(element, defaultStrokeColor)\n          });\n        }\n\n        drawEvent();\n      }\n\n\n      return diamond;\n    },\n    'bpmn:Gateway': function(parentGfx, element) {\n      var attrs = {\n        fill: getFillColor(element, defaultFillColor),\n        fillOpacity: DEFAULT_FILL_OPACITY,\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      };\n\n      return drawDiamond(parentGfx, element.width, element.height, attrs);\n    },\n    'bpmn:SequenceFlow': function(parentGfx, element) {\n      var pathData = createPathFromConnection(element);\n\n      var fill = getFillColor(element, defaultFillColor),\n          stroke = getStrokeColor(element, defaultStrokeColor);\n\n      var attrs = {\n        strokeLinejoin: 'round',\n        markerEnd: marker('sequenceflow-end', fill, stroke),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      };\n\n      var path = drawPath(parentGfx, pathData, attrs);\n\n      var sequenceFlow = getSemantic(element);\n\n      var source;\n\n      if (element.source) {\n        source = element.source.businessObject;\n\n        // conditional flow marker\n        if (sequenceFlow.conditionExpression && source.$instanceOf('bpmn:Activity')) {\n          svgAttr(path, {\n            markerStart: marker('conditional-flow-marker', fill, stroke)\n          });\n        }\n\n        // default marker\n        if (source.default && (source.$instanceOf('bpmn:Gateway') || source.$instanceOf('bpmn:Activity')) &&\n            source.default === sequenceFlow) {\n          svgAttr(path, {\n            markerStart: marker('conditional-default-flow-marker', fill, stroke)\n          });\n        }\n      }\n\n      return path;\n    },\n    'bpmn:Association': function(parentGfx, element, attrs) {\n\n      var semantic = getSemantic(element);\n\n      var fill = getFillColor(element, defaultFillColor),\n          stroke = getStrokeColor(element, defaultStrokeColor);\n\n      attrs = assign({\n        strokeDasharray: '0.5, 5',\n        strokeLinecap: 'round',\n        strokeLinejoin: 'round',\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      }, attrs || {});\n\n      if (semantic.associationDirection === 'One' ||\n          semantic.associationDirection === 'Both') {\n        attrs.markerEnd = marker('association-end', fill, stroke);\n      }\n\n      if (semantic.associationDirection === 'Both') {\n        attrs.markerStart = marker('association-start', fill, stroke);\n      }\n\n      return drawLine(parentGfx, element.waypoints, attrs);\n    },\n    'bpmn:DataInputAssociation': function(parentGfx, element) {\n      var fill = getFillColor(element, defaultFillColor),\n          stroke = getStrokeColor(element, defaultStrokeColor);\n\n      return renderer('bpmn:Association')(parentGfx, element, {\n        markerEnd: marker('association-end', fill, stroke)\n      });\n    },\n    'bpmn:DataOutputAssociation': function(parentGfx, element) {\n      var fill = getFillColor(element, defaultFillColor),\n          stroke = getStrokeColor(element, defaultStrokeColor);\n\n      return renderer('bpmn:Association')(parentGfx, element, {\n        markerEnd: marker('association-end', fill, stroke)\n      });\n    },\n    'bpmn:MessageFlow': function(parentGfx, element) {\n\n      var semantic = getSemantic(element),\n          di = getDi(element);\n\n      var fill = getFillColor(element, defaultFillColor),\n          stroke = getStrokeColor(element, defaultStrokeColor);\n\n      var pathData = createPathFromConnection(element);\n\n      var attrs = {\n        markerEnd: marker('messageflow-end', fill, stroke),\n        markerStart: marker('messageflow-start', fill, stroke),\n        strokeDasharray: '10, 12',\n        strokeLinecap: 'round',\n        strokeLinejoin: 'round',\n        strokeWidth: '1.5px',\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      };\n\n      var path = drawPath(parentGfx, pathData, attrs);\n\n      if (semantic.messageRef) {\n        var midPoint = path.getPointAtLength(path.getTotalLength() / 2);\n\n        var markerPathData = pathMap.getScaledPath('MESSAGE_FLOW_MARKER', {\n          abspos: {\n            x: midPoint.x,\n            y: midPoint.y\n          }\n        });\n\n        var messageAttrs = { strokeWidth: 1 };\n\n        if (di.messageVisibleKind === 'initiating') {\n          messageAttrs.fill = 'white';\n          messageAttrs.stroke = 'black';\n        } else {\n          messageAttrs.fill = '#888';\n          messageAttrs.stroke = 'white';\n        }\n\n        drawPath(parentGfx, markerPathData, messageAttrs);\n      }\n\n      return path;\n    },\n    'bpmn:DataObject': function(parentGfx, element) {\n      var pathData = pathMap.getScaledPath('DATA_OBJECT_PATH', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.474,\n          my: 0.296\n        }\n      });\n\n      var elementObject = drawPath(parentGfx, pathData, {\n        fill: getFillColor(element, defaultFillColor),\n        fillOpacity: DEFAULT_FILL_OPACITY,\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      var semantic = getSemantic(element);\n\n      if (isCollection(semantic)) {\n        renderDataItemCollection(parentGfx, element);\n      }\n\n      return elementObject;\n    },\n    'bpmn:DataObjectReference': as('bpmn:DataObject'),\n    'bpmn:DataInput': function(parentGfx, element) {\n\n      var arrowPathData = pathMap.getRawPath('DATA_ARROW');\n\n      // page\n      var elementObject = renderer('bpmn:DataObject')(parentGfx, element);\n\n      /* input arrow path */ drawPath(parentGfx, arrowPathData, { strokeWidth: 1 });\n\n      return elementObject;\n    },\n    'bpmn:DataOutput': function(parentGfx, element) {\n      var arrowPathData = pathMap.getRawPath('DATA_ARROW');\n\n      // page\n      var elementObject = renderer('bpmn:DataObject')(parentGfx, element);\n\n      /* output arrow path */ drawPath(parentGfx, arrowPathData, {\n        strokeWidth: 1,\n        fill: 'black'\n      });\n\n      return elementObject;\n    },\n    'bpmn:DataStoreReference': function(parentGfx, element) {\n      var DATA_STORE_PATH = pathMap.getScaledPath('DATA_STORE', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0,\n          my: 0.133\n        }\n      });\n\n      var elementStore = drawPath(parentGfx, DATA_STORE_PATH, {\n        strokeWidth: 2,\n        fill: getFillColor(element, defaultFillColor),\n        fillOpacity: DEFAULT_FILL_OPACITY,\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      return elementStore;\n    },\n    'bpmn:BoundaryEvent': function(parentGfx, element) {\n\n      var semantic = getSemantic(element),\n          cancel = semantic.cancelActivity;\n\n      var attrs = {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      };\n\n      if (!cancel) {\n        attrs.strokeDasharray = '6';\n        attrs.strokeLinecap = 'round';\n      }\n\n      // apply fillOpacity\n      var outerAttrs = assign({}, attrs, {\n        fillOpacity: 1\n      });\n\n      // apply no-fill\n      var innerAttrs = assign({}, attrs, {\n        fill: 'none'\n      });\n\n      var outer = renderer('bpmn:Event')(parentGfx, element, outerAttrs);\n\n      /* inner path */ drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, innerAttrs);\n\n      renderEventContent(element, parentGfx);\n\n      return outer;\n    },\n    'bpmn:Group': function(parentGfx, element) {\n      var semantic = getSemantic(element),\n          di = getDi(element);\n\n      var group = drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, {\n        strokeWidth: 1,\n        strokeDasharray: '8,3,1,3',\n        fill: 'none',\n        pointerEvents: 'none'\n      });\n\n      var categoryValueRef = semantic.categoryValueRef || {};\n\n      if (categoryValueRef.value) {\n        var box = di.label ? di.label.bounds : element;\n\n        renderLabel(parentGfx, categoryValueRef.value, {\n          box: box,\n          style: {\n            fill: getStrokeColor(element, defaultStrokeColor)\n          }\n        });\n      }\n\n      return group;\n    },\n    'label': function(parentGfx, element) {\n      return renderExternalLabel(parentGfx, element);\n    },\n    'bpmn:TextAnnotation': function(parentGfx, element) {\n      var style = {\n        'fill': 'none',\n        'stroke': 'none'\n      };\n\n      var textElement = drawRect(parentGfx, element.width, element.height, 0, 0, style);\n\n      var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.0,\n          my: 0.0\n        }\n      });\n\n      drawPath(parentGfx, textPathData, {\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      var text = getSemantic(element).text || '';\n      renderLabel(parentGfx, text, {\n        box: element,\n        align: 'left-top',\n        padding: 5,\n        style: {\n          fill: getStrokeColor(element, defaultStrokeColor)\n        }\n      });\n\n      return textElement;\n    },\n    'ParticipantMultiplicityMarker': function(parentGfx, element) {\n      var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2) / element.width),\n          my: (element.height - 15) / element.height\n        }\n      });\n\n      drawMarker('participant-multiplicity', parentGfx, markerPath, {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n    },\n    'SubProcessMarker': function(parentGfx, element) {\n      var markerRect = drawRect(parentGfx, 14, 14, 0, {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n\n      // Process marker is placed in the middle of the box\n      // therefore fixed values can be used here\n      translate(markerRect, element.width / 2 - 7.5, element.height - 20);\n\n      var markerPath = pathMap.getScaledPath('MARKER_SUB_PROCESS', {\n        xScaleFactor: 1.5,\n        yScaleFactor: 1.5,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: (element.width / 2 - 7.5) / element.width,\n          my: (element.height - 20) / element.height\n        }\n      });\n\n      drawMarker('sub-process', parentGfx, markerPath, {\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n    },\n    'ParallelMarker': function(parentGfx, element, position) {\n      var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2 + position.parallel) / element.width),\n          my: (element.height - 20) / element.height\n        }\n      });\n\n      drawMarker('parallel', parentGfx, markerPath, {\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n    },\n    'SequentialMarker': function(parentGfx, element, position) {\n      var markerPath = pathMap.getScaledPath('MARKER_SEQUENTIAL', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2 + position.seq) / element.width),\n          my: (element.height - 19) / element.height\n        }\n      });\n\n      drawMarker('sequential', parentGfx, markerPath, {\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n    },\n    'CompensationMarker': function(parentGfx, element, position) {\n      var markerMath = pathMap.getScaledPath('MARKER_COMPENSATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2 + position.compensation) / element.width),\n          my: (element.height - 13) / element.height\n        }\n      });\n\n      drawMarker('compensation', parentGfx, markerMath, {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n    },\n    'LoopMarker': function(parentGfx, element, position) {\n      var markerPath = pathMap.getScaledPath('MARKER_LOOP', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2 + position.loop) / element.width),\n          my: (element.height - 7) / element.height\n        }\n      });\n\n      drawMarker('loop', parentGfx, markerPath, {\n        strokeWidth: 1,\n        fill: getFillColor(element, defaultFillColor),\n        stroke: getStrokeColor(element, defaultStrokeColor),\n        strokeLinecap: 'round',\n        strokeMiterlimit: 0.5\n      });\n    },\n    'AdhocMarker': function(parentGfx, element, position) {\n      var markerPath = pathMap.getScaledPath('MARKER_ADHOC', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: ((element.width / 2 + position.adhoc) / element.width),\n          my: (element.height - 15) / element.height\n        }\n      });\n\n      drawMarker('adhoc', parentGfx, markerPath, {\n        strokeWidth: 1,\n        fill: getStrokeColor(element, defaultStrokeColor),\n        stroke: getStrokeColor(element, defaultStrokeColor)\n      });\n    }\n  };\n\n  function attachTaskMarkers(parentGfx, element, taskMarkers) {\n    var obj = getSemantic(element);\n\n    var subprocess = taskMarkers && taskMarkers.indexOf('SubProcessMarker') !== -1;\n    var position;\n\n    if (subprocess) {\n      position = {\n        seq: -21,\n        parallel: -22,\n        compensation: -42,\n        loop: -18,\n        adhoc: 10\n      };\n    } else {\n      position = {\n        seq: -3,\n        parallel: -6,\n        compensation: -27,\n        loop: 0,\n        adhoc: 10\n      };\n    }\n\n    forEach(taskMarkers, function(marker) {\n      renderer(marker)(parentGfx, element, position);\n    });\n\n    if (obj.isForCompensation) {\n      renderer('CompensationMarker')(parentGfx, element, position);\n    }\n\n    if (obj.$type === 'bpmn:AdHocSubProcess') {\n      renderer('AdhocMarker')(parentGfx, element, position);\n    }\n\n    var loopCharacteristics = obj.loopCharacteristics,\n        isSequential = loopCharacteristics && loopCharacteristics.isSequential;\n\n    if (loopCharacteristics) {\n\n      if (isSequential === undefined) {\n        renderer('LoopMarker')(parentGfx, element, position);\n      }\n\n      if (isSequential === false) {\n        renderer('ParallelMarker')(parentGfx, element, position);\n      }\n\n      if (isSequential === true) {\n        renderer('SequentialMarker')(parentGfx, element, position);\n      }\n    }\n  }\n\n  function renderDataItemCollection(parentGfx, element) {\n\n    var yPosition = (element.height - 16) / element.height;\n\n    var pathData = pathMap.getScaledPath('DATA_OBJECT_COLLECTION_PATH', {\n      xScaleFactor: 1,\n      yScaleFactor: 1,\n      containerWidth: element.width,\n      containerHeight: element.height,\n      position: {\n        mx: 0.451,\n        my: yPosition\n      }\n    });\n\n    /* collection path */ drawPath(parentGfx, pathData, {\n      strokeWidth: 2\n    });\n  }\n\n\n  // extension API, use at your own risk\n  this._drawPath = drawPath;\n\n}",
            "name": "BpmnRenderer",
            "parameters": [
                "config",
                "eventBus",
                "styles",
                "pathMap",
                "canvas",
                "textRenderer",
                "priority"
            ],
            "start_line": 64,
            "end_line": 1862,
            "return": true
        },
        "function_83": {
            "signature": "",
            "content": "BpmnRenderer.prototype.canRender = function(element) {\n  return is(element, 'bpmn:BaseElement');\n};",
            "name": "function_83",
            "parameters": [
                "element"
            ],
            "start_line": 1877,
            "end_line": 1879,
            "return": true
        },
        "function_84": {
            "signature": "",
            "content": "BpmnRenderer.prototype.drawShape = function(parentGfx, element) {\n  var type = element.type;\n  var h = this.handlers[type];\n\n  /* jshint -W040 */\n  return h(parentGfx, element);\n};",
            "name": "function_84",
            "parameters": [
                "parentGfx",
                "element"
            ],
            "start_line": 1881,
            "end_line": 1887,
            "return": true
        },
        "function_85": {
            "signature": "",
            "content": "BpmnRenderer.prototype.drawConnection = function(parentGfx, element) {\n  var type = element.type;\n  var h = this.handlers[type];\n\n  /* jshint -W040 */\n  return h(parentGfx, element);\n};",
            "name": "function_85",
            "parameters": [
                "parentGfx",
                "element"
            ],
            "start_line": 1889,
            "end_line": 1895,
            "return": true
        },
        "function_86": {
            "signature": "",
            "content": "BpmnRenderer.prototype.getShapePath = function(element) {\n\n  if (is(element, 'bpmn:Event')) {\n    return getCirclePath(element);\n  }\n\n  if (is(element, 'bpmn:Activity')) {\n    return getRoundRectPath(element, TASK_BORDER_RADIUS);\n  }\n\n  if (is(element, 'bpmn:Gateway')) {\n    return getDiamondPath(element);\n  }\n\n  return getRectPath(element);\n};",
            "name": "function_86",
            "parameters": [
                "element"
            ],
            "start_line": 1897,
            "end_line": 1912,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\draw\\BpmnRenderUtil.js": {
        "function_1": {
            "signature": "/**\n* Checks if eventDefinition of the given element matches with semantic type.\n*\n* @return {boolean} true if element is of the given semantic type\n*/",
            "content": "export function isTypedEvent(event, eventDefinitionType, filter) {\n\n  function matches(definition, filter) {\n    return every(filter, function(val, key) {\n\n      // we want a == conversion here, to be able to catch\n      // undefined == false and friends\n      /* jshint -W116 */\n      return definition[key] == val;\n    });\n  }\n\n  return some(event.eventDefinitions, function(definition) {\n    return definition.$type === eventDefinitionType && matches(event, filter);\n  });\n}",
            "name": "isTypedEvent",
            "parameters": [
                "event",
                "eventDefinitionType",
                "filter"
            ],
            "start_line": 18,
            "end_line": 33,
            "return": true
        },
        "function_5": {
            "signature": "",
            "content": "export function isThrowEvent(event) {\n  return (event.$type === 'bpmn:IntermediateThrowEvent') || (event.$type === 'bpmn:EndEvent');\n}",
            "name": "isThrowEvent",
            "parameters": [
                "event"
            ],
            "start_line": 35,
            "end_line": 37,
            "return": true
        },
        "function_6": {
            "signature": "",
            "content": "export function isCollection(element) {\n  var dataObject = element.dataObjectRef;\n\n  return element.isCollection || (dataObject && dataObject.isCollection);\n}",
            "name": "isCollection",
            "parameters": [
                "element"
            ],
            "start_line": 39,
            "end_line": 43,
            "return": true
        },
        "function_7": {
            "signature": "",
            "content": "export function getDi(element) {\n  return element.businessObject.di;\n}",
            "name": "getDi",
            "parameters": [
                "element"
            ],
            "start_line": 45,
            "end_line": 47,
            "return": true
        },
        "function_8": {
            "signature": "",
            "content": "export function getSemantic(element) {\n  return element.businessObject;\n}",
            "name": "getSemantic",
            "parameters": [
                "element"
            ],
            "start_line": 49,
            "end_line": 51,
            "return": true
        },
        "function_9": {
            "signature": "// color access //////////////////////",
            "content": "export function getFillColor(element, defaultColor) {\n  return getDi(element).get('bioc:fill') || defaultColor || 'white';\n}",
            "name": "getFillColor",
            "parameters": [
                "element",
                "defaultColor"
            ],
            "start_line": 56,
            "end_line": 58,
            "return": true
        },
        "function_10": {
            "signature": "",
            "content": "export function getStrokeColor(element, defaultColor) {\n  return getDi(element).get('bioc:stroke') || defaultColor || 'black';\n}",
            "name": "getStrokeColor",
            "parameters": [
                "element",
                "defaultColor"
            ],
            "start_line": 60,
            "end_line": 62,
            "return": true
        },
        "function_11": {
            "signature": "// cropping path customizations //////////////////////",
            "content": "export function getCirclePath(shape) {\n\n  var cx = shape.x + shape.width / 2,\n      cy = shape.y + shape.height / 2,\n      radius = shape.width / 2;\n\n  var circlePath = [\n    ['M', cx, cy],\n    ['m', 0, -radius],\n    ['a', radius, radius, 0, 1, 1, 0, 2 * radius],\n    ['a', radius, radius, 0, 1, 1, 0, -2 * radius],\n    ['z']\n  ];\n\n  return componentsToPath(circlePath);\n}",
            "name": "getCirclePath",
            "parameters": [
                "shape"
            ],
            "start_line": 67,
            "end_line": 82,
            "return": true
        },
        "function_12": {
            "signature": "",
            "content": "export function getRoundRectPath(shape, borderRadius) {\n\n  var x = shape.x,\n      y = shape.y,\n      width = shape.width,\n      height = shape.height;\n\n  var roundRectPath = [\n    ['M', x + borderRadius, y],\n    ['l', width - borderRadius * 2, 0],\n    ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius],\n    ['l', 0, height - borderRadius * 2],\n    ['a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, borderRadius],\n    ['l', borderRadius * 2 - width, 0],\n    ['a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, -borderRadius],\n    ['l', 0, borderRadius * 2 - height],\n    ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, -borderRadius],\n    ['z']\n  ];\n\n  return componentsToPath(roundRectPath);\n}",
            "name": "getRoundRectPath",
            "parameters": [
                "shape",
                "borderRadius"
            ],
            "start_line": 84,
            "end_line": 105,
            "return": true
        },
        "function_13": {
            "signature": "",
            "content": "export function getDiamondPath(shape) {\n\n  var width = shape.width,\n      height = shape.height,\n      x = shape.x,\n      y = shape.y,\n      halfWidth = width / 2,\n      halfHeight = height / 2;\n\n  var diamondPath = [\n    ['M', x + halfWidth, y],\n    ['l', halfWidth, halfHeight],\n    ['l', -halfWidth, halfHeight],\n    ['l', -halfWidth, -halfHeight],\n    ['z']\n  ];\n\n  return componentsToPath(diamondPath);\n}",
            "name": "getDiamondPath",
            "parameters": [
                "shape"
            ],
            "start_line": 107,
            "end_line": 125,
            "return": true
        },
        "function_14": {
            "signature": "",
            "content": "export function getRectPath(shape) {\n  var x = shape.x,\n      y = shape.y,\n      width = shape.width,\n      height = shape.height;\n\n  var rectPath = [\n    ['M', x, y],\n    ['l', width, 0],\n    ['l', 0, height],\n    ['l', -width, 0],\n    ['z']\n  ];\n\n  return componentsToPath(rectPath);\n}",
            "name": "getRectPath",
            "parameters": [
                "shape"
            ],
            "start_line": 127,
            "end_line": 142,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\draw\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\draw\\PathMap.js": {
        "function_1": {
            "signature": "/**\n* Map containing SVG paths needed by BpmnRenderer.\n*/",
            "content": "export default function PathMap() {\n\n  /**\n   * Contains a map of path elements\n   *\n   * <h1>Path definition</h1>\n   * A parameterized path is defined like this:\n   * <pre>\n   * 'GATEWAY_PARALLEL': {\n   *   d: 'm {mx},{my} {e.x0},0 0,{e.x1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +\n          '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',\n   *   height: 17.5,\n   *   width:  17.5,\n   *   heightElements: [2.5, 7.5],\n   *   widthElements: [2.5, 7.5]\n   * }\n   * </pre>\n   * <p>It's important to specify a correct <b>height and width</b> for the path as the scaling\n   * is based on the ratio between the specified height and width in this object and the\n   * height and width that is set as scale target (Note x,y coordinates will be scaled with\n   * individual ratios).</p>\n   * <p>The '<b>heightElements</b>' and '<b>widthElements</b>' array must contain the values that will be scaled.\n   * The scaling is based on the computed ratios.\n   * Coordinates on the y axis should be in the <b>heightElement</b>'s array, they will be scaled using\n   * the computed ratio coefficient.\n   * In the parameterized path the scaled values can be accessed through the 'e' object in {} brackets.\n   *   <ul>\n   *    <li>The values for the y axis can be accessed in the path string using {e.y0}, {e.y1}, ....</li>\n   *    <li>The values for the x axis can be accessed in the path string using {e.x0}, {e.x1}, ....</li>\n   *   </ul>\n   *   The numbers x0, x1 respectively y0, y1, ... map to the corresponding array index.\n   * </p>\n   */\n  this.pathMap = {\n    'EVENT_MESSAGE': {\n      d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',\n      height: 36,\n      width:  36,\n      heightElements: [6, 14],\n      widthElements: [10.5, 21]\n    },\n    'EVENT_SIGNAL': {\n      d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z',\n      height: 36,\n      width: 36,\n      heightElements: [18],\n      widthElements: [10, 20]\n    },\n    'EVENT_ESCALATION': {\n      d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x0},-{e.y1} l -{e.x0},{e.y1} Z',\n      height: 36,\n      width: 36,\n      heightElements: [20, 7],\n      widthElements: [8]\n    },\n    'EVENT_CONDITIONAL': {\n      d: 'M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z ' +\n         'M {e.x2},{e.y3} l {e.x0},0 ' +\n         'M {e.x2},{e.y4} l {e.x0},0 ' +\n         'M {e.x2},{e.y5} l {e.x0},0 ' +\n         'M {e.x2},{e.y6} l {e.x0},0 ' +\n         'M {e.x2},{e.y7} l {e.x0},0 ' +\n         'M {e.x2},{e.y8} l {e.x0},0 ',\n      height: 36,\n      width:  36,\n      heightElements: [8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5],\n      widthElements:  [10.5, 14.5, 12.5]\n    },\n    'EVENT_LINK': {\n      d: 'm {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z',\n      height: 36,\n      width: 36,\n      heightElements: [4.4375, 6.75, 7.8125],\n      widthElements: [9.84375, 13.5]\n    },\n    'EVENT_ERROR': {\n      d: 'm {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z',\n      height: 36,\n      width: 36,\n      heightElements: [0.023, 8.737, 8.151, 16.564, 10.591, 8.714],\n      widthElements: [0.085, 6.672, 6.97, 4.273, 5.337, 6.636]\n    },\n    'EVENT_CANCEL_45': {\n      d: 'm {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 ' +\n        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',\n      height: 36,\n      width: 36,\n      heightElements: [4.75, 8.5],\n      widthElements: [4.75, 8.5]\n    },\n    'EVENT_COMPENSATION': {\n      d: 'm {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x1},-{e.y2} {e.x2},-{e.y3} 0,{e.y1} -{e.x2},-{e.y3} z',\n      height: 36,\n      width: 36,\n      heightElements: [6.5, 13, 0.4, 6.1],\n      widthElements: [9, 9.3, 8.7]\n    },\n    'EVENT_TIMER_WH': {\n      d: 'M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ',\n      height: 36,\n      width:  36,\n      heightElements: [10, 2],\n      widthElements: [3, 7]\n    },\n    'EVENT_TIMER_LINE': {\n      d:  'M {mx},{my} ' +\n          'm {e.x0},{e.y0} l -{e.x1},{e.y1} ',\n      height: 36,\n      width:  36,\n      heightElements: [10, 3],\n      widthElements: [0, 0]\n    },\n    'EVENT_MULTIPLE': {\n      d:'m {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z',\n      height: 36,\n      width:  36,\n      heightElements: [6.28099, 12.56199],\n      widthElements: [3.1405, 9.42149, 12.56198]\n    },\n    'EVENT_PARALLEL_MULTIPLE': {\n      d:'m {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +\n        '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',\n      height: 36,\n      width:  36,\n      heightElements: [2.56228, 7.68683],\n      widthElements: [2.56228, 7.68683]\n    },\n    'GATEWAY_EXCLUSIVE': {\n      d:'m {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} ' +\n                    '{e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} ' +\n                    '{e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z',\n      height: 17.5,\n      width:  17.5,\n      heightElements: [8.5, 6.5312, -6.5312, -8.5],\n      widthElements:  [6.5, -6.5, 3, -3, 5, -5]\n    },\n    'GATEWAY_PARALLEL': {\n      d:'m {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 ' +\n        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',\n      height: 30,\n      width:  30,\n      heightElements: [5, 12.5],\n      widthElements: [5, 12.5]\n    },\n    'GATEWAY_EVENT_BASED': {\n      d:'m {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z',\n      height: 11,\n      width:  11,\n      heightElements: [-6, 6, 12, -12],\n      widthElements: [9, -3, -12]\n    },\n    'GATEWAY_COMPLEX': {\n      d:'m {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} ' +\n        '{e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} ' +\n        '{e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} ' +\n        '-{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z',\n      height: 17.125,\n      width:  17.125,\n      heightElements: [4.875, 3.4375, 2.125, 3],\n      widthElements: [3.4375, 2.125, 4.875, 3]\n    },\n    'DATA_OBJECT_PATH': {\n      d:'m 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0',\n      height: 61,\n      width:  51,\n      heightElements: [10, 50, 60],\n      widthElements: [10, 40, 50, 60]\n    },\n    'DATA_OBJECT_COLLECTION_PATH': {\n      d:'m {mx}, {my} ' +\n        'm  0 15  l 0 -15 ' +\n        'm  4 15  l 0 -15 ' +\n        'm  4 15  l 0 -15 ',\n      height: 61,\n      width:  51,\n      heightElements: [12],\n      widthElements: [1, 6, 12, 15]\n    },\n    'DATA_ARROW': {\n      d:'m 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z',\n      height: 61,\n      width:  51,\n      heightElements: [],\n      widthElements: []\n    },\n    'DATA_STORE': {\n      d:'m  {mx},{my} ' +\n        'l  0,{e.y2} ' +\n        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +\n        'l  0,-{e.y2} ' +\n        'c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0' +\n        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +\n        'm  -{e.x2},{e.y0}' +\n        'c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0' +\n        'm  -{e.x2},{e.y0}' +\n        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0',\n      height: 61,\n      width:  61,\n      heightElements: [7, 10, 45],\n      widthElements:  [2, 58, 60]\n    },\n    'TEXT_ANNOTATION': {\n      d: 'm {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0',\n      height: 30,\n      width: 10,\n      heightElements: [30],\n      widthElements: [10]\n    },\n    'MARKER_SUB_PROCESS': {\n      d: 'm{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0',\n      height: 10,\n      width: 10,\n      heightElements: [],\n      widthElements: []\n    },\n    'MARKER_PARALLEL': {\n      d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',\n      height: 10,\n      width: 10,\n      heightElements: [],\n      widthElements: []\n    },\n    'MARKER_SEQUENTIAL': {\n      d: 'm{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0',\n      height: 10,\n      width: 10,\n      heightElements: [],\n      widthElements: []\n    },\n    'MARKER_COMPENSATION': {\n      d: 'm {mx},{my} 7,-5 0,10 z m 7.1,-0.3 6.9,-4.7 0,10 -6.9,-4.7 z',\n      height: 10,\n      width: 21,\n      heightElements: [],\n      widthElements: []\n    },\n    'MARKER_LOOP': {\n      d: 'm {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 ' +\n        '-6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 ' +\n        '0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 ' +\n        'l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902',\n      height: 13.9,\n      width: 13.7,\n      heightElements: [],\n      widthElements: []\n    },\n    'MARKER_ADHOC': {\n      d: 'm {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 ' +\n        '3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 ' +\n        '1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 ' +\n        '-3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 ' +\n        '-2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z',\n      height: 4,\n      width: 15,\n      heightElements: [],\n      widthElements: []\n    },\n    'TASK_TYPE_SEND': {\n      d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',\n      height: 14,\n      width:  21,\n      heightElements: [6, 14],\n      widthElements: [10.5, 21]\n    },\n    'TASK_TYPE_SCRIPT': {\n      d: 'm {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 ' +\n        'c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z ' +\n        'm -7,-12 l 5,0 ' +\n        'm -4.5,3 l 4.5,0 ' +\n        'm -3,3 l 5,0' +\n        'm -4,3 l 5,0',\n      height: 15,\n      width:  12.6,\n      heightElements: [6, 14],\n      widthElements: [10.5, 21]\n    },\n    'TASK_TYPE_USER_1': {\n      d: 'm {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 ' +\n        '-4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 ' +\n        '0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 ' +\n        'h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 z' +\n        'm -8,6 l 0,5.5 m 11,0 l 0,-5'\n    },\n    'TASK_TYPE_USER_2': {\n      d: 'm {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 ' +\n        '-2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 '\n    },\n    'TASK_TYPE_USER_3': {\n      d: 'm {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 ' +\n        '4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 ' +\n        '-4.20799998,3.36699999 -4.20699998,4.34799999 z'\n    },\n    'TASK_TYPE_MANUAL': {\n      d: 'm {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 ' +\n        '-0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 ' +\n        '0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 ' +\n        '-1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 ' +\n        '0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 ' +\n        '-10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 ' +\n        '2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 ' +\n        '-0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 ' +\n        '-1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 ' +\n        '-0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 ' +\n        '0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 ' +\n        '-5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z'\n    },\n    'TASK_TYPE_INSTANTIATING_SEND': {\n      d: 'm {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6'\n    },\n    'TASK_TYPE_SERVICE': {\n      d: 'm {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 ' +\n        '0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 ' +\n        '-1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 ' +\n        'v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 ' +\n        '-0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 ' +\n        '-1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 ' +\n        'h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 ' +\n        '-0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 ' +\n        'c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 ' +\n        'l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 ' +\n        '0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 ' +\n        'c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z ' +\n        'm 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +\n        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +\n        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'\n    },\n    'TASK_TYPE_SERVICE_FILL': {\n      d: 'm {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +\n        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +\n        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'\n    },\n    'TASK_TYPE_BUSINESS_RULE_HEADER': {\n      d: 'm {mx},{my} 0,4 20,0 0,-4 z'\n    },\n    'TASK_TYPE_BUSINESS_RULE_MAIN': {\n      d: 'm {mx},{my} 0,12 20,0 0,-12 z' +\n        'm 0,8 l 20,0 ' +\n        'm -13,-4 l 0,8'\n    },\n    'MESSAGE_FLOW_MARKER': {\n      d: 'm {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6'\n    }\n  };\n\n  this.getRawPath = function getRawPath(pathId) {\n    return this.pathMap[pathId].d;\n  };\n\n  /**\n   * Scales the path to the given height and width.\n   * <h1>Use case</h1>\n   * <p>Use case is to scale the content of elements (event, gateways) based\n   * on the element bounding box's size.\n   * </p>\n   * <h1>Why not transform</h1>\n   * <p>Scaling a path with transform() will also scale the stroke and IE does not support\n   * the option 'non-scaling-stroke' to prevent this.\n   * Also there are use cases where only some parts of a path should be\n   * scaled.</p>\n   *\n   * @param {String} pathId The ID of the path.\n   * @param {Object} param <p>\n   *   Example param object scales the path to 60% size of the container (data.width, data.height).\n   *   <pre>\n   *   {\n   *     xScaleFactor: 0.6,\n   *     yScaleFactor:0.6,\n   *     containerWidth: data.width,\n   *     containerHeight: data.height,\n   *     position: {\n   *       mx: 0.46,\n   *       my: 0.2,\n   *     }\n   *   }\n   *   </pre>\n   *   <ul>\n   *    <li>targetpathwidth = xScaleFactor * containerWidth</li>\n   *    <li>targetpathheight = yScaleFactor * containerHeight</li>\n   *    <li>Position is used to set the starting coordinate of the path. M is computed:\n    *    <ul>\n    *      <li>position.x * containerWidth</li>\n    *      <li>position.y * containerHeight</li>\n    *    </ul>\n    *    Center of the container <pre> position: {\n   *       mx: 0.5,\n   *       my: 0.5,\n   *     }</pre>\n   *     Upper left corner of the container\n   *     <pre> position: {\n   *       mx: 0.0,\n   *       my: 0.0,\n   *     }</pre>\n   *    </li>\n   *   </ul>\n   * </p>\n   *\n   */\n  this.getScaledPath = function getScaledPath(pathId, param) {\n    var rawPath = this.pathMap[pathId];\n\n    // positioning\n    // compute the start point of the path\n    var mx, my;\n\n    if (param.abspos) {\n      mx = param.abspos.x;\n      my = param.abspos.y;\n    } else {\n      mx = param.containerWidth * param.position.mx;\n      my = param.containerHeight * param.position.my;\n    }\n\n    var coordinates = {}; // map for the scaled coordinates\n    if (param.position) {\n\n      // path\n      var heightRatio = (param.containerHeight / rawPath.height) * param.yScaleFactor;\n      var widthRatio = (param.containerWidth / rawPath.width) * param.xScaleFactor;\n\n\n      // Apply height ratio\n      for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {\n        coordinates['y' + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;\n      }\n\n      // Apply width ratio\n      for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {\n        coordinates['x' + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;\n      }\n    }\n\n    // Apply value to raw path\n    var path = format(\n      rawPath.d, {\n        mx: mx,\n        my: my,\n        e: coordinates\n      }\n    );\n    return path;\n  };\n}",
            "name": "PathMap",
            "parameters": [],
            "start_line": 5,
            "end_line": 446,
            "return": true
        },
        "function_4": {
            "signature": "",
            "content": "function replacer(all, key, obj) {\n  var res = obj;\n  key.replace(objNotationRegex, function(all, name, quote, quotedName, isFunc) {\n    name = name || quotedName;\n    if (res) {\n      if (name in res) {\n        res = res[name];\n      }\n      typeof res == 'function' && isFunc && (res = res());\n    }\n  });\n  res = (res == null || res == obj ? all : res) + '';\n\n  return res;\n}",
            "name": "replacer",
            "parameters": [
                "all",
                "key",
                "obj"
            ],
            "start_line": 454,
            "end_line": 468,
            "return": true
        },
        "function_6": {
            "signature": "",
            "content": "function format(str, obj) {\n  return String(str).replace(tokenRegex, function(all, key) {\n    return replacer(all, key, obj);\n  });\n}",
            "name": "format",
            "parameters": [
                "str",
                "obj"
            ],
            "start_line": 470,
            "end_line": 474,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\draw\\TextRenderer.js": {
        "function_1": {
            "signature": "",
            "content": "export default function TextRenderer(config) {\n\n  var defaultStyle = assign({\n    fontFamily: 'Arial, sans-serif',\n    fontSize: DEFAULT_FONT_SIZE,\n    fontWeight: 'normal',\n    lineHeight: LINE_HEIGHT_RATIO\n  }, config && config.defaultStyle || {});\n\n  var fontSize = parseInt(defaultStyle.fontSize, 10) - 1;\n\n  var externalStyle = assign({}, defaultStyle, {\n    fontSize: fontSize\n  }, config && config.externalStyle || {});\n\n  var textUtil = new TextUtil({\n    style: defaultStyle\n  });\n\n  /**\n   * Get the new bounds of an externally rendered,\n   * layouted label.\n   *\n   * @param  {Bounds} bounds\n   * @param  {String} text\n   *\n   * @return {Bounds}\n   */\n  this.getExternalLabelBounds = function(bounds, text) {\n\n    var layoutedDimensions = textUtil.getDimensions(text, {\n      box: {\n        width: 90,\n        height: 30,\n        x: bounds.width / 2 + bounds.x,\n        y: bounds.height / 2 + bounds.y\n      },\n      style: externalStyle\n    });\n\n    // resize label shape to fit label text\n    return {\n      x: Math.round(bounds.x + bounds.width / 2 - layoutedDimensions.width / 2),\n      y: Math.round(bounds.y),\n      width: Math.ceil(layoutedDimensions.width),\n      height: Math.ceil(layoutedDimensions.height)\n    };\n\n  };\n\n  /**\n   * Get the new bounds of text annotation.\n   *\n   * @param  {Bounds} bounds\n   * @param  {String} text\n   *\n   * @return {Bounds}\n   */\n  this.getTextAnnotationBounds = function(bounds, text) {\n\n    var layoutedDimensions = textUtil.getDimensions(text, {\n      box: bounds,\n      style: defaultStyle,\n      align: 'left-top',\n      padding: 5\n    });\n\n    return {\n      x: bounds.x,\n      y: bounds.y,\n      width: bounds.width,\n      height: Math.max(MIN_TEXT_ANNOTATION_HEIGHT, Math.round(layoutedDimensions.height))\n    };\n  };\n\n  /**\n   * Create a layouted text element.\n   *\n   * @param {String} text\n   * @param {Object} [options]\n   *\n   * @return {SVGElement} rendered text\n   */\n  this.createText = function(text, options) {\n    return textUtil.createText(text, options || {});\n  };\n\n  /**\n   * Get default text style.\n   */\n  this.getDefaultStyle = function() {\n    return defaultStyle;\n  };\n\n  /**\n   * Get the external text style.\n   */\n  this.getExternalStyle = function() {\n    return externalStyle;\n  };\n\n}",
            "name": "TextRenderer",
            "parameters": [
                "config"
            ],
            "start_line": 11,
            "end_line": 112,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\auto-place\\AutoPlace.js": {
        "function_1": {
            "signature": "/**\n* A service that places elements connected to existing ones\n* to an appropriate position in an _automated_ fashion.\n*\n* @param {EventBus} eventBus\n* @param {Modeling} modeling\n*/",
            "content": "export default function AutoPlace(eventBus, modeling) {\n\n  function emit(event, payload) {\n    return eventBus.fire(event, payload);\n  }\n\n\n  /**\n   * Append shape to source at appropriate position.\n   *\n   * @param {djs.model.Shape} source\n   * @param {djs.model.Shape} shape\n   *\n   * @return {djs.model.Shape} appended shape\n   */\n  this.append = function(source, shape) {\n\n    // allow others to provide the position\n    var position = emit('autoPlace', {\n      source: source,\n      shape: shape\n    });\n\n    if (!position) {\n      position = getNewShapePosition(source, shape);\n    }\n\n    var newShape = modeling.appendShape(source, shape, position, source.parent);\n\n    // notify interested parties on new shape placed\n    emit('autoPlace.end', {\n      shape: newShape\n    });\n\n    return newShape;\n  };\n\n}",
            "name": "AutoPlace",
            "parameters": [
                "eventBus",
                "modeling"
            ],
            "start_line": 11,
            "end_line": 48,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\auto-place\\AutoPlaceSelectionBehavior.js": {
        "function_1": {
            "signature": "/**\n* Select element after auto placement.\n*\n* @param {EventBus} eventBus\n* @param {Selection} selection\n*/",
            "content": "export default function AutoPlaceSelectionBehavior(eventBus, selection) {\n\n  eventBus.on('autoPlace.end', 500, function(e) {\n    selection.select(e.shape);\n  });\n\n}",
            "name": "AutoPlaceSelectionBehavior",
            "parameters": [
                "eventBus",
                "selection"
            ],
            "start_line": 7,
            "end_line": 13,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\auto-place\\AutoPlaceUtil.js": {
        "function_1": {
            "signature": "/**\n* Find the new position for the target element to\n* connect to source.\n*\n* @param  {djs.model.Shape} source\n* @param  {djs.model.Shape} element\n*\n* @return {Point}\n*/",
            "content": "export function getNewShapePosition(source, element) {\n\n  if (is(element, 'bpmn:TextAnnotation')) {\n    return getTextAnnotationPosition(source, element);\n  }\n\n  if (isAny(element, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ])) {\n    return getDataElementPosition(source, element);\n  }\n\n  if (is(element, 'bpmn:FlowNode')) {\n    return getFlowNodePosition(source, element);\n  }\n\n  return getDefaultPosition(source, element);\n}",
            "name": "getNewShapePosition",
            "parameters": [
                "source",
                "element"
            ],
            "start_line": 31,
            "end_line": 46,
            "return": true
        },
        "function_2": {
            "signature": "/**\n* Always try to place element right of source;\n* compute actual distance from previous nodes in flow.\n*/",
            "content": "export function getFlowNodePosition(source, element) {\n\n  var sourceTrbl = asTRBL(source);\n  var sourceMid = getMid(source);\n\n  var horizontalDistance = getFlowNodeDistance(source, element);\n\n  var orientation = 'left',\n      rowSize = 80,\n      margin = 30;\n\n  if (is(source, 'bpmn:BoundaryEvent')) {\n    orientation = getOrientation(source, source.host, -25);\n\n    if (orientation.indexOf('top') !== -1) {\n      margin *= -1;\n    }\n  }\n\n  function getVerticalDistance(orient) {\n    if (orient.indexOf('top') != -1) {\n      return -1 * rowSize;\n    } else if (orient.indexOf('bottom') != -1) {\n      return rowSize;\n    } else {\n      return 0;\n    }\n  }\n\n  var position = {\n    x: sourceTrbl.right + horizontalDistance + element.width / 2,\n    y: sourceMid.y + getVerticalDistance(orientation)\n  };\n\n  var escapeDirection = {\n    y: {\n      margin: margin,\n      rowSize: rowSize\n    }\n  };\n\n  return deconflictPosition(source, element, position, escapeDirection);\n}",
            "name": "getFlowNodePosition",
            "parameters": [
                "source",
                "element"
            ],
            "start_line": 52,
            "end_line": 94,
            "return": true
        },
        "function_4": {
            "signature": "/**\n* Compute best distance between source and target,\n* based on existing connections to and from source.\n*\n* @param {djs.model.Shape} source\n* @param {djs.model.Shape} element\n*\n* @return {Number} distance\n*/",
            "content": "export function getFlowNodeDistance(source, element) {\n\n  var sourceTrbl = asTRBL(source);\n\n  // is connection a reference to consider?\n  function isReference(c) {\n    return is(c, 'bpmn:SequenceFlow');\n  }\n\n  function toTargetNode(weight) {\n\n    return function(shape) {\n      return {\n        shape: shape,\n        weight: weight,\n        distanceTo: function(shape) {\n          var shapeTrbl = asTRBL(shape);\n\n          return shapeTrbl.left - sourceTrbl.right;\n        }\n      };\n    };\n  }\n\n  function toSourceNode(weight) {\n    return function(shape) {\n      return {\n        shape: shape,\n        weight: weight,\n        distanceTo: function(shape) {\n          var shapeTrbl = asTRBL(shape);\n\n          return sourceTrbl.left - shapeTrbl.right;\n        }\n      };\n    };\n  }\n\n  // we create a list of nodes to take into consideration\n  // for calculating the optimal flow node distance\n  //\n  //   * weight existing target nodes higher than source nodes\n  //   * only take into account individual nodes once\n  //\n  var nodes = reduce([].concat(\n    getTargets(source, isReference).map(toTargetNode(5)),\n    getSources(source, isReference).map(toSourceNode(1))\n  ), function(nodes, node) {\n    // filter out shapes connected twice via source or target\n    nodes[node.shape.id + '__weight_' + node.weight] = node;\n\n    return nodes;\n  }, {});\n\n  // compute distances between source and incoming nodes;\n  // group at the same time by distance and expose the\n  // favourite distance as { fav: { count, value } }.\n  var distancesGrouped = reduce(nodes, function(result, node) {\n\n    var shape = node.shape,\n        weight = node.weight,\n        distanceTo = node.distanceTo;\n\n    var fav = result.fav,\n        currentDistance,\n        currentDistanceCount,\n        currentDistanceEntry;\n\n    currentDistance = distanceTo(shape);\n\n    // ignore too far away peers\n    // or non-left to right modeled nodes\n    if (currentDistance < 0 || currentDistance > MAX_HORIZONTAL_DISTANCE) {\n      return result;\n    }\n\n    currentDistanceEntry = result[String(currentDistance)] =\n      result[String(currentDistance)] || {\n        value: currentDistance,\n        count: 0\n      };\n\n    // inc diff count\n    currentDistanceCount = currentDistanceEntry.count += 1 * weight;\n\n    if (!fav || fav.count < currentDistanceCount) {\n      result.fav = currentDistanceEntry;\n    }\n\n    return result;\n  }, { });\n\n\n  if (distancesGrouped.fav) {\n    return distancesGrouped.fav.value;\n  } else {\n    return DEFAULT_HORIZONTAL_DISTANCE;\n  }\n}",
            "name": "getFlowNodeDistance",
            "parameters": [
                "source",
                "element"
            ],
            "start_line": 106,
            "end_line": 204,
            "return": true
        },
        "function_14": {
            "signature": "/**\n* Always try to place text annotations top right of source.\n*/",
            "content": "export function getTextAnnotationPosition(source, element) {\n\n  var sourceTrbl = asTRBL(source);\n\n  var position = {\n    x: sourceTrbl.right + element.width / 2,\n    y: sourceTrbl.top - 50 - element.height / 2\n  };\n\n  var escapeDirection = {\n    y: {\n      margin: -30,\n      rowSize: 20\n    }\n  };\n\n  return deconflictPosition(source, element, position, escapeDirection);\n}",
            "name": "getTextAnnotationPosition",
            "parameters": [
                "source",
                "element"
            ],
            "start_line": 210,
            "end_line": 227,
            "return": true
        },
        "function_15": {
            "signature": "/**\n* Always put element bottom right of source.\n*/",
            "content": "export function getDataElementPosition(source, element) {\n\n  var sourceTrbl = asTRBL(source);\n\n  var position = {\n    x: sourceTrbl.right - 10 + element.width / 2,\n    y: sourceTrbl.bottom + 40 + element.width / 2\n  };\n\n  var escapeDirection = {\n    x: {\n      margin: 30,\n      rowSize: 30\n    }\n  };\n\n  return deconflictPosition(source, element, position, escapeDirection);\n}",
            "name": "getDataElementPosition",
            "parameters": [
                "source",
                "element"
            ],
            "start_line": 233,
            "end_line": 250,
            "return": true
        },
        "function_16": {
            "signature": "/**\n* Always put element right of source per default.\n*/",
            "content": "export function getDefaultPosition(source, element) {\n\n  var sourceTrbl = asTRBL(source);\n\n  var sourceMid = getMid(source);\n\n  // simply put element right next to source\n  return {\n    x: sourceTrbl.right + DEFAULT_HORIZONTAL_DISTANCE + element.width / 2,\n    y: sourceMid.y\n  };\n}",
            "name": "getDefaultPosition",
            "parameters": [
                "source",
                "element"
            ],
            "start_line": 256,
            "end_line": 267,
            "return": true
        },
        "function_17": {
            "signature": "/**\n* Returns all connected elements around the given source.\n*\n* This includes:\n*\n*   - connected elements\n*   - host connected elements\n*   - attachers connected elements\n*\n* @param  {djs.model.Shape} source\n* @param  {djs.model.Shape} element\n*\n* @return {Array<djs.model.Shape>}\n*/",
            "content": "function getAutoPlaceClosure(source, element) {\n\n  var allConnected = getConnected(source);\n\n  if (source.host) {\n    allConnected = allConnected.concat(getConnected(source.host));\n  }\n\n  if (source.attachers) {\n    allConnected = allConnected.concat(source.attachers.reduce(function(shapes, attacher) {\n      return shapes.concat(getConnected(attacher));\n    }, []));\n  }\n\n  return allConnected;\n}",
            "name": "getAutoPlaceClosure",
            "parameters": [
                "source",
                "element"
            ],
            "start_line": 284,
            "end_line": 299,
            "return": true
        },
        "function_19": {
            "signature": "/**\n* Return target at given position, if defined.\n*\n* This takes connected elements from host and attachers\n* into account, too.\n*/",
            "content": "export function getConnectedAtPosition(source, position, element) {\n\n  var bounds = {\n    x: position.x - (element.width / 2),\n    y: position.y - (element.height / 2),\n    width: element.width,\n    height: element.height\n  };\n\n  var closure = getAutoPlaceClosure(source, element);\n\n  return find(closure, function(target) {\n\n    if (target === element) {\n      return false;\n    }\n\n    var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);\n\n    return orientation === 'intersect';\n  });\n}",
            "name": "getConnectedAtPosition",
            "parameters": [
                "source",
                "position",
                "element"
            ],
            "start_line": 307,
            "end_line": 328,
            "return": true
        },
        "function_21": {
            "signature": "/**\n* Returns a new, position for the given element\n* based on the given element that is not occupied\n* by some element connected to source.\n*\n* Take into account the escapeDirection (where to move\n* on positining clashes) in the computation.\n*\n* @param {djs.model.Shape} source\n* @param {djs.model.Shape} element\n* @param {Point} position\n* @param {Object} escapeDelta\n*\n* @return {Point}\n*/",
            "content": "export function deconflictPosition(source, element, position, escapeDelta) {\n\n  function nextPosition(existingElement) {\n\n    var newPosition = {\n      x: position.x,\n      y: position.y\n    };\n\n    [ 'x', 'y' ].forEach(function(axis) {\n\n      var axisDelta = escapeDelta[axis];\n\n      if (!axisDelta) {\n        return;\n      }\n\n      var dimension = axis === 'x' ? 'width' : 'height';\n\n      var margin = axisDelta.margin,\n          rowSize = axisDelta.rowSize;\n\n      if (margin < 0) {\n        newPosition[axis] = Math.min(\n          existingElement[axis] + margin - element[dimension] / 2,\n          position[axis] - rowSize + margin\n        );\n      } else {\n        newPosition[axis] = Math.max(\n          existingTarget[axis] + existingTarget[dimension] + margin + element[dimension] / 2,\n          position[axis] + rowSize + margin\n        );\n      }\n    });\n\n    return newPosition;\n  }\n\n  var existingTarget;\n\n  // deconflict position until free slot is found\n  while ((existingTarget = getConnectedAtPosition(source, position, element))) {\n    position = nextPosition(existingTarget);\n  }\n\n  return position;\n}",
            "name": "deconflictPosition",
            "parameters": [
                "source",
                "element",
                "position",
                "escapeDelta"
            ],
            "start_line": 346,
            "end_line": 392,
            "return": true
        },
        "function_24": {
            "signature": "// helpers //////////////////////",
            "content": "function noneFilter() {\n  return true;\n}",
            "name": "noneFilter",
            "parameters": [],
            "start_line": 398,
            "end_line": 400,
            "return": true
        },
        "function_25": {
            "signature": "",
            "content": "function getConnected(element, connectionFilter) {\n  return [].concat(\n    getTargets(element, connectionFilter),\n    getSources(element, connectionFilter)\n  );\n}",
            "name": "getConnected",
            "parameters": [
                "element",
                "connectionFilter"
            ],
            "start_line": 402,
            "end_line": 407,
            "return": true
        },
        "function_26": {
            "signature": "",
            "content": "function getSources(shape, connectionFilter) {\n\n  if (!connectionFilter) {\n    connectionFilter = noneFilter;\n  }\n\n  return shape.incoming.filter(connectionFilter).map(function(c) {\n    return c.source;\n  });\n}",
            "name": "getSources",
            "parameters": [
                "shape",
                "connectionFilter"
            ],
            "start_line": 409,
            "end_line": 418,
            "return": true
        },
        "function_28": {
            "signature": "",
            "content": "function getTargets(shape, connectionFilter) {\n\n  if (!connectionFilter) {\n    connectionFilter = noneFilter;\n  }\n\n  return shape.outgoing.filter(connectionFilter).map(function(c) {\n    return c.target;\n  });\n}",
            "name": "getTargets",
            "parameters": [
                "shape",
                "connectionFilter"
            ],
            "start_line": 420,
            "end_line": 429,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\auto-place\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\auto-resize\\BpmnAutoResize.js": {
        "function_1": {
            "signature": "/**\n* Sub class of the AutoResize module which implements a BPMN\n* specific resize function.\n*/",
            "content": "export default function BpmnAutoResize(injector) {\n\n  injector.invoke(AutoResize, this);\n}",
            "name": "BpmnAutoResize",
            "parameters": [
                "injector"
            ],
            "start_line": 12,
            "end_line": 15,
            "return": false
        },
        "function_2": {
            "signature": "/**\n* Resize shapes and lanes\n*\n* @param  {djs.model.Shape} target\n* @param  {Object} newBounds\n*/",
            "content": "BpmnAutoResize.prototype.resize = function(target, newBounds, hints) {\n\n  if (is(target, 'bpmn:Participant')) {\n    this._modeling.resizeLane(target, newBounds, null, hints);\n  } else {\n    this._modeling.resizeShape(target, newBounds, null, hints);\n  }\n};",
            "name": "function_2",
            "parameters": [
                "target",
                "newBounds",
                "hints"
            ],
            "start_line": 30,
            "end_line": 37,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\auto-resize\\BpmnAutoResizeProvider.js": {
        "function_1": {
            "signature": "/**\n* This module is a provider for automatically resizing parent BPMN elements\n*/",
            "content": "export default function BpmnAutoResizeProvider(eventBus, modeling) {\n  AutoResizeProvider.call(this, eventBus);\n\n  this._modeling = modeling;\n}",
            "name": "BpmnAutoResizeProvider",
            "parameters": [
                "eventBus",
                "modeling"
            ],
            "start_line": 13,
            "end_line": 17,
            "return": false
        },
        "function_2": {
            "signature": "/**\n* Check if the given target can be expanded\n*\n* @param  {djs.model.Shape} target\n*\n* @return {boolean}\n*/",
            "content": "BpmnAutoResizeProvider.prototype.canResize = function(elements, target) {\n\n  if (!is(target, 'bpmn:Participant') && !is(target, 'bpmn:Lane') && !(is(target, 'bpmn:SubProcess'))) {\n    return false;\n  }\n\n  var canResize = true;\n\n  forEach(elements, function(element) {\n\n    if (is(element, 'bpmn:Lane') || element.labelTarget) {\n      canResize = false;\n      return;\n    }\n  });\n\n  return canResize;\n};",
            "name": "function_2",
            "parameters": [
                "elements",
                "target"
            ],
            "start_line": 34,
            "end_line": 51,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\auto-resize\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\context-pad\\ContextPadProvider.js": {
        "function_1": {
            "signature": "/**\n* A provider for BPMN 2.0 elements context pad\n*/",
            "content": "export default function ContextPadProvider(\n    config, injector, eventBus,\n    contextPad, modeling, elementFactory,\n    connect, create, popupMenu,\n    canvas, rules, translate) {\n\n  config = config || {};\n\n  contextPad.registerProvider(this);\n\n  this._contextPad = contextPad;\n\n  this._modeling = modeling;\n\n  this._elementFactory = elementFactory;\n  this._connect = connect;\n  this._create = create;\n  this._popupMenu = popupMenu;\n  this._canvas = canvas;\n  this._rules = rules;\n  this._translate = translate;\n\n  if (config.autoPlace !== false) {\n    this._autoPlace = injector.get('autoPlace', false);\n  }\n\n  eventBus.on('create.end', 250, function(event) {\n    var shape = event.context.shape;\n\n    if (!hasPrimaryModifier(event)) {\n      return;\n    }\n\n    var entries = contextPad.getEntries(shape);\n\n    if (entries.replace) {\n      entries.replace.action.click(event, shape);\n    }\n  });\n}",
            "name": "ContextPadProvider",
            "parameters": [
                "config",
                "injector",
                "eventBus",
                "contextPad",
                "modeling",
                "elementFactory",
                "connect",
                "create",
                "popupMenu",
                "canvas",
                "rules",
                "translate"
            ],
            "start_line": 32,
            "end_line": 71,
            "return": true
        },
        "function_3": {
            "signature": "",
            "content": "ContextPadProvider.prototype.getContextPadEntries = function(element) {\n\n  var contextPad = this._contextPad,\n      modeling = this._modeling,\n\n      elementFactory = this._elementFactory,\n      connect = this._connect,\n      create = this._create,\n      popupMenu = this._popupMenu,\n      canvas = this._canvas,\n      rules = this._rules,\n      autoPlace = this._autoPlace,\n      translate = this._translate;\n\n  var actions = {};\n\n  if (element.type === 'label') {\n    return actions;\n  }\n\n  var businessObject = element.businessObject;\n\n  function startConnect(event, element) {\n    connect.start(event, element);\n  }\n\n  function removeElement(e) {\n    modeling.removeElements([ element ]);\n  }\n\n  function getReplaceMenuPosition(element) {\n\n    var Y_OFFSET = 5;\n\n    var diagramContainer = canvas.getContainer(),\n        pad = contextPad.getPad(element).html;\n\n    var diagramRect = diagramContainer.getBoundingClientRect(),\n        padRect = pad.getBoundingClientRect();\n\n    var top = padRect.top - diagramRect.top;\n    var left = padRect.left - diagramRect.left;\n\n    var pos = {\n      x: left,\n      y: top + padRect.height + Y_OFFSET\n    };\n\n    return pos;\n  }\n\n\n  /**\n   * Create an append action\n   *\n   * @param {String} type\n   * @param {String} className\n   * @param {String} [title]\n   * @param {Object} [options]\n   *\n   * @return {Object} descriptor\n   */\n  function appendAction(type, className, title, options) {\n\n    if (typeof title !== 'string') {\n      options = title;\n      title = translate('Append {type}', { type: type.replace(/^bpmn:/, '') });\n    }\n\n    function appendStart(event, element) {\n\n      var shape = elementFactory.createShape(assign({ type: type }, options));\n      create.start(event, shape, element);\n    }\n\n\n    var append = autoPlace ? function(event, element) {\n      var shape = elementFactory.createShape(assign({ type: type }, options));\n\n      autoPlace.append(element, shape);\n    } : appendStart;\n\n\n    return {\n      group: 'model',\n      className: className,\n      title: title,\n      action: {\n        dragstart: appendStart,\n        click: append\n      }\n    };\n  }\n\n  function splitLaneHandler(count) {\n\n    return function(event, element) {\n      // actual split\n      modeling.splitLane(element, count);\n\n      // refresh context pad after split to\n      // get rid of split icons\n      contextPad.open(element, true);\n    };\n  }\n\n\n  if (isAny(businessObject, [ 'bpmn:Lane', 'bpmn:Participant' ]) && isExpanded(businessObject)) {\n\n    var childLanes = getChildLanes(element);\n\n    assign(actions, {\n      'lane-insert-above': {\n        group: 'lane-insert-above',\n        className: 'bpmn-icon-lane-insert-above',\n        title: translate('Add Lane above'),\n        action: {\n          click: function(event, element) {\n            modeling.addLane(element, 'top');\n          }\n        }\n      }\n    });\n\n    if (childLanes.length < 2) {\n\n      if (element.height >= 120) {\n        assign(actions, {\n          'lane-divide-two': {\n            group: 'lane-divide',\n            className: 'bpmn-icon-lane-divide-two',\n            title: translate('Divide into two Lanes'),\n            action: {\n              click: splitLaneHandler(2)\n            }\n          }\n        });\n      }\n\n      if (element.height >= 180) {\n        assign(actions, {\n          'lane-divide-three': {\n            group: 'lane-divide',\n            className: 'bpmn-icon-lane-divide-three',\n            title: translate('Divide into three Lanes'),\n            action: {\n              click: splitLaneHandler(3)\n            }\n          }\n        });\n      }\n    }\n\n    assign(actions, {\n      'lane-insert-below': {\n        group: 'lane-insert-below',\n        className: 'bpmn-icon-lane-insert-below',\n        title: translate('Add Lane below'),\n        action: {\n          click: function(event, element) {\n            modeling.addLane(element, 'bottom');\n          }\n        }\n      }\n    });\n\n  }\n\n  if (is(businessObject, 'bpmn:FlowNode')) {\n\n    if (is(businessObject, 'bpmn:EventBasedGateway')) {\n\n      assign(actions, {\n        'append.receive-task': appendAction(\n          'bpmn:ReceiveTask',\n          'bpmn-icon-receive-task'\n        ),\n        'append.message-intermediate-event': appendAction(\n          'bpmn:IntermediateCatchEvent',\n          'bpmn-icon-intermediate-event-catch-message',\n          translate('Append MessageIntermediateCatchEvent'),\n          { eventDefinitionType: 'bpmn:MessageEventDefinition' }\n        ),\n        'append.timer-intermediate-event': appendAction(\n          'bpmn:IntermediateCatchEvent',\n          'bpmn-icon-intermediate-event-catch-timer',\n          translate('Append TimerIntermediateCatchEvent'),\n          { eventDefinitionType: 'bpmn:TimerEventDefinition' }\n        ),\n        'append.condtion-intermediate-event': appendAction(\n          'bpmn:IntermediateCatchEvent',\n          'bpmn-icon-intermediate-event-catch-condition',\n          translate('Append ConditionIntermediateCatchEvent'),\n          { eventDefinitionType: 'bpmn:ConditionalEventDefinition' }\n        ),\n        'append.signal-intermediate-event': appendAction(\n          'bpmn:IntermediateCatchEvent',\n          'bpmn-icon-intermediate-event-catch-signal',\n          translate('Append SignalIntermediateCatchEvent'),\n          { eventDefinitionType: 'bpmn:SignalEventDefinition' }\n        )\n      });\n    } else\n\n    if (isEventType(businessObject, 'bpmn:BoundaryEvent', 'bpmn:CompensateEventDefinition')) {\n\n      assign(actions, {\n        'append.compensation-activity':\n            appendAction(\n              'bpmn:Task',\n              'bpmn-icon-task',\n              translate('Append compensation activity'),\n              {\n                isForCompensation: true\n              }\n            )\n      });\n    } else\n\n    if (!is(businessObject, 'bpmn:EndEvent') &&\n        !businessObject.isForCompensation &&\n        !isEventType(businessObject, 'bpmn:IntermediateThrowEvent', 'bpmn:LinkEventDefinition') &&\n        !isEventSubProcess(businessObject)) {\n\n      assign(actions, {\n        'append.end-event': appendAction(\n          'bpmn:EndEvent',\n          'bpmn-icon-end-event-none'\n        ),\n        'append.gateway': appendAction(\n          'bpmn:ExclusiveGateway',\n          'bpmn-icon-gateway-none',\n          translate('Append Gateway')\n        ),\n        'append.append-task': appendAction(\n          'bpmn:Task',\n          'bpmn-icon-task'\n        ),\n        'append.intermediate-event': appendAction(\n          'bpmn:IntermediateThrowEvent',\n          'bpmn-icon-intermediate-event-none',\n          translate('Append Intermediate/Boundary Event')\n        )\n      });\n    }\n  }\n\n  if (!popupMenu.isEmpty(element, 'bpmn-replace')) {\n    // Replace menu entry\n    assign(actions, {\n      'replace': {\n        group: 'edit',\n        className: 'bpmn-icon-screw-wrench',\n        title: translate('Change type'),\n        action: {\n          click: function(event, element) {\n\n            var position = assign(getReplaceMenuPosition(element), {\n              cursor: { x: event.x, y: event.y }\n            });\n\n            popupMenu.open(element, 'bpmn-replace', position);\n          }\n        }\n      }\n    });\n  }\n\n  if (isAny(businessObject, [\n    'bpmn:FlowNode',\n    'bpmn:InteractionNode',\n    'bpmn:DataObjectReference',\n    'bpmn:DataStoreReference'\n  ])) {\n\n    assign(actions, {\n      'append.text-annotation': appendAction('bpmn:TextAnnotation', 'bpmn-icon-text-annotation'),\n\n      'connect': {\n        group: 'connect',\n        className: 'bpmn-icon-connection-multi',\n        title: translate('Connect using ' +\n                  (businessObject.isForCompensation ? '' : 'Sequence/MessageFlow or ') +\n                  'Association'),\n        action: {\n          click: startConnect,\n          dragstart: startConnect\n        }\n      }\n    });\n  }\n\n  if (isAny(businessObject, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ])) {\n    assign(actions, {\n      'connect': {\n        group: 'connect',\n        className: 'bpmn-icon-connection-multi',\n        title: translate('Connect using DataInputAssociation'),\n        action: {\n          click: startConnect,\n          dragstart: startConnect\n        }\n      }\n    });\n  }\n\n  // delete element entry, only show if allowed by rules\n  var deleteAllowed = rules.allowed('elements.delete', { elements: [ element ] });\n\n  if (isArray(deleteAllowed)) {\n    // was the element returned as a deletion candidate?\n    deleteAllowed = deleteAllowed[0] === element;\n  }\n\n  if (deleteAllowed) {\n    assign(actions, {\n      'delete': {\n        group: 'edit',\n        className: 'bpmn-icon-trash',\n        title: translate('Remove'),\n        action: {\n          click: removeElement\n        }\n      }\n    });\n  }\n\n  return actions;\n};",
            "name": "function_3",
            "parameters": [
                "element"
            ],
            "start_line": 89,
            "end_line": 417,
            "return": true
        },
        "function_15": {
            "signature": "",
            "content": "function isEventType(eventBo, type, definition) {\n\n  var isType = eventBo.$instanceOf(type);\n  var isDefinition = false;\n\n  var definitions = eventBo.eventDefinitions || [];\n  forEach(definitions, function(def) {\n    if (def.$type === definition) {\n      isDefinition = true;\n    }\n  });\n\n  return isType && isDefinition;\n}",
            "name": "isEventType",
            "parameters": [
                "eventBo",
                "type",
                "definition"
            ],
            "start_line": 419,
            "end_line": 432,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\context-pad\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\copy-paste\\BpmnCopyPaste.js": {
        "function_1": {
            "signature": "",
            "content": "function setProperties(descriptor, data, properties) {\n  forEach(properties, function(property) {\n    if (data[property] !== undefined) {\n      descriptor[property] = data[property];\n    }\n  });\n}",
            "name": "setProperties",
            "parameters": [
                "descriptor",
                "data",
                "properties"
            ],
            "start_line": 18,
            "end_line": 24,
            "return": false
        },
        "function_3": {
            "signature": "",
            "content": "function removeProperties(element, properties) {\n  forEach(properties, function(prop) {\n    if (element[prop]) {\n      delete element[prop];\n    }\n  });\n}",
            "name": "removeProperties",
            "parameters": [
                "element",
                "properties"
            ],
            "start_line": 26,
            "end_line": 32,
            "return": false
        },
        "function_5": {
            "signature": "",
            "content": "export default function BpmnCopyPaste(\n    bpmnFactory, eventBus, copyPaste,\n    clipboard, canvas, bpmnRules) {\n\n  var helper = new ModelCloneHelper(eventBus, bpmnFactory);\n\n  copyPaste.registerDescriptor(function(element, descriptor) {\n    var businessObject = descriptor.oldBusinessObject = getBusinessObject(element);\n\n    var colors = {};\n\n    descriptor.type = element.type;\n\n    setProperties(descriptor, businessObject.di, [ 'isExpanded' ]);\n\n    setProperties(colors, businessObject.di, [ 'fill', 'stroke' ]);\n\n    descriptor.colors = colors;\n\n    if (element.type === 'label') {\n      return descriptor;\n    }\n\n    setProperties(descriptor, businessObject, [\n      'processRef',\n      'triggeredByEvent'\n    ]);\n\n    if (businessObject.default) {\n      descriptor.default = businessObject.default.id;\n    }\n\n    return descriptor;\n  });\n\n  eventBus.on('element.paste', function(context) {\n    var descriptor = context.descriptor,\n        createdElements = context.createdElements,\n        parent = descriptor.parent,\n        rootElement = canvas.getRootElement(),\n        oldBusinessObject = descriptor.oldBusinessObject,\n        newBusinessObject,\n        source,\n        target,\n        canConnect;\n\n    newBusinessObject = bpmnFactory.create(oldBusinessObject.$type);\n\n    var properties = getProperties(oldBusinessObject.$descriptor);\n\n    properties = filter(properties, function(property) {\n      return IGNORED_PROPERTIES.indexOf(property.replace(/bpmn:/, '')) === -1;\n    });\n\n    descriptor.businessObject = helper.clone(oldBusinessObject, newBusinessObject, properties);\n\n    if (descriptor.type === 'label') {\n      return;\n    }\n\n    if (is(parent, 'bpmn:Process')) {\n      descriptor.parent = is(rootElement, 'bpmn:Collaboration') ? rootElement : parent;\n    }\n\n    if (descriptor.type === 'bpmn:DataOutputAssociation' ||\n        descriptor.type === 'bpmn:DataInputAssociation' ||\n        descriptor.type === 'bpmn:MessageFlow') {\n      descriptor.parent = rootElement;\n    }\n\n    if (is(parent, 'bpmn:Lane')) {\n      descriptor.parent = parent.parent;\n    }\n\n    // make sure that the correct type of connection is created\n    if (descriptor.waypoints) {\n      source = createdElements[descriptor.source];\n      target = createdElements[descriptor.target];\n\n      if (source && target) {\n        source = source.element;\n        target = target.element;\n      }\n\n      canConnect = bpmnRules.canConnect(source, target);\n\n      if (canConnect) {\n        descriptor.type = canConnect.type;\n      }\n    }\n\n    // remove the id or else we cannot paste multiple times\n    delete newBusinessObject.id;\n\n    // assign an ID\n    bpmnFactory._ensureId(newBusinessObject);\n\n    if (descriptor.type === 'bpmn:Participant' && descriptor.processRef) {\n      descriptor.processRef = newBusinessObject.processRef = bpmnFactory.create('bpmn:Process');\n    }\n\n    setProperties(newBusinessObject, descriptor, [\n      'isExpanded',\n      'triggeredByEvent'\n    ]);\n\n    removeProperties(descriptor, [\n      'triggeredByEvent'\n    ]);\n  });\n\n}",
            "name": "BpmnCopyPaste",
            "parameters": [
                "bpmnFactory",
                "eventBus",
                "copyPaste",
                "clipboard",
                "canvas",
                "bpmnRules"
            ],
            "start_line": 34,
            "end_line": 145,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\copy-paste\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\distribute-elements\\BpmnDistributeElements.js": {
        "function_1": {
            "signature": "/**\n* Registers element exclude filters for elements that\n* currently do not support distribution.\n*/",
            "content": "export default function BpmnDistributeElements(distributeElements) {\n\n  distributeElements.registerFilter(function(elements) {\n    return filter(elements, function(element) {\n      var cannotDistribute = isAny(element, [\n        'bpmn:Association',\n        'bpmn:BoundaryEvent',\n        'bpmn:DataInputAssociation',\n        'bpmn:DataOutputAssociation',\n        'bpmn:Lane',\n        'bpmn:MessageFlow',\n        'bpmn:Participant',\n        'bpmn:SequenceFlow',\n        'bpmn:TextAnnotation'\n      ]);\n\n      return !(element.labelTarget || cannotDistribute);\n    });\n  });\n}",
            "name": "BpmnDistributeElements",
            "parameters": [
                "distributeElements"
            ],
            "start_line": 14,
            "end_line": 33,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\distribute-elements\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\editor-actions\\BpmnEditorActions.js": {
        "function_1": {
            "signature": "/**\n* Registers and executes BPMN specific editor actions.\n*\n* @param {Injector} injector\n*/",
            "content": "export default function BpmnEditorActions(injector) {\n  injector.invoke(EditorActions, this);\n}",
            "name": "BpmnEditorActions",
            "parameters": [
                "injector"
            ],
            "start_line": 19,
            "end_line": 21,
            "return": false
        },
        "function_2": {
            "signature": "/**\n* Register default actions.\n*\n* @param {Injector} injector\n*/",
            "content": "BpmnEditorActions.prototype._registerDefaultActions = function(injector) {\n\n  // (0) invoke super method\n\n  EditorActions.prototype._registerDefaultActions.call(this, injector);\n\n  // (1) retrieve optional components to integrate with\n\n  var canvas = injector.get('canvas', false);\n  var elementRegistry = injector.get('elementRegistry', false);\n  var selection = injector.get('selection', false);\n  var spaceTool = injector.get('spaceTool', false);\n  var lassoTool = injector.get('lassoTool', false);\n  var handTool = injector.get('handTool', false);\n  var globalConnect = injector.get('globalConnect', false);\n  var distributeElements = injector.get('distributeElements', false);\n  var alignElements = injector.get('alignElements', false);\n  var directEditing = injector.get('directEditing', false);\n  var searchPad = injector.get('searchPad', false);\n  var modeling = injector.get('modeling', false);\n\n  // (2) check components and register actions\n\n  if (canvas && elementRegistry && selection) {\n    this._registerAction('selectElements', function() {\n      // select all elements except for the invisible\n      // root element\n      var rootElement = canvas.getRootElement();\n\n      var elements = elementRegistry.filter(function(element) {\n        return element !== rootElement;\n      });\n\n      selection.select(elements);\n\n      return elements;\n    });\n  }\n\n  if (spaceTool) {\n    this._registerAction('spaceTool', function() {\n      spaceTool.toggle();\n    });\n  }\n\n  if (lassoTool) {\n    this._registerAction('lassoTool', function() {\n      lassoTool.toggle();\n    });\n  }\n\n  if (handTool) {\n    this._registerAction('handTool', function() {\n      handTool.toggle();\n    });\n  }\n\n  if (globalConnect) {\n    this._registerAction('globalConnectTool', function() {\n      globalConnect.toggle();\n    });\n  }\n\n  if (selection && distributeElements) {\n    this._registerAction('distributeElements', function(opts) {\n      var currentSelection = selection.get(),\n          type = opts.type;\n\n      if (currentSelection.length) {\n        distributeElements.trigger(currentSelection, type);\n      }\n    });\n  }\n\n  if (selection && alignElements) {\n    this._registerAction('alignElements', function(opts) {\n      var currentSelection = selection.get(),\n          aligneableElements = [],\n          type = opts.type;\n\n      if (currentSelection.length) {\n        aligneableElements = filter(currentSelection, function(element) {\n          return !is(element, 'bpmn:Lane');\n        });\n\n        alignElements.trigger(aligneableElements, type);\n      }\n    });\n  }\n\n  if (selection && modeling) {\n    this._registerAction('setColor', function(opts) {\n      var currentSelection = selection.get();\n\n      if (currentSelection.length) {\n        modeling.setColor(currentSelection, opts);\n      }\n    });\n  }\n\n  if (selection && directEditing) {\n    this._registerAction('directEditing', function() {\n      var currentSelection = selection.get();\n\n      if (currentSelection.length) {\n        directEditing.activate(currentSelection[0]);\n      }\n    });\n  }\n\n  if (searchPad) {\n    this._registerAction('find', function() {\n      searchPad.toggle();\n    });\n  }\n\n  if (canvas && modeling) {\n    this._registerAction('moveToOrigin', function() {\n      var rootElement = canvas.getRootElement(),\n          boundingBox,\n          elements;\n\n      if (is(rootElement, 'bpmn:Collaboration')) {\n        elements = elementRegistry.filter(function(element) {\n          return is(element.parent, 'bpmn:Collaboration');\n        });\n      } else {\n        elements = elementRegistry.filter(function(element) {\n          return element !== rootElement && !is(element.parent, 'bpmn:SubProcess');\n        });\n      }\n\n      boundingBox = getBBox(elements);\n\n      modeling.moveElements(\n        elements,\n        { x: -boundingBox.x, y: -boundingBox.y },\n        rootElement\n      );\n    });\n  }\n\n};",
            "name": "function_2",
            "parameters": [
                "injector"
            ],
            "start_line": 34,
            "end_line": 176,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\editor-actions\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\grid-snapping\\BpmnGridSnapping.js": {
        "function_1": {
            "signature": "",
            "content": "export default function BpmnGridSnapping(eventBus) {\n  eventBus.on([\n    'create.init',\n    'shape.move.init'\n  ], function(event) {\n    var context = event.context,\n        shape = event.shape;\n\n    if (isAny(shape, [\n      'bpmn:Participant',\n      'bpmn:SubProcess',\n      'bpmn:TextAnnotation'\n    ])) {\n      if (!context.gridSnappingContext) {\n        context.gridSnappingContext = {};\n      }\n\n      context.gridSnappingContext.snapLocation = 'top-left';\n    }\n  });\n}",
            "name": "BpmnGridSnapping",
            "parameters": [
                "eventBus"
            ],
            "start_line": 3,
            "end_line": 23,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\grid-snapping\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\grid-snapping\\behavior\\AutoPlaceBehavior.js": {
        "function_1": {
            "signature": "",
            "content": "export default function AutoPlaceBehavior(eventBus, gridSnapping) {\n  eventBus.on('autoPlace', function(context) {\n    var source = context.source,\n        sourceMid = getMid(source),\n        shape = context.shape;\n\n    var position = getNewShapePosition(source, shape);\n\n    [ 'x', 'y' ].forEach(function(axis) {\n      var options = {};\n\n      // do not snap if x/y equal\n      if (position[ axis ] === sourceMid[ axis ]) {\n        return;\n      }\n\n      if (position[ axis ] > sourceMid[ axis ]) {\n        options.min = position[ axis ];\n      } else {\n        options.max = position[ axis ];\n      }\n\n      if (is(shape, 'bpmn:TextAnnotation')) {\n\n        if (isHorizontal(axis)) {\n          options.offset = -shape.width / 2;\n        } else {\n          options.offset = -shape.height / 2;\n        }\n\n      }\n\n      position[ axis ] = gridSnapping.snapValue(position[ axis ], options);\n\n    });\n\n    // must be returned to be considered by auto place\n    return position;\n  });\n}",
            "name": "AutoPlaceBehavior",
            "parameters": [
                "eventBus",
                "gridSnapping"
            ],
            "start_line": 7,
            "end_line": 46,
            "return": true
        },
        "function_4": {
            "signature": "// helpers //////////",
            "content": "function isHorizontal(axis) {\n  return axis === 'x';\n}",
            "name": "isHorizontal",
            "parameters": [
                "axis"
            ],
            "start_line": 55,
            "end_line": 57,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\grid-snapping\\behavior\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\grid-snapping\\behavior\\LayoutConnectionBehavior.js": {
        "function_1": {
            "signature": "/**\n* Snaps connections with Manhattan layout.\n*/",
            "content": "export default function LayoutConnectionBehavior(eventBus, gridSnapping, modeling) {\n  CommandInterceptor.call(this, eventBus);\n\n  this._gridSnapping = gridSnapping;\n\n  var self = this;\n\n  this.postExecuted([\n    'connection.create',\n    'connection.layout'\n  ], HIGH_PRIORITY, function(event) {\n    var context = event.context,\n        connection = context.connection,\n        waypoints = connection.waypoints;\n\n    if (hasMiddleSegments(waypoints)) {\n      modeling.updateProperties(connection, {\n        waypoints: self.snapMiddleSegments(waypoints)\n      });\n    }\n  });\n}",
            "name": "LayoutConnectionBehavior",
            "parameters": [
                "eventBus",
                "gridSnapping",
                "modeling"
            ],
            "start_line": 13,
            "end_line": 34,
            "return": false
        },
        "function_3": {
            "signature": "/**\n* Snap middle segments of a given connection.\n*\n* @param {Array<Point>} waypoints\n*\n* @returns {Array<Point>}\n*/",
            "content": "LayoutConnectionBehavior.prototype.snapMiddleSegments = function(waypoints) {\n  var gridSnapping = this._gridSnapping;\n\n  var middleSegments = getMiddleSegments(waypoints);\n\n  middleSegments.forEach(function(middleSegment) {\n    var segmentStart = middleSegment.start,\n        segmentEnd = middleSegment.end;\n\n    var aligned = pointsAligned(segmentStart, segmentEnd);\n\n    if (horizontallyAligned(aligned)) {\n\n      // snap horizontally\n      segmentStart.x = segmentEnd.x = gridSnapping.snapValue(segmentStart.x);\n    }\n\n    if (verticallyAligned(aligned)) {\n\n      // snap vertically\n      segmentStart.y = segmentEnd.y = gridSnapping.snapValue(segmentStart.y);\n    }\n  });\n\n  return waypoints;\n};",
            "name": "function_3",
            "parameters": [
                "waypoints"
            ],
            "start_line": 51,
            "end_line": 76,
            "return": true
        },
        "function_5": {
            "signature": "/**\n* Check wether a connection has a middle segments.\n*\n* @param {Array} waypoints\n*\n* @returns {boolean}\n*/",
            "content": "function hasMiddleSegments(waypoints) {\n  return waypoints.length > 3;\n}",
            "name": "hasMiddleSegments",
            "parameters": [
                "waypoints"
            ],
            "start_line": 89,
            "end_line": 91,
            "return": true
        },
        "function_6": {
            "signature": "/**\n* Check wether an alignment is horizontal.\n*\n* @param {string} aligned\n*\n* @returns {boolean}\n*/",
            "content": "function horizontallyAligned(aligned) {\n  return aligned === 'h';\n}",
            "name": "horizontallyAligned",
            "parameters": [
                "aligned"
            ],
            "start_line": 100,
            "end_line": 102,
            "return": true
        },
        "function_7": {
            "signature": "/**\n* Check wether an alignment is vertical.\n*\n* @param {string} aligned\n*\n* @returns {boolean}\n*/",
            "content": "function verticallyAligned(aligned) {\n  return aligned === 'v';\n}",
            "name": "verticallyAligned",
            "parameters": [
                "aligned"
            ],
            "start_line": 111,
            "end_line": 113,
            "return": true
        },
        "function_8": {
            "signature": "/**\n* Get middle segments from a given connection.\n*\n* @param {Array} waypoints\n*\n* @returns {Array}\n*/",
            "content": "function getMiddleSegments(waypoints) {\n  var middleSegments = [];\n\n  for (var i = 1; i < waypoints.length - 2; i++) {\n    middleSegments.push({\n      start: waypoints[i],\n      end: waypoints[i + 1]\n    });\n  }\n\n  return middleSegments;\n}",
            "name": "getMiddleSegments",
            "parameters": [
                "waypoints"
            ],
            "start_line": 122,
            "end_line": 133,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\keyboard\\BpmnKeyboardBindings.js": {
        "function_1": {
            "signature": "/**\n* BPMN 2.0 specific keyboard bindings.\n*\n* @param {Injector} injector\n*/",
            "content": "export default function BpmnKeyboardBindings(injector) {\n  injector.invoke(KeyboardBindings, this);\n}",
            "name": "BpmnKeyboardBindings",
            "parameters": [
                "injector"
            ],
            "start_line": 11,
            "end_line": 13,
            "return": false
        },
        "function_2": {
            "signature": "/**\n* Register available keyboard bindings.\n*\n* @param {Keyboard} keyboard\n* @param {EditorActions} editorActions\n*/",
            "content": "BpmnKeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {\n\n  // inherit default bindings\n  KeyboardBindings.prototype.registerBindings.call(this, keyboard, editorActions);\n\n  /**\n   * Add keyboard binding if respective editor action\n   * is registered.\n   *\n   * @param {String} action name\n   * @param {Function} fn that implements the key binding\n   */\n  function addListener(action, fn) {\n\n    if (editorActions.isRegistered(action)) {\n      keyboard.addListener(fn);\n    }\n  }\n\n  // select all elements\n  // CTRL + A\n  addListener('selectElements', function(context) {\n\n    var event = context.keyEvent;\n\n    if (keyboard.isKey(['a', 'A'], event) && keyboard.isCmd(event)) {\n      editorActions.trigger('selectElements');\n\n      return true;\n    }\n  });\n\n  // search labels\n  // CTRL + F\n  addListener('find', function(context) {\n\n    var event = context.keyEvent;\n\n    if (keyboard.isKey(['f', 'F'], event) && keyboard.isCmd(event)) {\n      editorActions.trigger('find');\n\n      return true;\n    }\n  });\n\n  // activate space tool\n  // S\n  addListener('spaceTool', function(context) {\n\n    var event = context.keyEvent;\n\n    if (keyboard.hasModifier(event)) {\n      return;\n    }\n\n    if (keyboard.isKey(['s', 'S'], event)) {\n      editorActions.trigger('spaceTool');\n\n      return true;\n    }\n  });\n\n  // activate lasso tool\n  // L\n  addListener('lassoTool', function(context) {\n\n    var event = context.keyEvent;\n\n    if (keyboard.hasModifier(event)) {\n      return;\n    }\n\n    if (keyboard.isKey(['l', 'L'], event)) {\n      editorActions.trigger('lassoTool');\n\n      return true;\n    }\n  });\n\n  // activate hand tool\n  // H\n  addListener('handTool', function(context) {\n\n    var event = context.keyEvent;\n\n    if (keyboard.hasModifier(event)) {\n      return;\n    }\n\n    if (keyboard.isKey(['h', 'H'], event)) {\n      editorActions.trigger('handTool');\n\n      return true;\n    }\n  });\n\n  // activate global connect tool\n  // C\n  addListener('globalConnectTool', function(context) {\n\n    var event = context.keyEvent;\n\n    if (keyboard.hasModifier(event)) {\n      return;\n    }\n\n    if (keyboard.isKey(['c', 'C'], event)) {\n      editorActions.trigger('globalConnectTool');\n\n      return true;\n    }\n  });\n\n  // activate direct editing\n  // E\n  addListener('directEditing', function(context) {\n\n    var event = context.keyEvent;\n\n    if (keyboard.hasModifier(event)) {\n      return;\n    }\n\n    if (keyboard.isKey(['e', 'E'], event)) {\n      editorActions.trigger('directEditing');\n\n      return true;\n    }\n  });\n\n};",
            "name": "function_2",
            "parameters": [
                "keyboard",
                "editorActions"
            ],
            "start_line": 28,
            "end_line": 158,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\keyboard\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\label-editing\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\label-editing\\LabelEditingPreview.js": {
        "function_1": {
            "signature": "",
            "content": "export default function LabelEditingPreview(\n    eventBus, canvas, elementRegistry,\n    pathMap) {\n\n  var self = this;\n\n  var defaultLayer = canvas.getDefaultLayer();\n\n  var element, absoluteElementBBox, gfx;\n\n  eventBus.on('directEditing.activate', function(context) {\n    var activeProvider = context.active;\n\n    element = activeProvider.element.label || activeProvider.element;\n\n    // text annotation\n    if (is(element, 'bpmn:TextAnnotation')) {\n      absoluteElementBBox = canvas.getAbsoluteBBox(element);\n\n      gfx = svgCreate('g');\n\n      var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: element.height,\n        position: {\n          mx: 0.0,\n          my: 0.0\n        }\n      });\n\n      var path = self.path = svgCreate('path');\n\n      svgAttr(path, {\n        d: textPathData,\n        strokeWidth: 2,\n        stroke: getStrokeColor(element)\n      });\n\n      svgAppend(gfx, path);\n\n      svgAppend(defaultLayer, gfx);\n\n      translate(gfx, element.x, element.y);\n    }\n\n    if (is(element, 'bpmn:TextAnnotation') ||\n        element.labelTarget) {\n      canvas.addMarker(element, MARKER_HIDDEN);\n    } else if (is(element, 'bpmn:Task') ||\n               is(element, 'bpmn:CallActivity') ||\n               is(element, 'bpmn:SubProcess') ||\n               is(element, 'bpmn:Participant')) {\n      canvas.addMarker(element, MARKER_LABEL_HIDDEN);\n    }\n  });\n\n  eventBus.on('directEditing.resize', function(context) {\n\n    // text annotation\n    if (is(element, 'bpmn:TextAnnotation')) {\n      var height = context.height,\n          dy = context.dy;\n\n      var newElementHeight = Math.max(element.height / absoluteElementBBox.height * (height + dy), 0);\n\n      var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {\n        xScaleFactor: 1,\n        yScaleFactor: 1,\n        containerWidth: element.width,\n        containerHeight: newElementHeight,\n        position: {\n          mx: 0.0,\n          my: 0.0\n        }\n      });\n\n      svgAttr(self.path, {\n        d: textPathData\n      });\n    }\n  });\n\n  eventBus.on([ 'directEditing.complete', 'directEditing.cancel' ], function(context) {\n    var activeProvider = context.active;\n\n    if (activeProvider) {\n      canvas.removeMarker(activeProvider.element.label || activeProvider.element, MARKER_HIDDEN);\n      canvas.removeMarker(element, MARKER_LABEL_HIDDEN);\n    }\n\n    element = undefined;\n    absoluteElementBBox = undefined;\n\n    if (gfx) {\n      svgRemove(gfx);\n\n      gfx = undefined;\n    }\n  });\n}",
            "name": "LabelEditingPreview",
            "parameters": [
                "eventBus",
                "canvas",
                "elementRegistry",
                "pathMap"
            ],
            "start_line": 21,
            "end_line": 122,
            "return": false
        },
        "function_5": {
            "signature": "// helpers ///////////////////",
            "content": "function getStrokeColor(element, defaultColor) {\n  var bo = getBusinessObject(element);\n\n  return bo.di.get('stroke') || defaultColor || 'black';\n}",
            "name": "getStrokeColor",
            "parameters": [
                "element",
                "defaultColor"
            ],
            "start_line": 134,
            "end_line": 138,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\label-editing\\LabelEditingProvider.js": {
        "function_1": {
            "signature": "",
            "content": "export default function LabelEditingProvider(\n    eventBus, canvas, directEditing,\n    modeling, resizeHandles, textRenderer) {\n\n  this._canvas = canvas;\n  this._modeling = modeling;\n  this._textRenderer = textRenderer;\n\n  directEditing.registerProvider(this);\n\n  // listen to dblclick on non-root elements\n  eventBus.on('element.dblclick', function(event) {\n    activateDirectEdit(event.element, true);\n  });\n\n  // complete on followup canvas operation\n  eventBus.on([\n    'element.mousedown',\n    'drag.init',\n    'canvas.viewbox.changing',\n    'autoPlace',\n    'popupMenu.open'\n  ], function(event) {\n\n    if (directEditing.isActive()) {\n      directEditing.complete();\n    }\n  });\n\n  // cancel on command stack changes\n  eventBus.on([ 'commandStack.changed' ], function(e) {\n    if (directEditing.isActive()) {\n      directEditing.cancel();\n    }\n  });\n\n\n  eventBus.on('directEditing.activate', function(event) {\n    resizeHandles.removeResizers();\n  });\n\n  eventBus.on('create.end', 500, function(event) {\n\n    var element = event.shape,\n        canExecute = event.context.canExecute,\n        isTouch = event.isTouch;\n\n    // TODO(nikku): we need to find a way to support the\n    // direct editing on mobile devices; right now this will\n    // break for desworkflowediting on mobile devices\n    // as it breaks the user interaction workflow\n\n    // TODO(nre): we should temporarily focus the edited element\n    // here and release the focused viewport after the direct edit\n    // operation is finished\n    if (isTouch) {\n      return;\n    }\n\n    if (!canExecute) {\n      return;\n    }\n\n    activateDirectEdit(element);\n  });\n\n  eventBus.on('autoPlace.end', 500, function(event) {\n    activateDirectEdit(event.shape);\n  });\n\n\n  function activateDirectEdit(element, force) {\n    if (force ||\n        isAny(element, [ 'bpmn:Task', 'bpmn:TextAnnotation' ]) ||\n        isCollapsedSubProcess(element)) {\n\n      directEditing.activate(element);\n    }\n  }\n\n}",
            "name": "LabelEditingProvider",
            "parameters": [
                "eventBus",
                "canvas",
                "directEditing",
                "modeling",
                "resizeHandles",
                "textRenderer"
            ],
            "start_line": 21,
            "end_line": 101,
            "return": true
        },
        "function_9": {
            "signature": "/**\n* Activate direct editing for activities and text annotations.\n*\n* @param  {djs.model.Base} element\n*\n* @return {Object} an object with properties bounds (position and size), text and options\n*/",
            "content": "LabelEditingProvider.prototype.activate = function(element) {\n\n  // text\n  var text = getLabel(element);\n\n  if (text === undefined) {\n    return;\n  }\n\n  var context = {\n    text: text\n  };\n\n  // bounds\n  var bounds = this.getEditingBBox(element);\n\n  assign(context, bounds);\n\n  var options = {};\n\n  // tasks\n  if (\n    isAny(element, [\n      'bpmn:Task',\n      'bpmn:Participant',\n      'bpmn:Lane',\n      'bpmn:CallActivity'\n    ]) ||\n    isCollapsedSubProcess(element)\n  ) {\n    assign(options, {\n      centerVertically: true\n    });\n  }\n\n  // external labels\n  if (isLabelExternal(element)) {\n    assign(options, {\n      autoResize: true\n    });\n  }\n\n  // text annotations\n  if (is(element, 'bpmn:TextAnnotation')) {\n    assign(options, {\n      resizable: true,\n      autoResize: true\n    });\n  }\n\n  assign(context, {\n    options: options\n  });\n\n  return context;\n};",
            "name": "function_9",
            "parameters": [
                "element"
            ],
            "start_line": 120,
            "end_line": 175,
            "return": true
        },
        "function_10": {
            "signature": "/**\n* Get the editing bounding box based on the element's size and position\n*\n* @param  {djs.model.Base} element\n*\n* @return {Object} an object containing information about position\n*                  and size (fixed or minimum and/or maximum)\n*/",
            "content": "LabelEditingProvider.prototype.getEditingBBox = function(element) {\n  var canvas = this._canvas;\n\n  var target = element.label || element;\n\n  var bbox = canvas.getAbsoluteBBox(target);\n\n  var mid = {\n    x: bbox.x + bbox.width / 2,\n    y: bbox.y + bbox.height / 2\n  };\n\n  // default position\n  var bounds = { x: bbox.x, y: bbox.y };\n\n  var zoom = canvas.zoom();\n\n  var defaultStyle = this._textRenderer.getDefaultStyle(),\n      externalStyle = this._textRenderer.getExternalStyle();\n\n  // take zoom into account\n  var externalFontSize = externalStyle.fontSize * zoom,\n      externalLineHeight = externalStyle.lineHeight,\n      defaultFontSize = defaultStyle.fontSize * zoom,\n      defaultLineHeight = defaultStyle.lineHeight;\n\n  var style = {\n    fontFamily: this._textRenderer.getDefaultStyle().fontFamily,\n    fontWeight: this._textRenderer.getDefaultStyle().fontWeight\n  };\n\n  // adjust for expanded pools AND lanes\n  if (is(element, 'bpmn:Lane') || isExpandedPool(element)) {\n\n    assign(bounds, {\n      width: bbox.height,\n      height: 30 * zoom,\n      x: bbox.x - bbox.height / 2 + (15 * zoom),\n      y: mid.y - (30 * zoom) / 2\n    });\n\n    assign(style, {\n      fontSize: defaultFontSize + 'px',\n      lineHeight: defaultLineHeight,\n      paddingTop: (7 * zoom) + 'px',\n      paddingBottom: (7 * zoom) + 'px',\n      paddingLeft: (5 * zoom) + 'px',\n      paddingRight: (5 * zoom) + 'px',\n      transform: 'rotate(-90deg)'\n    });\n  }\n\n\n  // internal labels for tasks and collapsed call activities,\n  // sub processes and participants\n  if (isAny(element, [ 'bpmn:Task', 'bpmn:CallActivity']) ||\n      isCollapsedPool(element) ||\n      isCollapsedSubProcess(element)) {\n\n    assign(bounds, {\n      width: bbox.width,\n      height: bbox.height\n    });\n\n    assign(style, {\n      fontSize: defaultFontSize + 'px',\n      lineHeight: defaultLineHeight,\n      paddingTop: (7 * zoom) + 'px',\n      paddingBottom: (7 * zoom) + 'px',\n      paddingLeft: (5 * zoom) + 'px',\n      paddingRight: (5 * zoom) + 'px'\n    });\n  }\n\n\n  // internal labels for expanded sub processes\n  if (isExpandedSubProcess(element)) {\n    assign(bounds, {\n      width: bbox.width,\n      x: bbox.x\n    });\n\n    assign(style, {\n      fontSize: defaultFontSize + 'px',\n      lineHeight: defaultLineHeight,\n      paddingTop: (7 * zoom) + 'px',\n      paddingBottom: (7 * zoom) + 'px',\n      paddingLeft: (5 * zoom) + 'px',\n      paddingRight: (5 * zoom) + 'px'\n    });\n  }\n\n  var width = 90 * zoom,\n      paddingTop = 7 * zoom,\n      paddingBottom = 4 * zoom;\n\n  // external labels for events, data elements, gateways and connections\n  if (target.labelTarget) {\n    assign(bounds, {\n      width: width,\n      height: bbox.height + paddingTop + paddingBottom,\n      x: mid.x - width / 2,\n      y: bbox.y - paddingTop\n    });\n\n    assign(style, {\n      fontSize: externalFontSize + 'px',\n      lineHeight: externalLineHeight,\n      paddingTop: paddingTop + 'px',\n      paddingBottom: paddingBottom + 'px'\n    });\n  }\n\n  // external label not yet created\n  if (isLabelExternal(target)\n      && !hasExternalLabel(target)\n      && !isLabel(target)) {\n\n    var externalLabelMid = getExternalLabelMid(element);\n\n    var absoluteBBox = canvas.getAbsoluteBBox({\n      x: externalLabelMid.x,\n      y: externalLabelMid.y,\n      width: 0,\n      height: 0\n    });\n\n    var height = externalFontSize + paddingTop + paddingBottom;\n\n    assign(bounds, {\n      width: width,\n      height: height,\n      x: absoluteBBox.x - width / 2,\n      y: absoluteBBox.y - height / 2\n    });\n\n    assign(style, {\n      fontSize: externalFontSize + 'px',\n      lineHeight: externalLineHeight,\n      paddingTop: paddingTop + 'px',\n      paddingBottom: paddingBottom + 'px'\n    });\n  }\n\n  // text annotations\n  if (is(element, 'bpmn:TextAnnotation')) {\n    assign(bounds, {\n      width: bbox.width,\n      height: bbox.height,\n      minWidth: 30 * zoom,\n      minHeight: 10 * zoom\n    });\n\n    assign(style, {\n      textAlign: 'left',\n      paddingTop: (5 * zoom) + 'px',\n      paddingBottom: (7 * zoom) + 'px',\n      paddingLeft: (7 * zoom) + 'px',\n      paddingRight: (5 * zoom) + 'px',\n      fontSize: defaultFontSize + 'px',\n      lineHeight: defaultLineHeight\n    });\n  }\n\n  return { bounds: bounds, style: style };\n};",
            "name": "function_10",
            "parameters": [
                "element"
            ],
            "start_line": 186,
            "end_line": 351,
            "return": true
        },
        "function_11": {
            "signature": "",
            "content": "LabelEditingProvider.prototype.update = function(\n    element, newLabel,\n    activeContextText, bounds) {\n\n  var newBounds,\n      bbox;\n\n  if (is(element, 'bpmn:TextAnnotation')) {\n\n    bbox = this._canvas.getAbsoluteBBox(element);\n\n    newBounds = {\n      x: element.x,\n      y: element.y,\n      width: element.width / bbox.width * bounds.width,\n      height: element.height / bbox.height * bounds.height\n    };\n  }\n\n  if (isEmptyText(newLabel)) {\n    newLabel = null;\n  }\n\n  this._modeling.updateLabel(element, newLabel, newBounds);\n};",
            "name": "function_11",
            "parameters": [
                "element",
                "newLabel",
                "activeContextText",
                "bounds"
            ],
            "start_line": 354,
            "end_line": 378,
            "return": false
        },
        "function_12": {
            "signature": "// helpers //////////////////////",
            "content": "function isCollapsedSubProcess(element) {\n  return is(element, 'bpmn:SubProcess') && !isExpanded(element);\n}",
            "name": "isCollapsedSubProcess",
            "parameters": [
                "element"
            ],
            "start_line": 384,
            "end_line": 386,
            "return": true
        },
        "function_13": {
            "signature": "",
            "content": "function isExpandedSubProcess(element) {\n  return is(element, 'bpmn:SubProcess') && isExpanded(element);\n}",
            "name": "isExpandedSubProcess",
            "parameters": [
                "element"
            ],
            "start_line": 388,
            "end_line": 390,
            "return": true
        },
        "function_14": {
            "signature": "",
            "content": "function isCollapsedPool(element) {\n  return is(element, 'bpmn:Participant') && !isExpanded(element);\n}",
            "name": "isCollapsedPool",
            "parameters": [
                "element"
            ],
            "start_line": 392,
            "end_line": 394,
            "return": true
        },
        "function_15": {
            "signature": "",
            "content": "function isExpandedPool(element) {\n  return is(element, 'bpmn:Participant') && isExpanded(element);\n}",
            "name": "isExpandedPool",
            "parameters": [
                "element"
            ],
            "start_line": 396,
            "end_line": 398,
            "return": true
        },
        "function_16": {
            "signature": "",
            "content": "function isEmptyText(label) {\n  return !label || !label.trim();\n}",
            "name": "isEmptyText",
            "parameters": [
                "label"
            ],
            "start_line": 400,
            "end_line": 402,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\label-editing\\LabelUtil.js": {
        "function_1": {
            "signature": "",
            "content": "function getLabelAttr(semantic) {\n  if (\n    is(semantic, 'bpmn:FlowElement') ||\n    is(semantic, 'bpmn:Participant') ||\n    is(semantic, 'bpmn:Lane') ||\n    is(semantic, 'bpmn:SequenceFlow') ||\n    is(semantic, 'bpmn:MessageFlow') ||\n    is(semantic, 'bpmn:DataInput') ||\n    is(semantic, 'bpmn:DataOutput')\n  ) {\n    return 'name';\n  }\n\n  if (is(semantic, 'bpmn:TextAnnotation')) {\n    return 'text';\n  }\n}",
            "name": "getLabelAttr",
            "parameters": [
                "semantic"
            ],
            "start_line": 3,
            "end_line": 19,
            "return": true
        },
        "function_2": {
            "signature": "",
            "content": "export function getLabel(element) {\n  var semantic = element.businessObject,\n      attr = getLabelAttr(semantic);\n\n  if (attr) {\n    return semantic[attr] || '';\n  }\n}",
            "name": "getLabel",
            "parameters": [
                "element"
            ],
            "start_line": 21,
            "end_line": 28,
            "return": true
        },
        "function_3": {
            "signature": "",
            "content": "export function setLabel(element, text, isExternal) {\n  var semantic = element.businessObject,\n      attr = getLabelAttr(semantic);\n\n  if (attr) {\n    semantic[attr] = text;\n  }\n\n  return element;\n}",
            "name": "setLabel",
            "parameters": [
                "element",
                "text",
                "isExternal"
            ],
            "start_line": 31,
            "end_line": 40,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\label-editing\\cmd\\UpdateLabelHandler.js": {
        "function_1": {
            "signature": "/**\n* A handler that updates the text of a BPMN element.\n*/",
            "content": "export default function UpdateLabelHandler(modeling, textRenderer) {\n\n  /**\n   * Set the label and return the changed elements.\n   *\n   * Element parameter can be label itself or connection (i.e. sequence flow).\n   *\n   * @param {djs.model.Base} element\n   * @param {String} text\n   */\n  function setText(element, text) {\n\n    // external label if present\n    var label = element.label || element;\n\n    var labelTarget = element.labelTarget || element;\n\n    setLabel(label, text, labelTarget !== label);\n\n    return [ label, labelTarget ];\n  }\n\n  function preExecute(ctx) {\n    var element = ctx.element,\n        businessObject = element.businessObject,\n        newLabel = ctx.newLabel;\n\n    if (!isLabel(element)\n        && isLabelExternal(element)\n        && !hasExternalLabel(element)\n        && !isEmptyText(newLabel)) {\n\n      // create label\n      var paddingTop = 7;\n\n      var labelCenter = getExternalLabelMid(element);\n\n      labelCenter = {\n        x: labelCenter.x,\n        y: labelCenter.y + paddingTop\n      };\n\n      modeling.createLabel(element, labelCenter, {\n        id: businessObject.id + '_label',\n        businessObject: businessObject\n      });\n    }\n  }\n\n  function execute(ctx) {\n    ctx.oldLabel = getLabel(ctx.element);\n    return setText(ctx.element, ctx.newLabel);\n  }\n\n  function revert(ctx) {\n    return setText(ctx.element, ctx.oldLabel);\n  }\n\n  function postExecute(ctx) {\n    var element = ctx.element,\n        label = element.label || element,\n        newLabel = ctx.newLabel,\n        newBounds = ctx.newBounds,\n        hints = ctx.hints || {};\n\n    if (isLabel(label) && isEmptyText(newLabel)) {\n\n      if (hints.removeShape !== false) {\n        modeling.removeShape(label, { unsetLabel: false });\n      }\n\n      return;\n    }\n\n    // ignore internal labels for elements except text annotations\n    if (!isLabelExternal(element) && !is(element, 'bpmn:TextAnnotation')) {\n      return;\n    }\n\n    var bo = getBusinessObject(label);\n\n    var text = bo.name || bo.text;\n\n    // don't resize without text\n    if (!text) {\n      return;\n    }\n\n    // resize element based on label _or_ pre-defined bounds\n    if (typeof newBounds === 'undefined') {\n      newBounds = textRenderer.getExternalLabelBounds(label, text);\n    }\n\n    // setting newBounds to false or _null_ will\n    // disable the postExecute resize operation\n    if (newBounds) {\n      modeling.resizeShape(label, newBounds, NULL_DIMENSIONS);\n    }\n  }\n\n  // API\n\n  this.preExecute = preExecute;\n  this.execute = execute;\n  this.revert = revert;\n  this.postExecute = postExecute;\n}",
            "name": "UpdateLabelHandler",
            "parameters": [
                "modeling",
                "textRenderer"
            ],
            "start_line": 27,
            "end_line": 133,
            "return": true
        },
        "function_7": {
            "signature": "// helpers ///////////////////////",
            "content": "function isEmptyText(label) {\n  return !label || !label.trim();\n}",
            "name": "isEmptyText",
            "parameters": [
                "label"
            ],
            "start_line": 143,
            "end_line": 145,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\BpmnFactory.js": {
        "function_1": {
            "signature": "",
            "content": "export default function BpmnFactory(moddle) {\n  this._model = moddle;\n}",
            "name": "BpmnFactory",
            "parameters": [
                "moddle"
            ],
            "start_line": 12,
            "end_line": 14,
            "return": false
        },
        "function_2": {
            "signature": "",
            "content": "BpmnFactory.prototype._needsId = function(element) {\n  return isAny(element, [\n    'bpmn:RootElement',\n    'bpmn:FlowElement',\n    'bpmn:MessageFlow',\n    'bpmn:DataAssociation',\n    'bpmn:Artifact',\n    'bpmn:Participant',\n    'bpmn:Lane',\n    'bpmn:LaneSet',\n    'bpmn:Process',\n    'bpmn:Collaboration',\n    'bpmndi:BPMNShape',\n    'bpmndi:BPMNEdge',\n    'bpmndi:BPMNDiagram',\n    'bpmndi:BPMNPlane',\n    'bpmn:Property'\n  ]);\n};",
            "name": "function_2",
            "parameters": [
                "element"
            ],
            "start_line": 19,
            "end_line": 37,
            "return": true
        },
        "function_3": {
            "signature": "",
            "content": "BpmnFactory.prototype._ensureId = function(element) {\n\n  // generate semantic ids for elements\n  // bpmn:SequenceFlow -> SequenceFlow_ID\n  var prefix = (element.$type || '').replace(/^[^:]*:/g, '') + '_';\n\n  if (!element.id && this._needsId(element)) {\n    element.id = this._model.ids.nextPrefixed(prefix, element);\n  }\n};",
            "name": "function_3",
            "parameters": [
                "element"
            ],
            "start_line": 39,
            "end_line": 48,
            "return": false
        },
        "function_4": {
            "signature": "",
            "content": "BpmnFactory.prototype.create = function(type, attrs) {\n  var element = this._model.create(type, attrs || {});\n\n  this._ensureId(element);\n\n  return element;\n};",
            "name": "function_4",
            "parameters": [
                "type",
                "attrs"
            ],
            "start_line": 51,
            "end_line": 57,
            "return": true
        },
        "function_5": {
            "signature": "",
            "content": "BpmnFactory.prototype.createDiLabel = function() {\n  return this.create('bpmndi:BPMNLabel', {\n    bounds: this.createDiBounds()\n  });\n};",
            "name": "function_5",
            "parameters": [],
            "start_line": 60,
            "end_line": 64,
            "return": true
        },
        "function_6": {
            "signature": "",
            "content": "BpmnFactory.prototype.createDiShape = function(semantic, bounds, attrs) {\n\n  return this.create('bpmndi:BPMNShape', assign({\n    bpmnElement: semantic,\n    bounds: this.createDiBounds(bounds)\n  }, attrs));\n};",
            "name": "function_6",
            "parameters": [
                "semantic",
                "bounds",
                "attrs"
            ],
            "start_line": 67,
            "end_line": 73,
            "return": true
        },
        "function_7": {
            "signature": "",
            "content": "BpmnFactory.prototype.createDiBounds = function(bounds) {\n  return this.create('dc:Bounds', bounds);\n};",
            "name": "function_7",
            "parameters": [
                "bounds"
            ],
            "start_line": 76,
            "end_line": 78,
            "return": true
        },
        "function_8": {
            "signature": "",
            "content": "BpmnFactory.prototype.createDiWaypoints = function(waypoints) {\n  var self = this;\n\n  return map(waypoints, function(pos) {\n    return self.createDiWaypoint(pos);\n  });\n};",
            "name": "function_8",
            "parameters": [
                "waypoints"
            ],
            "start_line": 81,
            "end_line": 87,
            "return": true
        },
        "function_10": {
            "signature": "",
            "content": "BpmnFactory.prototype.createDiWaypoint = function(point) {\n  return this.create('dc:Point', pick(point, [ 'x', 'y' ]));\n};",
            "name": "function_10",
            "parameters": [
                "point"
            ],
            "start_line": 89,
            "end_line": 91,
            "return": true
        },
        "function_11": {
            "signature": "",
            "content": "BpmnFactory.prototype.createDiEdge = function(semantic, waypoints, attrs) {\n  return this.create('bpmndi:BPMNEdge', assign({\n    bpmnElement: semantic\n  }, attrs));\n};",
            "name": "function_11",
            "parameters": [
                "semantic",
                "waypoints",
                "attrs"
            ],
            "start_line": 94,
            "end_line": 98,
            "return": true
        },
        "function_12": {
            "signature": "",
            "content": "BpmnFactory.prototype.createDiPlane = function(semantic) {\n  return this.create('bpmndi:BPMNPlane', {\n    bpmnElement: semantic\n  });\n};",
            "name": "function_12",
            "parameters": [
                "semantic"
            ],
            "start_line": 100,
            "end_line": 104,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\BpmnLayouter.js": {
        "function_1": {
            "signature": "",
            "content": "export default function BpmnLayouter() {}",
            "name": "BpmnLayouter",
            "parameters": [],
            "start_line": 26,
            "end_line": 26,
            "return": false
        },
        "function_2": {
            "signature": "",
            "content": "BpmnLayouter.prototype.layoutConnection = function(connection, hints) {\n  hints = hints || {};\n\n  var source = connection.source,\n      target = connection.target,\n      waypoints = connection.waypoints,\n      start = hints.connectionStart,\n      end = hints.connectionEnd;\n\n  var manhattanOptions,\n      updatedWaypoints;\n\n  if (!start) {\n    start = getConnectionDocking(waypoints && waypoints[0], source);\n  }\n\n  if (!end) {\n    end = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);\n  }\n\n  // TODO(nikku): support vertical modeling\n  // and invert preferredLayouts accordingly\n\n  if (is(connection, 'bpmn:Association') ||\n      is(connection, 'bpmn:DataAssociation')) {\n\n    if (waypoints && !isCompensationAssociation(connection)) {\n      return [].concat([ start ], waypoints.slice(1, -1), [ end ]);\n    }\n  }\n\n  // manhattan layout sequence / message flows\n  if (is(connection, 'bpmn:MessageFlow')) {\n    manhattanOptions = getMessageFlowManhattanOptions(source, target);\n\n  } else\n\n\n  // layout all connection between flow elements h:h,\n  //\n  // except for\n  //\n  // (1) outgoing of BoundaryEvents -> layout based on attach orientation and target orientation\n  // (2) incoming / outgoing of Gateway -> v:h (outgoing), h:v (incoming)\n  // (3) loops from / to the same element\n  //\n  if (is(connection, 'bpmn:SequenceFlow') ||\n      isCompensationAssociation(connection)) {\n\n    if (source === target) {\n      manhattanOptions = {\n        preferredLayouts: [ 'b:l' ]\n      };\n    } else\n\n    if (is(source, 'bpmn:BoundaryEvent')) {\n\n      manhattanOptions = {\n        preferredLayouts: getBoundaryEventPreferredLayouts(source, target)\n      };\n\n    } else\n\n    if (is(source, 'bpmn:Gateway')) {\n\n      manhattanOptions = {\n        preferredLayouts: [ 'v:h' ]\n      };\n    } else\n\n    if (is(target, 'bpmn:Gateway')) {\n\n      manhattanOptions = {\n        preferredLayouts: [ 'h:v' ]\n      };\n    }\n\n    else {\n      manhattanOptions = {\n        preferredLayouts: [ 'h:h' ]\n      };\n    }\n\n  }\n\n  if (manhattanOptions) {\n\n    manhattanOptions = assign(manhattanOptions, hints);\n\n    updatedWaypoints =\n      withoutRedundantPoints(\n        repairConnection(\n          source, target,\n          start, end,\n          waypoints,\n          manhattanOptions\n        )\n      );\n  }\n\n  return updatedWaypoints || [ start, end ];\n};",
            "name": "function_2",
            "parameters": [
                "connection",
                "hints"
            ],
            "start_line": 31,
            "end_line": 132,
            "return": true
        },
        "function_3": {
            "signature": "",
            "content": "function getAttachOrientation(attachedElement) {\n\n  var hostElement = attachedElement.host,\n      padding = -10;\n\n  return getOrientation(getMid(attachedElement), hostElement, padding);\n}",
            "name": "getAttachOrientation",
            "parameters": [
                "attachedElement"
            ],
            "start_line": 135,
            "end_line": 141,
            "return": true
        },
        "function_4": {
            "signature": "",
            "content": "function getMessageFlowManhattanOptions(source, target) {\n  return {\n    preferredLayouts: [ 'straight', 'v:v' ],\n    preserveDocking: getMessageFlowPreserveDocking(source, target)\n  };\n}",
            "name": "getMessageFlowManhattanOptions",
            "parameters": [
                "source",
                "target"
            ],
            "start_line": 144,
            "end_line": 149,
            "return": true
        },
        "function_5": {
            "signature": "",
            "content": "function getMessageFlowPreserveDocking(source, target) {\n\n  // (1) docking element connected to participant has precedence\n\n  if (is(target, 'bpmn:Participant')) {\n    return 'source';\n  }\n\n  if (is(source, 'bpmn:Participant')) {\n    return 'target';\n  }\n\n  // (2) docking element connected to expanded sub-process has precedence\n\n  if (isExpandedSubProcess(target)) {\n    return 'source';\n  }\n\n  if (isExpandedSubProcess(source)) {\n    return 'target';\n  }\n\n  // (3) docking event has precedence\n\n  if (is(target, 'bpmn:Event')) {\n    return 'target';\n  }\n\n  if (is(source, 'bpmn:Event')) {\n    return 'source';\n  }\n\n  return null;\n}",
            "name": "getMessageFlowPreserveDocking",
            "parameters": [
                "source",
                "target"
            ],
            "start_line": 152,
            "end_line": 185,
            "return": true
        },
        "function_6": {
            "signature": "",
            "content": "function getConnectionDocking(point, shape) {\n  return point ? (point.original || point) : getMid(shape);\n}",
            "name": "getConnectionDocking",
            "parameters": [
                "point",
                "shape"
            ],
            "start_line": 188,
            "end_line": 190,
            "return": true
        },
        "function_7": {
            "signature": "",
            "content": "function isCompensationAssociation(connection) {\n\n  var source = connection.source,\n      target = connection.target;\n\n  return is(target, 'bpmn:Activity') &&\n         is(source, 'bpmn:BoundaryEvent') &&\n         target.businessObject.isForCompensation;\n}",
            "name": "isCompensationAssociation",
            "parameters": [
                "connection"
            ],
            "start_line": 192,
            "end_line": 200,
            "return": true
        },
        "function_8": {
            "signature": "",
            "content": "function isExpandedSubProcess(element) {\n  return is(element, 'bpmn:SubProcess') && isExpanded(element);\n}",
            "name": "isExpandedSubProcess",
            "parameters": [
                "element"
            ],
            "start_line": 203,
            "end_line": 205,
            "return": true
        },
        "function_9": {
            "signature": "",
            "content": "function isSame(a, b) {\n  return a === b;\n}",
            "name": "isSame",
            "parameters": [
                "a",
                "b"
            ],
            "start_line": 207,
            "end_line": 209,
            "return": true
        },
        "function_10": {
            "signature": "",
            "content": "function isAnyOrientation(orientation, orientations) {\n  return orientations.indexOf(orientation) !== -1;\n}",
            "name": "isAnyOrientation",
            "parameters": [
                "orientation",
                "orientations"
            ],
            "start_line": 211,
            "end_line": 213,
            "return": true
        },
        "function_11": {
            "signature": "",
            "content": "function getHorizontalOrientation(orientation) {\n  var matches = /right|left/.exec(orientation);\n\n  return matches && matches[0];\n}",
            "name": "getHorizontalOrientation",
            "parameters": [
                "orientation"
            ],
            "start_line": 233,
            "end_line": 237,
            "return": true
        },
        "function_12": {
            "signature": "",
            "content": "function getVerticalOrientation(orientation) {\n  var matches = /top|bottom/.exec(orientation);\n\n  return matches && matches[0];\n}",
            "name": "getVerticalOrientation",
            "parameters": [
                "orientation"
            ],
            "start_line": 239,
            "end_line": 243,
            "return": true
        },
        "function_13": {
            "signature": "",
            "content": "function isOppositeOrientation(a, b) {\n  return oppositeOrientationMapping[a] === b;\n}",
            "name": "isOppositeOrientation",
            "parameters": [
                "a",
                "b"
            ],
            "start_line": 245,
            "end_line": 247,
            "return": true
        },
        "function_14": {
            "signature": "",
            "content": "function isOppositeHorizontalOrientation(a, b) {\n  var horizontalOrientation = getHorizontalOrientation(a);\n\n  var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];\n\n  return b.indexOf(oppositeHorizontalOrientation) !== -1;\n}",
            "name": "isOppositeHorizontalOrientation",
            "parameters": [
                "a",
                "b"
            ],
            "start_line": 249,
            "end_line": 255,
            "return": true
        },
        "function_15": {
            "signature": "",
            "content": "function isOppositeVerticalOrientation(a, b) {\n  var verticalOrientation = getVerticalOrientation(a);\n\n  var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];\n\n  return b.indexOf(oppositeVerticalOrientation) !== -1;\n}",
            "name": "isOppositeVerticalOrientation",
            "parameters": [
                "a",
                "b"
            ],
            "start_line": 257,
            "end_line": 263,
            "return": true
        },
        "function_16": {
            "signature": "",
            "content": "function isHorizontalOrientation(orientation) {\n  return orientation === 'right' || orientation === 'left';\n}",
            "name": "isHorizontalOrientation",
            "parameters": [
                "orientation"
            ],
            "start_line": 265,
            "end_line": 267,
            "return": true
        },
        "function_17": {
            "signature": "",
            "content": "function getBoundaryEventPreferredLayouts(source, target) {\n  var sourceMid = getMid(source),\n      targetMid = getMid(target),\n      attachOrientation = getAttachOrientation(source),\n      sourceLayout,\n      targetLayout;\n\n  var isLoop = isSame(source.host, target);\n\n  var attachedToSide = isAnyOrientation(attachOrientation, [ 'top', 'right', 'bottom', 'left' ]);\n\n  var targetOrientation = getOrientation(targetMid, sourceMid, {\n    x: source.width / 2 + target.width / 2,\n    y: source.height / 2 + target.height / 2\n  });\n\n  // source layout\n  sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide, isLoop);\n\n  // target layout\n  targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide, isLoop);\n\n  return [ sourceLayout + ':' + targetLayout ];\n}",
            "name": "getBoundaryEventPreferredLayouts",
            "parameters": [
                "source",
                "target"
            ],
            "start_line": 269,
            "end_line": 292,
            "return": true
        },
        "function_18": {
            "signature": "",
            "content": "function getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide, isLoop) {\n\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    return orientationDirectionMapping[attachOrientation];\n  }\n\n  // attached to either top-right, top-left, bottom-right or bottom-left corner\n\n  // loop, same vertical or opposite horizontal orientation\n  if (isLoop ||\n    isSame(\n      getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)\n    ) ||\n    isOppositeOrientation(\n      getHorizontalOrientation(attachOrientation), getHorizontalOrientation(targetOrientation)\n    )) {\n    return orientationDirectionMapping[getVerticalOrientation(attachOrientation)];\n  }\n\n  // fallback\n  return orientationDirectionMapping[getHorizontalOrientation(attachOrientation)];\n}",
            "name": "getBoundaryEventSourceLayout",
            "parameters": [
                "attachOrientation",
                "targetOrientation",
                "attachedToSide",
                "isLoop"
            ],
            "start_line": 294,
            "end_line": 316,
            "return": true
        },
        "function_19": {
            "signature": "",
            "content": "function getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide, isLoop) {\n\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n      // orientation is 'right' or 'left'\n\n      // loop or opposite horizontal orientation or same orientation\n      if (\n        isLoop ||\n        isOppositeHorizontalOrientation(attachOrientation, targetOrientation) ||\n        isSame(attachOrientation, targetOrientation)\n      ) {\n        return 'h';\n      }\n\n      // fallback\n      return 'v';\n    } else {\n      // orientation is 'top' or 'bottom'\n\n      // loop or opposite vertical orientation or same orientation\n      if (\n        isLoop ||\n        isOppositeVerticalOrientation(attachOrientation, targetOrientation) ||\n        isSame(attachOrientation, targetOrientation)\n      ) {\n        return 'v';\n      }\n\n      // fallback\n      return 'h';\n    }\n  }\n  // attached to either top-right, top-left, bottom-right or bottom-left corner\n\n  // orientation is 'right', 'left'\n  // or same vertical orientation but also 'right' or 'left'\n  if (isHorizontalOrientation(targetOrientation) ||\n    (isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) &&\n      getHorizontalOrientation(targetOrientation))) {\n    return 'h';\n  } else {\n    return 'v';\n  }\n}",
            "name": "getBoundaryEventTargetLayout",
            "parameters": [
                "attachOrientation",
                "targetOrientation",
                "attachedToSide",
                "isLoop"
            ],
            "start_line": 318,
            "end_line": 363,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\BpmnUpdater.js": {
        "function_1": {
            "signature": "/**\n* A handler responsible for updating the underlying BPMN 2.0 XML + DI\n* once changes on the diagram happen\n*/",
            "content": "export default function BpmnUpdater(\n    eventBus, bpmnFactory, connectionDocking,\n    translate) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this._bpmnFactory = bpmnFactory;\n  this._translate = translate;\n\n  var self = this;\n\n\n\n  // connection cropping //////////////////////\n\n  // crop connection ends during create/update\n  function cropConnection(e) {\n    var context = e.context,\n        connection;\n\n    if (!context.cropped) {\n      connection = context.connection;\n      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);\n      context.cropped = true;\n    }\n  }\n\n  this.executed([\n    'connection.layout',\n    'connection.create'\n  ], cropConnection);\n\n  this.reverted([ 'connection.layout' ], function(e) {\n    delete e.context.cropped;\n  });\n\n\n\n  // BPMN + DI update //////////////////////\n\n\n  // update parent\n  function updateParent(e) {\n    var context = e.context;\n\n    self.updateParent(context.shape || context.connection, context.oldParent);\n  }\n\n  function reverseUpdateParent(e) {\n    var context = e.context;\n\n    var element = context.shape || context.connection,\n        // oldParent is the (old) new parent, because we are undoing\n        oldParent = context.parent || context.newParent;\n\n    self.updateParent(element, oldParent);\n  }\n\n  this.executed([\n    'shape.move',\n    'shape.create',\n    'shape.delete',\n    'connection.create',\n    'connection.move',\n    'connection.delete'\n  ], ifBpmn(updateParent));\n\n  this.reverted([\n    'shape.move',\n    'shape.create',\n    'shape.delete',\n    'connection.create',\n    'connection.move',\n    'connection.delete'\n  ], ifBpmn(reverseUpdateParent));\n\n  /*\n   * ## Updating Parent\n   *\n   * When morphing a Process into a Collaboration or vice-versa,\n   * make sure that both the *semantic* and *di* parent of each element\n   * is updated.\n   *\n   */\n  function updateRoot(event) {\n    var context = event.context,\n        oldRoot = context.oldRoot,\n        children = oldRoot.children;\n\n    forEach(children, function(child) {\n      if (is(child, 'bpmn:BaseElement')) {\n        self.updateParent(child);\n      }\n    });\n  }\n\n  this.executed([ 'canvas.updateRoot' ], updateRoot);\n  this.reverted([ 'canvas.updateRoot' ], updateRoot);\n\n\n  // update bounds\n  function updateBounds(e) {\n    var shape = e.context.shape;\n\n    if (!is(shape, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    self.updateBounds(shape);\n  }\n\n  this.executed([ 'shape.move', 'shape.create', 'shape.resize' ], ifBpmn(function(event) {\n\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n\n  this.reverted([ 'shape.move', 'shape.create', 'shape.resize' ], ifBpmn(function(event) {\n\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n\n  // Handle labels separately. This is necessary, because the label bounds have to be updated\n  // every time its shape changes, not only on move, create and resize.\n  eventBus.on('shape.changed', function(event) {\n    if (event.element.type === 'label') {\n      updateBounds({ context: { shape: event.element } });\n    }\n  });\n\n  // attach / detach connection\n  function updateConnection(e) {\n    self.updateConnection(e.context);\n  }\n\n  this.executed([\n    'connection.create',\n    'connection.move',\n    'connection.delete',\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(updateConnection));\n\n  this.reverted([\n    'connection.create',\n    'connection.move',\n    'connection.delete',\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(updateConnection));\n\n\n  // update waypoints\n  function updateConnectionWaypoints(e) {\n    self.updateConnectionWaypoints(e.context.connection);\n  }\n\n  this.executed([\n    'connection.layout',\n    'connection.move',\n    'connection.updateWaypoints',\n  ], ifBpmn(updateConnectionWaypoints));\n\n  this.reverted([\n    'connection.layout',\n    'connection.move',\n    'connection.updateWaypoints',\n  ], ifBpmn(updateConnectionWaypoints));\n\n\n  // update Default & Conditional flows\n  this.executed([\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(function(e) {\n    var context = e.context,\n        connection = context.connection,\n        businessObject = getBusinessObject(connection),\n        oldSource = getBusinessObject(context.oldSource),\n        oldTarget = getBusinessObject(context.oldTarget),\n        newSource = getBusinessObject(connection.source),\n        newTarget = getBusinessObject(connection.target);\n\n    if (oldSource === newSource || oldTarget === newTarget) {\n      return;\n    }\n\n    // on reconnectStart -> default flow\n    if (oldSource && oldSource.default === businessObject) {\n      context.default = oldSource.default;\n      oldSource.default = undefined;\n    }\n\n    // on reconnectEnd -> default flow\n    if ((businessObject.sourceRef && businessObject.sourceRef.default) &&\n        !(is(newTarget, 'bpmn:Activity') ||\n          is(newTarget, 'bpmn:EndEvent') ||\n          is(newTarget, 'bpmn:Gateway') ||\n          is(newTarget, 'bpmn:IntermediateThrowEvent'))) {\n      context.default = businessObject.sourceRef.default;\n      businessObject.sourceRef.default = undefined;\n    }\n\n    // on reconnectStart -> conditional flow\n    if (oldSource && (businessObject.conditionExpression) &&\n      !(is(newSource, 'bpmn:Activity') ||\n        is(newSource, 'bpmn:Gateway'))) {\n      context.conditionExpression = businessObject.conditionExpression;\n      businessObject.conditionExpression = undefined;\n    }\n\n    // on reconnectEnd -> conditional flow\n    if (oldTarget && (businessObject.conditionExpression) &&\n        !(is(newTarget, 'bpmn:Activity') ||\n          is(newTarget, 'bpmn:EndEvent') ||\n          is(newTarget, 'bpmn:Gateway') ||\n          is(newTarget, 'bpmn:IntermediateThrowEvent'))) {\n      context.conditionExpression = businessObject.conditionExpression;\n      businessObject.conditionExpression = undefined;\n    }\n  }));\n\n  this.reverted([\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(function(e) {\n    var context = e.context,\n        connection = context.connection,\n        businessObject = getBusinessObject(connection),\n        newSource = getBusinessObject(connection.source);\n\n    // default flow\n    if (context.default) {\n      if (is(newSource, 'bpmn:ExclusiveGateway') || is(newSource, 'bpmn:InclusiveGateway') ||\n          is(newSource, 'bpmn:Activity')) {\n        newSource.default = context.default;\n      }\n    }\n\n    // conditional flow\n    if (context.conditionExpression && is(newSource, 'bpmn:Activity')) {\n      businessObject.conditionExpression = context.conditionExpression;\n    }\n  }));\n\n  // update attachments\n  function updateAttachment(e) {\n    self.updateAttachment(e.context);\n  }\n\n  this.executed([ 'element.updateAttachment' ], ifBpmn(updateAttachment));\n  this.reverted([ 'element.updateAttachment' ], ifBpmn(updateAttachment));\n}",
            "name": "BpmnUpdater",
            "parameters": [
                "eventBus",
                "bpmnFactory",
                "connectionDocking",
                "translate"
            ],
            "start_line": 28,
            "end_line": 289,
            "return": true
        },
        "function_17": {
            "signature": "// implementation //////////////////////",
            "content": "BpmnUpdater.prototype.updateAttachment = function(context) {\n\n  var shape = context.shape,\n      businessObject = shape.businessObject,\n      host = shape.host;\n\n  businessObject.attachedToRef = host && host.businessObject;\n};",
            "name": "function_17",
            "parameters": [
                "context"
            ],
            "start_line": 303,
            "end_line": 310,
            "return": false
        },
        "function_18": {
            "signature": "",
            "content": "BpmnUpdater.prototype.updateParent = function(element, oldParent) {\n  // do not update BPMN 2.0 label parent\n  if (element instanceof Label) {\n    return;\n  }\n\n  // data stores in collaborations are handled seperately by DataStoreBehavior\n  if (is(element, 'bpmn:DataStoreReference') &&\n      element.parent &&\n      is(element.parent, 'bpmn:Collaboration')) {\n    return;\n  }\n\n  var parentShape = element.parent;\n\n  var businessObject = element.businessObject,\n      parentBusinessObject = parentShape && parentShape.businessObject,\n      parentDi = parentBusinessObject && parentBusinessObject.di;\n\n  if (is(element, 'bpmn:FlowNode')) {\n    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);\n  }\n\n  if (is(element, 'bpmn:DataOutputAssociation')) {\n    if (element.source) {\n      parentBusinessObject = element.source.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  if (is(element, 'bpmn:DataInputAssociation')) {\n    if (element.target) {\n      parentBusinessObject = element.target.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  this.updateSemanticParent(businessObject, parentBusinessObject);\n\n  if (is(element, 'bpmn:DataObjectReference') && businessObject.dataObjectRef) {\n    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);\n  }\n\n  this.updateDiParent(businessObject.di, parentDi);\n};",
            "name": "function_18",
            "parameters": [
                "element",
                "oldParent"
            ],
            "start_line": 312,
            "end_line": 358,
            "return": true
        },
        "function_19": {
            "signature": "",
            "content": "BpmnUpdater.prototype.updateBounds = function(shape) {\n\n  var di = shape.businessObject.di;\n\n  var target = (shape instanceof Label) ? this._getLabel(di) : di;\n\n  var bounds = target.bounds;\n\n  if (!bounds) {\n    bounds = this._bpmnFactory.createDiBounds();\n    target.set('bounds', bounds);\n  }\n\n  assign(bounds, {\n    x: shape.x,\n    y: shape.y,\n    width: shape.width,\n    height: shape.height\n  });\n};",
            "name": "function_19",
            "parameters": [
                "shape"
            ],
            "start_line": 361,
            "end_line": 380,
            "return": false
        },
        "function_20": {
            "signature": "",
            "content": "BpmnUpdater.prototype.updateFlowNodeRefs = function(businessObject, newContainment, oldContainment) {\n\n  if (oldContainment === newContainment) {\n    return;\n  }\n\n  var oldRefs, newRefs;\n\n  if (is (oldContainment, 'bpmn:Lane')) {\n    oldRefs = oldContainment.get('flowNodeRef');\n    collectionRemove(oldRefs, businessObject);\n  }\n\n  if (is(newContainment, 'bpmn:Lane')) {\n    newRefs = newContainment.get('flowNodeRef');\n    collectionAdd(newRefs, businessObject);\n  }\n};",
            "name": "function_20",
            "parameters": [
                "businessObject",
                "newContainment",
                "oldContainment"
            ],
            "start_line": 382,
            "end_line": 399,
            "return": true
        },
        "function_21": {
            "signature": "// update existing sourceElement and targetElement di information",
            "content": "BpmnUpdater.prototype.updateDiConnection = function(di, newSource, newTarget) {\n\n  if (di.sourceElement && di.sourceElement.bpmnElement !== newSource) {\n    di.sourceElement = newSource && newSource.di;\n  }\n\n  if (di.targetElement && di.targetElement.bpmnElement !== newTarget) {\n    di.targetElement = newTarget && newTarget.di;\n  }\n\n};",
            "name": "function_21",
            "parameters": [
                "di",
                "newSource",
                "newTarget"
            ],
            "start_line": 403,
            "end_line": 413,
            "return": false
        },
        "function_22": {
            "signature": "",
            "content": "BpmnUpdater.prototype.updateDiParent = function(di, parentDi) {\n\n  if (parentDi && !is(parentDi, 'bpmndi:BPMNPlane')) {\n    parentDi = parentDi.$parent;\n  }\n\n  if (di.$parent === parentDi) {\n    return;\n  }\n\n  var planeElements = (parentDi || di.$parent).get('planeElement');\n\n  if (parentDi) {\n    planeElements.push(di);\n    di.$parent = parentDi;\n  } else {\n    collectionRemove(planeElements, di);\n    di.$parent = null;\n  }\n};",
            "name": "function_22",
            "parameters": [
                "di",
                "parentDi"
            ],
            "start_line": 416,
            "end_line": 435,
            "return": true
        },
        "function_23": {
            "signature": "",
            "content": "function getDefinitions(element) {\n  while (element && !is(element, 'bpmn:Definitions')) {\n    element = element.$parent;\n  }\n\n  return element;\n}",
            "name": "getDefinitions",
            "parameters": [
                "element"
            ],
            "start_line": 437,
            "end_line": 443,
            "return": true
        },
        "function_24": {
            "signature": "",
            "content": "BpmnUpdater.prototype.getLaneSet = function(container) {\n\n  var laneSet, laneSets;\n\n  // bpmn:Lane\n  if (is(container, 'bpmn:Lane')) {\n    laneSet = container.childLaneSet;\n\n    if (!laneSet) {\n      laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n      container.childLaneSet = laneSet;\n      laneSet.$parent = container;\n    }\n\n    return laneSet;\n  }\n\n  // bpmn:Participant\n  if (is(container, 'bpmn:Participant')) {\n    container = container.processRef;\n  }\n\n  // bpmn:FlowElementsContainer\n  laneSets = container.get('laneSets');\n  laneSet = laneSets[0];\n\n  if (!laneSet) {\n    laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n    laneSet.$parent = container;\n    laneSets.push(laneSet);\n  }\n\n  return laneSet;\n};",
            "name": "function_24",
            "parameters": [
                "container"
            ],
            "start_line": 445,
            "end_line": 478,
            "return": true
        },
        "function_25": {
            "signature": "",
            "content": "BpmnUpdater.prototype.updateSemanticParent = function(businessObject, newParent, visualParent) {\n\n  var containment,\n      translate = this._translate;\n\n  if (businessObject.$parent === newParent) {\n    return;\n  }\n\n  if (is(businessObject, 'bpmn:DataInput') || is(businessObject, 'bpmn:DataOutput')) {\n\n    if (is(newParent, 'bpmn:Participant') && 'processRef' in newParent) {\n      newParent = newParent.processRef;\n    }\n\n    // already in correct ioSpecification\n    if ('ioSpecification' in newParent && newParent.ioSpecification === businessObject.$parent) {\n      return;\n    }\n  }\n\n  if (is(businessObject, 'bpmn:Lane')) {\n\n    if (newParent) {\n      newParent = this.getLaneSet(newParent);\n    }\n\n    containment = 'lanes';\n  } else\n\n  if (is(businessObject, 'bpmn:FlowElement')) {\n\n    if (newParent) {\n\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n      } else\n\n      if (is(newParent, 'bpmn:Lane')) {\n        do {\n          // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)\n          newParent = newParent.$parent.$parent;\n        } while (is(newParent, 'bpmn:Lane'));\n\n      }\n    }\n\n    containment = 'flowElements';\n\n  } else\n\n  if (is(businessObject, 'bpmn:Artifact')) {\n\n    while (newParent &&\n           !is(newParent, 'bpmn:Process') &&\n           !is(newParent, 'bpmn:SubProcess') &&\n           !is(newParent, 'bpmn:Collaboration')) {\n\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n        break;\n      } else {\n        newParent = newParent.$parent;\n      }\n    }\n\n    containment = 'artifacts';\n  } else\n\n  if (is(businessObject, 'bpmn:MessageFlow')) {\n    containment = 'messageFlows';\n\n  } else\n\n  if (is(businessObject, 'bpmn:Participant')) {\n    containment = 'participants';\n\n    // make sure the participants process is properly attached / detached\n    // from the XML document\n\n    var process = businessObject.processRef,\n        definitions;\n\n    if (process) {\n      definitions = getDefinitions(businessObject.$parent || newParent);\n\n      if (businessObject.$parent) {\n        collectionRemove(definitions.get('rootElements'), process);\n        process.$parent = null;\n      }\n\n      if (newParent) {\n        collectionAdd(definitions.get('rootElements'), process);\n        process.$parent = definitions;\n      }\n    }\n  } else\n\n  if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    containment = 'dataOutputAssociations';\n  } else\n\n  if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    containment = 'dataInputAssociations';\n  }\n\n  if (!containment) {\n    throw new Error(translate(\n      'no parent for {element} in {parent}',\n      {\n        element: businessObject.id,\n        parent: newParent.id\n      }\n    ));\n  }\n\n  var children;\n\n  if (businessObject.$parent) {\n    // remove from old parent\n    children = businessObject.$parent.get(containment);\n    collectionRemove(children, businessObject);\n  }\n\n  if (!newParent) {\n    businessObject.$parent = null;\n  } else {\n    // add to new parent\n    children = newParent.get(containment);\n    children.push(businessObject);\n    businessObject.$parent = newParent;\n  }\n\n  if (visualParent) {\n    var diChildren = visualParent.get(containment);\n\n    collectionRemove(children, businessObject);\n\n    if (newParent) {\n\n      if (!diChildren) {\n        diChildren = [];\n        newParent.set(containment, diChildren);\n      }\n\n      diChildren.push(businessObject);\n    }\n  }\n};",
            "name": "function_25",
            "parameters": [
                "businessObject",
                "newParent",
                "visualParent"
            ],
            "start_line": 480,
            "end_line": 628,
            "return": true
        },
        "function_26": {
            "signature": "",
            "content": "BpmnUpdater.prototype.updateConnectionWaypoints = function(connection) {\n  connection.businessObject.di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));\n};",
            "name": "function_26",
            "parameters": [
                "connection"
            ],
            "start_line": 631,
            "end_line": 633,
            "return": false
        },
        "function_27": {
            "signature": "",
            "content": "BpmnUpdater.prototype.updateConnection = function(context) {\n\n  var connection = context.connection,\n      businessObject = getBusinessObject(connection),\n      newSource = getBusinessObject(connection.source),\n      newTarget = getBusinessObject(connection.target),\n      visualParent;\n\n  if (!is(businessObject, 'bpmn:DataAssociation')) {\n\n    var inverseSet = is(businessObject, 'bpmn:SequenceFlow');\n\n    if (businessObject.sourceRef !== newSource) {\n      if (inverseSet) {\n        collectionRemove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);\n\n        if (newSource && newSource.get('outgoing')) {\n          newSource.get('outgoing').push(businessObject);\n        }\n      }\n\n      businessObject.sourceRef = newSource;\n    }\n\n    if (businessObject.targetRef !== newTarget) {\n      if (inverseSet) {\n        collectionRemove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);\n\n        if (newTarget && newTarget.get('incoming')) {\n          newTarget.get('incoming').push(businessObject);\n        }\n      }\n\n      businessObject.targetRef = newTarget;\n    }\n  } else\n\n  if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    // handle obnoxious isMsome sourceRef\n    businessObject.get('sourceRef')[0] = newSource;\n\n    visualParent = context.parent || context.newParent || newTarget;\n\n    this.updateSemanticParent(businessObject, newTarget, parent.businessObject);\n  } else\n\n  if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    visualParent = context.parent || context.newParent || newSource;\n\n    this.updateSemanticParent(businessObject, newSource, visualParent);\n\n    // targetRef = new target\n    businessObject.targetRef = newTarget;\n  }\n\n  this.updateConnectionWaypoints(connection);\n\n  this.updateDiConnection(businessObject.di, newSource, newTarget);\n};",
            "name": "function_27",
            "parameters": [
                "context"
            ],
            "start_line": 636,
            "end_line": 694,
            "return": false
        },
        "function_28": {
            "signature": "// helpers //////////////////////",
            "content": "BpmnUpdater.prototype._getLabel = function(di) {\n  if (!di.label) {\n    di.label = this._bpmnFactory.createDiLabel();\n  }\n\n  return di.label;\n};",
            "name": "function_28",
            "parameters": [
                "di"
            ],
            "start_line": 699,
            "end_line": 705,
            "return": true
        },
        "function_29": {
            "signature": "/**\n* Make sure the event listener is only called\n* if the touched element is a BPMN element.\n*\n* @param  {Function} fn\n* @return {Function} guarded function\n*/",
            "content": "function ifBpmn(fn) {\n\n  return function(event) {\n\n    var context = event.context,\n        element = context.shape || context.connection;\n\n    if (is(element, 'bpmn:BaseElement')) {\n      fn(event);\n    }\n  };\n}",
            "name": "ifBpmn",
            "parameters": [
                "fn"
            ],
            "start_line": 715,
            "end_line": 726,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\ElementFactory.js": {
        "function_1": {
            "signature": "/**\n* A bpmn-aware factory for diagram-js shapes\n*/",
            "content": "export default function ElementFactory(bpmnFactory, moddle, translate) {\n  BaseElementFactory.call(this);\n\n  this._bpmnFactory = bpmnFactory;\n  this._moddle = moddle;\n  this._translate = translate;\n}",
            "name": "ElementFactory",
            "parameters": [
                "bpmnFactory",
                "moddle",
                "translate"
            ],
            "start_line": 24,
            "end_line": 30,
            "return": false
        },
        "function_2": {
            "signature": "",
            "content": "ElementFactory.prototype.create = function(elementType, attrs) {\n  // no special magic for labels,\n  // we assume their businessObjects have already been created\n  // and wired via attrs\n  if (elementType === 'label') {\n    return this.baseCreate(elementType, assign({ type: 'label' }, DEFAULT_LABEL_SIZE, attrs));\n  }\n\n  return this.createBpmnElement(elementType, attrs);\n};",
            "name": "function_2",
            "parameters": [
                "elementType",
                "attrs"
            ],
            "start_line": 42,
            "end_line": 51,
            "return": true
        },
        "function_3": {
            "signature": "",
            "content": "ElementFactory.prototype.createBpmnElement = function(elementType, attrs) {\n  var size,\n      translate = this._translate;\n\n  attrs = attrs || {};\n\n  var businessObject = attrs.businessObject;\n\n  if (!businessObject) {\n    if (!attrs.type) {\n      throw new Error(translate('no shape type specified'));\n    }\n\n    businessObject = this._bpmnFactory.create(attrs.type);\n  }\n\n  if (!businessObject.di) {\n    if (elementType === 'root') {\n      businessObject.di = this._bpmnFactory.createDiPlane(businessObject, [], {\n        id: businessObject.id + '_di'\n      });\n    } else\n    if (elementType === 'connection') {\n      businessObject.di = this._bpmnFactory.createDiEdge(businessObject, [], {\n        id: businessObject.id + '_di'\n      });\n    } else {\n      businessObject.di = this._bpmnFactory.createDiShape(businessObject, {}, {\n        id: businessObject.id + '_di'\n      });\n    }\n  }\n\n  if (attrs.colors) {\n    assign(businessObject.di, attrs.colors);\n\n    delete attrs.colors;\n  }\n\n  applyAttributes(businessObject, attrs, [\n    'processRef',\n    'isInterrupting',\n    'associationDirection',\n    'isForCompensation'\n  ]);\n\n  if (attrs.isExpanded) {\n    applyAttribute(businessObject.di, attrs, 'isExpanded');\n  }\n\n  if (is(businessObject, 'bpmn:ExclusiveGateway')) {\n    businessObject.di.isMarkerVisible = true;\n  }\n\n  var eventDefinitions,\n      newEventDefinition;\n\n  if (attrs.eventDefinitionType) {\n    eventDefinitions = businessObject.get('eventDefinitions') || [];\n    newEventDefinition = this._moddle.create(attrs.eventDefinitionType);\n\n    if (attrs.eventDefinitionType === 'bpmn:ConditionalEventDefinition') {\n      newEventDefinition.condition = this._moddle.create('bpmn:FormalExpression');\n    }\n\n    eventDefinitions.push(newEventDefinition);\n\n    newEventDefinition.$parent = businessObject;\n    businessObject.eventDefinitions = eventDefinitions;\n\n    delete attrs.eventDefinitionType;\n  }\n\n  size = this._getDefaultSize(businessObject);\n\n  attrs = assign({\n    businessObject: businessObject,\n    id: businessObject.id\n  }, size, attrs);\n\n  return this.baseCreate(elementType, attrs);\n};",
            "name": "function_3",
            "parameters": [
                "elementType",
                "attrs"
            ],
            "start_line": 53,
            "end_line": 134,
            "return": true
        },
        "function_4": {
            "signature": "",
            "content": "ElementFactory.prototype._getDefaultSize = function(semantic) {\n\n  if (is(semantic, 'bpmn:SubProcess')) {\n\n    if (isExpanded(semantic)) {\n      return { width: 350, height: 200 };\n    } else {\n      return { width: 100, height: 80 };\n    }\n  }\n\n  if (is(semantic, 'bpmn:Task')) {\n    return { width: 100, height: 80 };\n  }\n\n  if (is(semantic, 'bpmn:Gateway')) {\n    return { width: 50, height: 50 };\n  }\n\n  if (is(semantic, 'bpmn:Event')) {\n    return { width: 36, height: 36 };\n  }\n\n  if (is(semantic, 'bpmn:Participant')) {\n    if (!isExpanded(semantic)) {\n      return { width: 400, height: 60 };\n    } else {\n      return { width: 600, height: 250 };\n    }\n  }\n\n  if (is(semantic, 'bpmn:Lane')) {\n    return { width: 400, height: 100 };\n  }\n\n  if (is(semantic, 'bpmn:DataObjectReference')) {\n    return { width: 36, height: 50 };\n  }\n\n  if (is(semantic, 'bpmn:DataStoreReference')) {\n    return { width: 50, height: 50 };\n  }\n\n  if (is(semantic, 'bpmn:TextAnnotation')) {\n    return { width: 100, height: 30 };\n  }\n\n  return { width: 100, height: 80 };\n};",
            "name": "function_4",
            "parameters": [
                "semantic"
            ],
            "start_line": 137,
            "end_line": 185,
            "return": true
        },
        "function_5": {
            "signature": "",
            "content": "ElementFactory.prototype.createParticipantShape = function(collapsed) {\n\n  var attrs = { type: 'bpmn:Participant' };\n\n  if (!collapsed) {\n    attrs.processRef = this._bpmnFactory.create('bpmn:Process');\n  }\n\n  return this.createShape(attrs);\n};",
            "name": "function_5",
            "parameters": [
                "collapsed"
            ],
            "start_line": 188,
            "end_line": 197,
            "return": true
        },
        "function_6": {
            "signature": "/**\n* Apply attributes from a map to the given element,\n* remove attribute from the map on application.\n*\n* @param {Base} element\n* @param {Object} attrs (in/out map of attributes)\n* @param {Array<String>} attributeNames name of attributes to apply\n*/",
            "content": "function applyAttributes(element, attrs, attributeNames) {\n\n  forEach(attributeNames, function(property) {\n    if (attrs[property] !== undefined) {\n      applyAttribute(element, attrs, property);\n    }\n  });\n}",
            "name": "applyAttributes",
            "parameters": [
                "element",
                "attrs",
                "attributeNames"
            ],
            "start_line": 210,
            "end_line": 217,
            "return": false
        },
        "function_8": {
            "signature": "/**\n* Apply named property to element and drain it from the attrs\n* collection.\n*\n* @param {Base} element\n* @param {Object} attrs (in/out map of attributes)\n* @param {String} attributeName to apply\n*/",
            "content": "function applyAttribute(element, attrs, attributeName) {\n  element[attributeName] = attrs[attributeName];\n\n  delete attrs[attributeName];\n}",
            "name": "applyAttribute",
            "parameters": [
                "element",
                "attrs",
                "attributeName"
            ],
            "start_line": 227,
            "end_line": 231,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\Modeling.js": {
        "function_1": {
            "signature": "/**\n* BPMN 2.0 modeling features activator\n*\n* @param {EventBus} eventBus\n* @param {ElementFactory} elementFactory\n* @param {CommandStack} commandStack\n* @param {BpmnRules} bpmnRules\n*/",
            "content": "export default function Modeling(\n    eventBus, elementFactory, commandStack,\n    bpmnRules) {\n\n  BaseModeling.call(this, eventBus, elementFactory, commandStack);\n\n  this._bpmnRules = bpmnRules;\n}",
            "name": "Modeling",
            "parameters": [
                "eventBus",
                "elementFactory",
                "commandStack",
                "bpmnRules"
            ],
            "start_line": 25,
            "end_line": 32,
            "return": false
        },
        "function_2": {
            "signature": "",
            "content": "Modeling.prototype.getHandlers = function() {\n  var handlers = BaseModeling.prototype.getHandlers.call(this);\n\n  handlers['element.updateProperties'] = UpdatePropertiesHandler;\n  handlers['canvas.updateRoot'] = UpdateCanvasRootHandler;\n  handlers['lane.add'] = AddLaneHandler;\n  handlers['lane.resize'] = ResizeLaneHandler;\n  handlers['lane.split'] = SplitLaneHandler;\n  handlers['lane.updateRefs'] = UpdateFlowNodeRefsHandler;\n  handlers['id.updateClaim'] = IdClaimHandler;\n  handlers['element.setColor'] = SetColorHandler;\n  handlers['element.updateLabel'] = UpdateLabelHandler;\n\n  return handlers;\n};",
            "name": "function_2",
            "parameters": [],
            "start_line": 44,
            "end_line": 58,
            "return": true
        },
        "function_3": {
            "signature": "",
            "content": "Modeling.prototype.updateLabel = function(element, newLabel, newBounds, hints) {\n  this._commandStack.execute('element.updateLabel', {\n    element: element,\n    newLabel: newLabel,\n    newBounds: newBounds,\n    hints: hints || {}\n  });\n};",
            "name": "function_3",
            "parameters": [
                "element",
                "newLabel",
                "newBounds",
                "hints"
            ],
            "start_line": 61,
            "end_line": 68,
            "return": false
        },
        "function_4": {
            "signature": "",
            "content": "Modeling.prototype.connect = function(source, target, attrs, hints) {\n\n  var bpmnRules = this._bpmnRules;\n\n  if (!attrs) {\n    attrs = bpmnRules.canConnect(source, target);\n  }\n\n  if (!attrs) {\n    return;\n  }\n\n  return this.createConnection(source, target, attrs, source.parent, hints);\n};",
            "name": "function_4",
            "parameters": [
                "source",
                "target",
                "attrs",
                "hints"
            ],
            "start_line": 71,
            "end_line": 84,
            "return": true
        },
        "function_5": {
            "signature": "",
            "content": "Modeling.prototype.updateProperties = function(element, properties) {\n  this._commandStack.execute('element.updateProperties', {\n    element: element,\n    properties: properties\n  });\n};",
            "name": "function_5",
            "parameters": [
                "element",
                "properties"
            ],
            "start_line": 87,
            "end_line": 92,
            "return": false
        },
        "function_6": {
            "signature": "",
            "content": "Modeling.prototype.resizeLane = function(laneShape, newBounds, balanced) {\n  this._commandStack.execute('lane.resize', {\n    shape: laneShape,\n    newBounds: newBounds,\n    balanced: balanced\n  });\n};",
            "name": "function_6",
            "parameters": [
                "laneShape",
                "newBounds",
                "balanced"
            ],
            "start_line": 94,
            "end_line": 100,
            "return": false
        },
        "function_7": {
            "signature": "",
            "content": "Modeling.prototype.addLane = function(targetLaneShape, location) {\n  var context = {\n    shape: targetLaneShape,\n    location: location\n  };\n\n  this._commandStack.execute('lane.add', context);\n\n  return context.newLane;\n};",
            "name": "function_7",
            "parameters": [
                "targetLaneShape",
                "location"
            ],
            "start_line": 102,
            "end_line": 111,
            "return": true
        },
        "function_8": {
            "signature": "",
            "content": "Modeling.prototype.splitLane = function(targetLane, count) {\n  this._commandStack.execute('lane.split', {\n    shape: targetLane,\n    count: count\n  });\n};",
            "name": "function_8",
            "parameters": [
                "targetLane",
                "count"
            ],
            "start_line": 113,
            "end_line": 118,
            "return": false
        },
        "function_9": {
            "signature": "/**\n* Transform the current diagram into a collaboration.\n*\n* @return {djs.model.Root} the new root element\n*/",
            "content": "Modeling.prototype.makeCollaboration = function() {\n\n  var collaborationElement = this._create('root', {\n    type: 'bpmn:Collaboration'\n  });\n\n  var context = {\n    newRoot: collaborationElement\n  };\n\n  this._commandStack.execute('canvas.updateRoot', context);\n\n  return collaborationElement;\n};",
            "name": "function_9",
            "parameters": [],
            "start_line": 125,
            "end_line": 138,
            "return": true
        },
        "function_10": {
            "signature": "",
            "content": "Modeling.prototype.updateLaneRefs = function(flowNodeShapes, laneShapes) {\n\n  this._commandStack.execute('lane.updateRefs', {\n    flowNodeShapes: flowNodeShapes,\n    laneShapes: laneShapes\n  });\n};",
            "name": "function_10",
            "parameters": [
                "flowNodeShapes",
                "laneShapes"
            ],
            "start_line": 140,
            "end_line": 146,
            "return": false
        },
        "function_11": {
            "signature": "/**\n* Transform the current diagram into a process.\n*\n* @return {djs.model.Root} the new root element\n*/",
            "content": "Modeling.prototype.makeProcess = function() {\n\n  var processElement = this._create('root', {\n    type: 'bpmn:Process'\n  });\n\n  var context = {\n    newRoot: processElement\n  };\n\n  this._commandStack.execute('canvas.updateRoot', context);\n};",
            "name": "function_11",
            "parameters": [],
            "start_line": 153,
            "end_line": 164,
            "return": false
        },
        "function_12": {
            "signature": "",
            "content": "Modeling.prototype.claimId = function(id, moddleElement) {\n  this._commandStack.execute('id.updateClaim', {\n    id: id,\n    element: moddleElement,\n    claiming: true\n  });\n};",
            "name": "function_12",
            "parameters": [
                "id",
                "moddleElement"
            ],
            "start_line": 167,
            "end_line": 173,
            "return": false
        },
        "function_13": {
            "signature": "",
            "content": "Modeling.prototype.unclaimId = function(id, moddleElement) {\n  this._commandStack.execute('id.updateClaim', {\n    id: id,\n    element: moddleElement\n  });\n};",
            "name": "function_13",
            "parameters": [
                "id",
                "moddleElement"
            ],
            "start_line": 176,
            "end_line": 181,
            "return": false
        },
        "function_14": {
            "signature": "",
            "content": "Modeling.prototype.setColor = function(elements, colors) {\n  if (!elements.length) {\n    elements = [ elements ];\n  }\n\n  this._commandStack.execute('element.setColor', {\n    elements: elements,\n    colors: colors\n  });\n};",
            "name": "function_14",
            "parameters": [
                "elements",
                "colors"
            ],
            "start_line": 183,
            "end_line": 192,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\AdaptiveLabelPositioningBehavior.js": {
        "function_1": {
            "signature": "/**\n* A component that makes sure that external labels are added\n* together with respective elements and properly updated (DI wise)\n* during move.\n*\n* @param {EventBus} eventBus\n* @param {Modeling} modeling\n*/",
            "content": "export default function AdaptiveLabelPositioningBehavior(eventBus, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this.postExecuted([\n    'connection.create',\n    'connection.layout',\n    'connection.updateWaypoints'\n  ], function(event) {\n\n    var context = event.context,\n        connection = context.connection;\n\n    var source = connection.source,\n        target = connection.target;\n\n    checkLabelAdjustment(source);\n    checkLabelAdjustment(target);\n  });\n\n\n  this.postExecuted([\n    'label.create'\n  ], function(event) {\n    checkLabelAdjustment(event.context.shape.labelTarget);\n  });\n\n\n  function checkLabelAdjustment(element) {\n\n    // skip non-existing labels\n    if (!hasExternalLabel(element)) {\n      return;\n    }\n\n    var optimalPosition = getOptimalPosition(element);\n\n    // no optimal position found\n    if (!optimalPosition) {\n      return;\n    }\n\n    adjustLabelPosition(element, optimalPosition);\n  }\n\n  var ELEMENT_LABEL_DISTANCE = 10;\n\n  function adjustLabelPosition(element, orientation) {\n\n    var elementMid = getMid(element),\n        label = element.label,\n        labelMid = getMid(label);\n\n    var elementTrbl = asTRBL(element);\n\n    var newLabelMid;\n\n    switch (orientation) {\n    case 'top':\n      newLabelMid = {\n        x: elementMid.x,\n        y: elementTrbl.top - ELEMENT_LABEL_DISTANCE - label.height / 2\n      };\n\n      break;\n\n    case 'left':\n\n      newLabelMid = {\n        x: elementTrbl.left - ELEMENT_LABEL_DISTANCE - label.width / 2,\n        y: elementMid.y\n      };\n\n      break;\n\n    case 'bottom':\n\n      newLabelMid = {\n        x: elementMid.x,\n        y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE + label.height / 2\n      };\n\n      break;\n\n    case 'right':\n\n      newLabelMid = {\n        x: elementTrbl.right + ELEMENT_LABEL_DISTANCE + label.width / 2,\n        y: elementMid.y\n      };\n\n      break;\n    }\n\n\n    var delta = substract(newLabelMid, labelMid);\n\n    modeling.moveShape(label, delta);\n  }\n\n}",
            "name": "AdaptiveLabelPositioningBehavior",
            "parameters": [
                "eventBus",
                "modeling"
            ],
            "start_line": 28,
            "end_line": 128,
            "return": true
        },
        "function_6": {
            "signature": "/**\n* Return the optimal label position around an element\n* or _undefined_, if none was found.\n*\n* @param  {Shape} element\n*\n* @return {String} positioning identifier\n*/",
            "content": "function getOptimalPosition(element) {\n\n  var labelMid = getMid(element.label);\n\n  var elementMid = getMid(element);\n\n  var labelOrientation = getApproximateOrientation(elementMid, labelMid);\n\n  if (!isAligned(labelOrientation)) {\n    return;\n  }\n\n  var takenAlignments = [].concat(\n    element.incoming.map(function(c) {\n      return c.waypoints[c.waypoints.length - 2 ];\n    }),\n    element.outgoing.map(function(c) {\n      return c.waypoints[1];\n    })\n  ).map(function(point) {\n    return getApproximateOrientation(elementMid, point);\n  });\n\n  var freeAlignments = ALIGNMENTS.filter(function(alignment) {\n\n    return takenAlignments.indexOf(alignment) === -1;\n  });\n\n  // NOTHING TO DO; label already aligned a.O.K.\n  if (freeAlignments.indexOf(labelOrientation) !== -1) {\n    return;\n  }\n\n  return freeAlignments[0];\n}",
            "name": "getOptimalPosition",
            "parameters": [
                "element"
            ],
            "start_line": 146,
            "end_line": 180,
            "return": true
        },
        "function_11": {
            "signature": "",
            "content": "function getApproximateOrientation(p0, p1) {\n  return getOrientation(p1, p0, 5);\n}",
            "name": "getApproximateOrientation",
            "parameters": [
                "p0",
                "p1"
            ],
            "start_line": 189,
            "end_line": 191,
            "return": true
        },
        "function_12": {
            "signature": "",
            "content": "function isAligned(orientation) {\n  return ALIGNMENTS.indexOf(orientation) !== -1;\n}",
            "name": "isAligned",
            "parameters": [
                "orientation"
            ],
            "start_line": 193,
            "end_line": 195,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\AppendBehavior.js": {
        "function_1": {
            "signature": "",
            "content": "export default function AppendBehavior(eventBus, elementFactory, bpmnRules) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  // assign correct shape position unless already set\n\n  this.preExecute('shape.append', function(context) {\n\n    var source = context.source,\n        shape = context.shape;\n\n    if (!context.position) {\n\n      if (is(shape, 'bpmn:TextAnnotation')) {\n        context.position = {\n          x: source.x + source.width / 2 + 75,\n          y: source.y - (50) - shape.height / 2\n        };\n      } else {\n        context.position = {\n          x: source.x + source.width + 80 + shape.width / 2,\n          y: source.y + source.height / 2\n        };\n      }\n    }\n  }, true);\n}",
            "name": "AppendBehavior",
            "parameters": [
                "eventBus",
                "elementFactory",
                "bpmnRules"
            ],
            "start_line": 8,
            "end_line": 34,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\BoundaryEventBehavior.js": {
        "function_1": {
            "signature": "/**\n* BPMN specific boundary event behavior\n*/",
            "content": "export default function BoundaryEventBehavior(eventBus, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  function getBoundaryEvents(element) {\n    return filter(element.attachers, function(attacher) {\n      return is(attacher, 'bpmn:BoundaryEvent');\n    });\n  }\n\n  // remove after connecting to event-based gateway\n  this.postExecute('connection.create', function(event) {\n    var source = event.context.source,\n        target = event.context.target,\n        boundaryEvents = getBoundaryEvents(target);\n\n    if (\n      is(source, 'bpmn:EventBasedGateway') &&\n      is(target, 'bpmn:ReceiveTask') &&\n      boundaryEvents.length > 0\n    ) {\n      modeling.removeElements(boundaryEvents);\n    }\n\n  });\n\n  // remove after replacing connected gateway with event-based gateway\n  this.postExecute('connection.reconnectStart', function(event) {\n    var oldSource = event.context.oldSource,\n        newSource = event.context.newSource;\n\n    if (is(oldSource, 'bpmn:Gateway') &&\n        is(newSource, 'bpmn:EventBasedGateway')) {\n      forEach(newSource.outgoing, function(connection) {\n        var target = connection.target,\n            attachedboundaryEvents = getBoundaryEvents(target);\n\n        if (is(target, 'bpmn:ReceiveTask') &&\n            attachedboundaryEvents.length > 0) {\n          modeling.removeElements(attachedboundaryEvents);\n        }\n      });\n    }\n  });\n}",
            "name": "BoundaryEventBehavior",
            "parameters": [
                "eventBus",
                "modeling"
            ],
            "start_line": 16,
            "end_line": 60,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\CopyPasteBehavior.js": {
        "function_1": {
            "signature": "",
            "content": "export default function CopyPasteBehavior(eventBus, modeling, canvas) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this.preExecute('elements.paste', 1500, function(context) {\n    var topParent = context.topParent;\n\n    // always grab the latest root\n    if (!topParent.parent) {\n      context.topParent = canvas.getRootElement();\n    }\n\n    if (is(topParent, 'bpmn:Lane')) {\n      do {\n        // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)\n        topParent = context.topParent = topParent.parent;\n\n      } while (is(topParent, 'bpmn:Lane') || !is(topParent, 'bpmn:Participant'));\n    }\n  }, true);\n\n  this.postExecute('elements.paste', function(context) {\n\n    var tree = context.tree,\n        createdElements = tree.createdElements;\n\n    forEach(createdElements, function(data) {\n      var element = data.element,\n          businessObject = element.businessObject,\n          descriptor = data.descriptor,\n          defaultFlow;\n\n      if ((is(businessObject, 'bpmn:ExclusiveGateway') || is(businessObject, 'bpmn:InclusiveGateway') ||\n           is(businessObject, 'bpmn:Activity')) && descriptor.default) {\n\n        defaultFlow = createdElements[descriptor.default];\n\n        // if the default flow wasn't created, means that it wasn't copied\n        if (defaultFlow) {\n          defaultFlow = defaultFlow.element;\n        } else {\n          defaultFlow = undefined;\n        }\n\n        delete element.default;\n\n        modeling.updateProperties(element, { default: defaultFlow });\n      }\n    });\n  }, true);\n}",
            "name": "CopyPasteBehavior",
            "parameters": [
                "eventBus",
                "modeling",
                "canvas"
            ],
            "start_line": 12,
            "end_line": 62,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\CreateBoundaryEventBehavior.js": {
        "function_1": {
            "signature": "/**\n* BPMN specific create boundary event behavior\n*/",
            "content": "export default function CreateBoundaryEventBehavior(\n    eventBus, modeling, elementFactory,\n    bpmnFactory) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * replace intermediate event with boundary event when\n   * attaching it to a shape\n   */\n\n  this.preExecute('shape.create', function(context) {\n    var shape = context.shape,\n        host = context.host,\n        businessObject,\n        boundaryEvent;\n\n    var attrs = {\n      cancelActivity: true\n    };\n\n    if (host && is(shape, 'bpmn:IntermediateThrowEvent')) {\n      attrs.attachedToRef = host.businessObject;\n\n      businessObject = bpmnFactory.create('bpmn:BoundaryEvent', attrs);\n\n      boundaryEvent = {\n        type: 'bpmn:BoundaryEvent',\n        businessObject: businessObject\n      };\n\n      context.shape = elementFactory.createShape(boundaryEvent);\n    }\n  }, true);\n}",
            "name": "CreateBoundaryEventBehavior",
            "parameters": [
                "eventBus",
                "modeling",
                "elementFactory",
                "bpmnFactory"
            ],
            "start_line": 11,
            "end_line": 45,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\CreateDataObjectBehavior.js": {
        "function_1": {
            "signature": "/**\n* BPMN specific create data object behavior\n*/",
            "content": "export default function CreateDataObjectBehavior(eventBus, bpmnFactory, moddle) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this.preExecute('shape.create', function(event) {\n\n    var context = event.context,\n        shape = context.shape;\n\n    if (is(shape, 'bpmn:DataObjectReference') && shape.type !== 'label') {\n\n      // create a DataObject every time a DataObjectReference is created\n      var dataObject = bpmnFactory.create('bpmn:DataObject');\n\n      // set the reference to the DataObject\n      shape.businessObject.dataObjectRef = dataObject;\n    }\n  });\n\n}",
            "name": "CreateDataObjectBehavior",
            "parameters": [
                "eventBus",
                "bpmnFactory",
                "moddle"
            ],
            "start_line": 11,
            "end_line": 30,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\CreateParticipantBehavior.js": {
        "function_1": {
            "signature": "/**\n* BPMN specific create participant behavior\n*/",
            "content": "export default function CreateParticipantBehavior(\n    eventBus, modeling, elementFactory,\n    bpmnFactory, canvas) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * morph process into collaboration before adding\n   * participant onto collaboration\n   */\n\n  this.preExecute('shape.create', function(context) {\n\n    var parent = context.parent,\n        shape = context.shape,\n        position = context.position;\n\n    var rootElement = canvas.getRootElement();\n\n    if (\n      is(parent, 'bpmn:Process') &&\n      is(shape, 'bpmn:Participant') &&\n      !is(rootElement, 'bpmn:Collaboration')\n    ) {\n\n      // this is going to detach the process root\n      // and set the returned collaboration element\n      // as the new root element\n      var collaborationElement = modeling.makeCollaboration();\n\n      // monkey patch the create context\n      // so that the participant is being dropped\n      // onto the new collaboration root instead\n      context.position = position;\n      context.parent = collaborationElement;\n\n      context.processRoot = parent;\n    }\n  }, true);\n\n\n  this.execute('shape.create', function(context) {\n\n    var processRoot = context.processRoot,\n        shape = context.shape;\n\n    if (processRoot) {\n      context.oldProcessRef = shape.businessObject.processRef;\n\n      // assign the participant processRef\n      shape.businessObject.processRef = processRoot.businessObject;\n    }\n  }, true);\n\n\n  this.revert('shape.create', function(context) {\n    var processRoot = context.processRoot,\n        shape = context.shape;\n\n    if (processRoot) {\n      // assign the participant processRef\n      shape.businessObject.processRef = context.oldProcessRef;\n    }\n  }, true);\n\n\n  this.postExecute('shape.create', function(context) {\n\n    var processRoot = context.processRoot,\n        shape = context.shape;\n\n    if (processRoot) {\n      // process root is already detached at this point\n      var processChildren = processRoot.children.slice();\n      modeling.moveElements(processChildren, { x: 0, y: 0 }, shape);\n    }\n\n  }, true);\n\n}",
            "name": "CreateParticipantBehavior",
            "parameters": [
                "eventBus",
                "modeling",
                "elementFactory",
                "bpmnFactory",
                "canvas"
            ],
            "start_line": 11,
            "end_line": 90,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\DataInputAssociationBehavior.js": {
        "function_1": {
            "signature": "/**\n* This behavior makes sure we always set a fake\n* DataInputAssociation#targetRef as demanded by the BPMN 2.0\n* XSD schema.\n*\n* The reference is set to a bpmn:Property{ name: '__targetRef_placeholder' }\n* which is created on the fly and cleaned up afterwards if not needed\n* anymore.\n*\n* @param {EventBus} eventBus\n* @param {BpmnFactory} bpmnFactory\n*/",
            "content": "export default function DataInputAssociationBehavior(eventBus, bpmnFactory) {\n\n  CommandInterceptor.call(this, eventBus);\n\n\n  this.executed([\n    'connection.create',\n    'connection.delete',\n    'connection.move',\n    'connection.reconnectEnd'\n  ], ifDataInputAssociation(fixTargetRef));\n\n  this.reverted([\n    'connection.create',\n    'connection.delete',\n    'connection.move',\n    'connection.reconnectEnd'\n  ], ifDataInputAssociation(fixTargetRef));\n\n\n  function usesTargetRef(element, targetRef, removedConnection) {\n\n    var inputAssociations = element.get('dataInputAssociations');\n\n    return find(inputAssociations, function(association) {\n      return association !== removedConnection &&\n             association.targetRef === targetRef;\n    });\n  }\n\n  function getTargetRef(element, create) {\n\n    var properties = element.get('properties');\n\n    var targetRefProp = find(properties, function(p) {\n      return p.name === TARGET_REF_PLACEHOLDER_NAME;\n    });\n\n    if (!targetRefProp && create) {\n      targetRefProp = bpmnFactory.create('bpmn:Property', {\n        name: TARGET_REF_PLACEHOLDER_NAME\n      });\n\n      collectionAdd(properties, targetRefProp);\n    }\n\n    return targetRefProp;\n  }\n\n  function cleanupTargetRef(element, connection) {\n\n    var targetRefProp = getTargetRef(element);\n\n    if (!targetRefProp) {\n      return;\n    }\n\n    if (!usesTargetRef(element, targetRefProp, connection)) {\n      collectionRemove(element.get('properties'), targetRefProp);\n    }\n  }\n\n  /**\n   * Make sure targetRef is set to a valid property or\n   * `null` if the connection is detached.\n   *\n   * @param {Event} event\n   */\n  function fixTargetRef(event) {\n\n    var context = event.context,\n        connection = context.connection,\n        connectionBo = connection.businessObject,\n        target = connection.target,\n        targetBo = target && target.businessObject,\n        newTarget = context.newTarget,\n        newTargetBo = newTarget && newTarget.businessObject,\n        oldTarget = context.oldTarget || context.target,\n        oldTargetBo = oldTarget && oldTarget.businessObject;\n\n    var dataAssociation = connection.businessObject,\n        targetRefProp;\n\n    if (oldTargetBo && oldTargetBo !== targetBo) {\n      cleanupTargetRef(oldTargetBo, connectionBo);\n    }\n\n    if (newTargetBo && newTargetBo !== targetBo) {\n      cleanupTargetRef(newTargetBo, connectionBo);\n    }\n\n    if (targetBo) {\n      targetRefProp = getTargetRef(targetBo, true);\n      dataAssociation.targetRef = targetRefProp;\n    } else {\n      dataAssociation.targetRef = null;\n    }\n  }\n}",
            "name": "DataInputAssociationBehavior",
            "parameters": [
                "eventBus",
                "bpmnFactory"
            ],
            "start_line": 33,
            "end_line": 131,
            "return": true
        },
        "function_8": {
            "signature": "/**\n* Only call the given function when the event\n* touches a bpmn:DataInputAssociation.\n*\n* @param {Function} fn\n* @return {Function}\n*/",
            "content": "function ifDataInputAssociation(fn) {\n\n  return function(event) {\n    var context = event.context,\n        connection = context.connection;\n\n    if (is(connection, 'bpmn:DataInputAssociation')) {\n      return fn(event);\n    }\n  };\n}",
            "name": "ifDataInputAssociation",
            "parameters": [
                "fn"
            ],
            "start_line": 148,
            "end_line": 158,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\DataStoreBehavior.js": {
        "function_1": {
            "signature": "/**\n* BPMN specific data store behavior\n*/",
            "content": "export default function DataStoreBehavior(\n    canvas, commandStack, elementRegistry,\n    eventBus) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  commandStack.registerHandler('dataStore.updateContainment', UpdateSemanticParentHandler);\n\n  function getFirstParticipant() {\n    return elementRegistry.filter(function(element) {\n      return is(element, 'bpmn:Participant');\n    })[0];\n  }\n\n  function getDataStores(element) {\n    return element.children.filter(function(child) {\n      return is(child, 'bpmn:DataStoreReference') && !child.labelTarget;\n    });\n  }\n\n  function updateDataStoreParent(dataStore, newDataStoreParent) {\n    var dataStoreBo = dataStore.businessObject || dataStore;\n\n    newDataStoreParent = newDataStoreParent || getFirstParticipant();\n\n    if (newDataStoreParent) {\n      var newDataStoreParentBo = newDataStoreParent.businessObject || newDataStoreParent;\n\n      commandStack.execute('dataStore.updateContainment', {\n        dataStoreBo: dataStoreBo,\n        newSemanticParent: newDataStoreParentBo.processRef || newDataStoreParentBo,\n        newDiParent: newDataStoreParentBo.di\n      });\n    }\n  }\n\n\n  // disable auto-resize for data stores\n  this.preExecute('shape.create', function(event) {\n\n    var context = event.context,\n        shape = context.shape;\n\n    if (is(shape, 'bpmn:DataStoreReference') &&\n        shape.type !== 'label') {\n\n      if (!context.hints) {\n        context.hints = {};\n      }\n\n      // prevent auto resizing\n      context.hints.autoResize = false;\n    }\n  });\n\n\n  // disable auto-resize for data stores\n  this.preExecute('elements.move', function(event) {\n    var context = event.context,\n        shapes = context.shapes;\n\n    var dataStoreReferences = shapes.filter(function(shape) {\n      return is(shape, 'bpmn:DataStoreReference');\n    });\n\n    if (dataStoreReferences.length) {\n      if (!context.hints) {\n        context.hints = {};\n      }\n\n      // prevent auto resizing for data store references\n      context.hints.autoResize = shapes.filter(function(shape) {\n        return !is(shape, 'bpmn:DataStoreReference');\n      });\n    }\n  });\n\n\n  // update parent on data store created\n  this.postExecute('shape.create', function(event) {\n    var context = event.context,\n        shape = context.shape,\n        parent = shape.parent;\n\n\n    if (is(shape, 'bpmn:DataStoreReference') &&\n        shape.type !== 'label' &&\n        is(parent, 'bpmn:Collaboration')) {\n\n      updateDataStoreParent(shape);\n    }\n  });\n\n\n  // update parent on data store moved\n  this.postExecute('shape.move', function(event) {\n    var context = event.context,\n        shape = context.shape,\n        oldParent = context.oldParent,\n        parent = shape.parent;\n\n    if (is(oldParent, 'bpmn:Collaboration')) {\n\n      // do nothing if not necessary\n      return;\n    }\n\n    if (is(shape, 'bpmn:DataStoreReference') &&\n        shape.type !== 'label' &&\n        is(parent, 'bpmn:Collaboration')) {\n\n      var participant = is(oldParent, 'bpmn:Participant') ?\n        oldParent :\n        getAncestor(oldParent, 'bpmn:Participant');\n\n      updateDataStoreParent(shape, participant);\n    }\n  });\n\n\n  // update data store parents on participant or subprocess deleted\n  this.postExecute('shape.delete', function(event) {\n    var context = event.context,\n        shape = context.shape,\n        rootElement = canvas.getRootElement();\n\n    if (isAny(shape, [ 'bpmn:Participant', 'bpmn:SubProcess' ])\n        && is(rootElement, 'bpmn:Collaboration')) {\n      getDataStores(rootElement)\n        .filter(function(dataStore) {\n          return isDescendant(dataStore, shape);\n        })\n        .forEach(function(dataStore) {\n          updateDataStoreParent(dataStore);\n        });\n    }\n  });\n\n  // update data store parents on collaboration -> process\n  this.postExecute('canvas.updateRoot', function(event) {\n    var context = event.context,\n        oldRoot = context.oldRoot,\n        newRoot = context.newRoot;\n\n    var dataStores = getDataStores(oldRoot);\n\n    dataStores.forEach(function(dataStore) {\n\n      if (is(newRoot, 'bpmn:Process')) {\n        updateDataStoreParent(dataStore, newRoot);\n      }\n\n    });\n  });\n}",
            "name": "DataStoreBehavior",
            "parameters": [
                "canvas",
                "commandStack",
                "elementRegistry",
                "eventBus"
            ],
            "start_line": 15,
            "end_line": 169,
            "return": true
        },
        "function_18": {
            "signature": "// helpers //////////",
            "content": "function isDescendant(descendant, ancestor) {\n  var descendantBo = descendant.businessObject || descendant,\n      ancestorBo = ancestor.businessObject || ancestor;\n\n  while (descendantBo.$parent) {\n    if (descendantBo.$parent === ancestorBo.processRef || ancestorBo) {\n      return true;\n    }\n\n    descendantBo = descendantBo.$parent;\n  }\n\n  return false;\n}",
            "name": "isDescendant",
            "parameters": [
                "descendant",
                "ancestor"
            ],
            "start_line": 183,
            "end_line": 196,
            "return": true
        },
        "function_19": {
            "signature": "",
            "content": "function getAncestor(element, type) {\n\n  while (element.parent) {\n    if (is(element.parent, type)) {\n      return element.parent;\n    }\n\n    element = element.parent;\n  }\n}",
            "name": "getAncestor",
            "parameters": [
                "element",
                "type"
            ],
            "start_line": 198,
            "end_line": 207,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\DeleteLaneBehavior.js": {
        "function_1": {
            "signature": "/**\n* BPMN specific delete lane behavior\n*/",
            "content": "export default function DeleteLaneBehavior(eventBus, modeling, spaceTool) {\n\n  CommandInterceptor.call(this, eventBus);\n\n\n  function compensateLaneDelete(shape, oldParent) {\n\n    var siblings = getChildLanes(oldParent);\n\n    var topAffected = [];\n    var bottomAffected = [];\n\n    eachElement(siblings, function(element) {\n\n      if (element.y > shape.y) {\n        bottomAffected.push(element);\n      } else {\n        topAffected.push(element);\n      }\n\n      return element.children;\n    });\n\n    if (!siblings.length) {\n      return;\n    }\n\n    var offset;\n\n    if (bottomAffected.length && topAffected.length) {\n      offset = shape.height / 2;\n    } else {\n      offset = shape.height;\n    }\n\n    var topAdjustments,\n        bottomAdjustments;\n\n    if (topAffected.length) {\n      topAdjustments = spaceTool.calculateAdjustments(\n        topAffected, 'y', offset, shape.y - 10);\n\n      spaceTool.makeSpace(\n        topAdjustments.movingShapes,\n        topAdjustments.resizingShapes,\n        { x: 0, y: offset }, 's');\n    }\n\n    if (bottomAffected.length) {\n      bottomAdjustments = spaceTool.calculateAdjustments(\n        bottomAffected, 'y', -offset, shape.y + shape.height + 10);\n\n      spaceTool.makeSpace(\n        bottomAdjustments.movingShapes,\n        bottomAdjustments.resizingShapes,\n        { x: 0, y: -offset }, 'n');\n    }\n  }\n\n\n  /**\n   * Adjust sizes of other lanes after lane deletion\n   */\n  this.postExecuted('shape.delete', LOW_PRIORITY, function(event) {\n\n    var context = event.context,\n        hints = context.hints,\n        shape = context.shape,\n        oldParent = context.oldParent;\n\n    // only compensate lane deletes\n    if (!is(shape, 'bpmn:Lane')) {\n      return;\n    }\n\n    // compensate root deletes only\n    if (hints && hints.nested) {\n      return;\n    }\n\n    compensateLaneDelete(shape, oldParent);\n  });\n}",
            "name": "DeleteLaneBehavior",
            "parameters": [
                "eventBus",
                "modeling",
                "spaceTool"
            ],
            "start_line": 22,
            "end_line": 104,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\DropOnFlowBehavior.js": {
        "function_1": {
            "signature": "",
            "content": "export default function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * Reconnect start / end of a connection after\n   * dropping an element on a flow.\n   */\n\n  function insertShape(shape, targetFlow, position) {\n    var waypoints = targetFlow.waypoints,\n        waypointsBefore,\n        waypointsAfter,\n        dockingPoint,\n        source,\n        target,\n        incomingConnection,\n        outgoingConnection,\n        oldOutgoing = shape.outgoing.slice(),\n        oldIncoming = shape.incoming.slice();\n\n    var intersection = getApproxIntersection(waypoints, position);\n\n    if (intersection) {\n      waypointsBefore = waypoints.slice(0, intersection.index);\n      waypointsAfter = waypoints.slice(intersection.index + (intersection.bendpoint ? 1 : 0));\n\n      // due to inaccuracy intersection might have been found\n      if (!waypointsBefore.length || !waypointsAfter.length) {\n        return;\n      }\n\n      dockingPoint = intersection.bendpoint ? waypoints[intersection.index] : position;\n\n      // if last waypointBefore is inside shape's bounds, ignore docking point\n      if (!isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length-1])) {\n        waypointsBefore.push(copy(dockingPoint));\n      }\n\n      // if first waypointAfter is inside shape's bounds, ignore docking point\n      if (!isPointInsideBBox(shape, waypointsAfter[0])) {\n        waypointsAfter.unshift(copy(dockingPoint));\n      }\n    }\n\n    source = targetFlow.source;\n    target = targetFlow.target;\n\n    if (bpmnRules.canConnect(source, shape, targetFlow)) {\n      // reconnect source -> inserted shape\n      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || position);\n\n      incomingConnection = targetFlow;\n    }\n\n    if (bpmnRules.canConnect(shape, target, targetFlow)) {\n\n      if (!incomingConnection) {\n        // reconnect inserted shape -> end\n        modeling.reconnectStart(targetFlow, shape, waypointsAfter || position);\n\n        outgoingConnection = targetFlow;\n      } else {\n        outgoingConnection = modeling.connect(\n          shape, target, { type: targetFlow.type, waypoints: waypointsAfter }\n        );\n      }\n    }\n\n    var duplicateConnections = [].concat(\n\n      incomingConnection && filter(oldIncoming, function(connection) {\n        return connection.source === incomingConnection.source;\n      }) || [],\n\n      outgoingConnection && filter(oldOutgoing, function(connection) {\n        return connection.source === outgoingConnection.source;\n      }) || []\n    );\n\n    if (duplicateConnections.length) {\n      modeling.removeElements(duplicateConnections);\n    }\n  }\n\n  this.preExecute('elements.move', function(context) {\n\n    var newParent = context.newParent,\n        shapes = context.shapes,\n        delta = context.delta,\n        shape = shapes[0];\n\n    if (!shape || !newParent) {\n      return;\n    }\n\n    // if the new parent is a connection,\n    // change it to the new parent's parent\n    if (newParent && newParent.waypoints) {\n      context.newParent = newParent = newParent.parent;\n    }\n\n    var shapeMid = getMid(shape);\n    var newShapeMid = {\n      x: shapeMid.x + delta.x,\n      y: shapeMid.y + delta.y\n    };\n\n    // find a connection which intersects with the\n    // element's mid point\n    var connection = find(newParent.children, function(element) {\n      var canInsert = bpmnRules.canInsert(shapes, element);\n\n      return canInsert && getApproxIntersection(element.waypoints, newShapeMid);\n    });\n\n    if (connection) {\n      context.targetFlow = connection;\n      context.position = newShapeMid;\n    }\n\n  }, true);\n\n  this.postExecuted('elements.move', function(context) {\n\n    var shapes = context.shapes,\n        targetFlow = context.targetFlow,\n        position = context.position;\n\n    if (targetFlow) {\n      insertShape(shapes[0], targetFlow, position);\n    }\n\n  }, true);\n\n  this.preExecute('shape.create', function(context) {\n\n    var parent = context.parent,\n        shape = context.shape;\n\n    if (bpmnRules.canInsert(shape, parent)) {\n      context.targetFlow = parent;\n      context.parent = parent.parent;\n    }\n  }, true);\n\n  this.postExecuted('shape.create', function(context) {\n\n    var shape = context.shape,\n        targetFlow = context.targetFlow,\n        position = context.position;\n\n    if (targetFlow) {\n      insertShape(shape, targetFlow, position);\n    }\n  }, true);\n}",
            "name": "DropOnFlowBehavior",
            "parameters": [
                "eventBus",
                "bpmnRules",
                "modeling"
            ],
            "start_line": 16,
            "end_line": 172,
            "return": true
        },
        "function_10": {
            "signature": "// helpers /////////////////////",
            "content": "function isPointInsideBBox(bbox, point) {\n  var x = point.x,\n      y = point.y;\n\n  return x >= bbox.x &&\n    x <= bbox.x + bbox.width &&\n    y >= bbox.y &&\n    y <= bbox.y + bbox.height;\n}",
            "name": "isPointInsideBBox",
            "parameters": [
                "bbox",
                "point"
            ],
            "start_line": 185,
            "end_line": 193,
            "return": true
        },
        "function_11": {
            "signature": "",
            "content": "function copy(obj) {\n  return assign({}, obj);\n}",
            "name": "copy",
            "parameters": [
                "obj"
            ],
            "start_line": 195,
            "end_line": 197,
            "return": true
        },
        "function_12": {
            "signature": "",
            "content": "function getMid(bounds) {\n\n  return {\n    x: Math.round(bounds.x + bounds.width / 2),\n    y: Math.round(bounds.y + bounds.height / 2)\n  };\n}",
            "name": "getMid",
            "parameters": [
                "bounds"
            ],
            "start_line": 199,
            "end_line": 205,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\EventBasedGatewayBehavior.js": {
        "function_1": {
            "signature": "",
            "content": "export default function EventBasedGatewayBehavior(eventBus, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * Remove existing sequence flows of event-based target before connecting\n   * from event-based gateway.\n   */\n  this.preExecuted('connection.create', function(event) {\n\n    var source = event.context.source,\n        target = event.context.target,\n        existingIncomingConnections = target.incoming.slice();\n\n    if (\n      is(source, 'bpmn:EventBasedGateway') &&\n      target.incoming.length\n    ) {\n\n      existingIncomingConnections.filter(isSequenceFlow)\n        .forEach(function(sequenceFlow) {\n          modeling.removeConnection(sequenceFlow);\n        });\n    }\n  });\n\n  /**\n   *  After replacing shape with event-based gateway, remove incoming sequence\n   *  flows of event-based targets which do not belong to event-based gateway\n   *  source.\n   */\n  this.preExecuted('shape.replace', function(event) {\n\n    var newShape = event.context.newShape,\n        newShapeTargets,\n        newShapeTargetsIncomingSequenceFlows;\n\n    if (!is(newShape, 'bpmn:EventBasedGateway')) {\n      return;\n    }\n\n    newShapeTargets = newShape.outgoing.filter(isSequenceFlow)\n      .map(function(sequenceFlow) {\n        return sequenceFlow.target;\n      });\n\n    newShapeTargetsIncomingSequenceFlows = newShapeTargets.reduce(function(sequenceFlows, target) {\n      var incomingSequenceFlows = target.incoming.filter(isSequenceFlow);\n\n      return sequenceFlows.concat(incomingSequenceFlows);\n    }, []);\n\n    newShapeTargetsIncomingSequenceFlows.forEach(function(sequenceFlow) {\n      if (sequenceFlow.source !== newShape) {\n        modeling.removeConnection(sequenceFlow);\n      }\n    });\n  });\n}",
            "name": "EventBasedGatewayBehavior",
            "parameters": [
                "eventBus",
                "modeling"
            ],
            "start_line": 7,
            "end_line": 65,
            "return": true
        },
        "function_8": {
            "signature": "// helpers //////////////////////",
            "content": "function isSequenceFlow(connection) {\n  return is(connection, 'bpmn:SequenceFlow');\n}",
            "name": "isSequenceFlow",
            "parameters": [
                "connection"
            ],
            "start_line": 78,
            "end_line": 80,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\ImportDockingFix.js": {
        "function_1": {
            "signature": "/**\n* Fix broken dockings after DI imports.\n*\n* @param {EventBus} eventBus\n*/",
            "content": "export default function ImportDockingFix(eventBus) {\n\n  function adjustDocking(startPoint, nextPoint, elementMid) {\n\n    var elementTop = {\n      x: elementMid.x,\n      y: elementMid.y - 50\n    };\n\n    var elementLeft = {\n      x: elementMid.x - 50,\n      y: elementMid.y\n    };\n\n    var verticalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementTop),\n        horizontalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementLeft);\n\n    // original is horizontal or vertical center cross intersection\n    var centerIntersect;\n\n    if (verticalIntersect && horizontalIntersect) {\n      if (getDistance(verticalIntersect, elementMid) > getDistance(horizontalIntersect, elementMid)) {\n        centerIntersect = horizontalIntersect;\n      } else {\n        centerIntersect = verticalIntersect;\n      }\n    } else {\n      centerIntersect = verticalIntersect || horizontalIntersect;\n    }\n\n    startPoint.original = centerIntersect;\n  }\n\n  function fixDockings(connection) {\n    var waypoints = connection.waypoints;\n\n    adjustDocking(\n      waypoints[0],\n      waypoints[1],\n      getMid(connection.source)\n    );\n\n    adjustDocking(\n      waypoints[waypoints.length - 1],\n      waypoints[waypoints.length - 2],\n      getMid(connection.target)\n    );\n  }\n\n  eventBus.on('bpmnElement.added', function(e) {\n\n    var element = e.element;\n\n    if (element.waypoints) {\n      fixDockings(element);\n    }\n  });\n}",
            "name": "ImportDockingFix",
            "parameters": [
                "eventBus"
            ],
            "start_line": 13,
            "end_line": 70,
            "return": false
        },
        "function_5": {
            "signature": "// helpers //////////////////////",
            "content": "function getDistance(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n}",
            "name": "getDistance",
            "parameters": [
                "p1",
                "p2"
            ],
            "start_line": 79,
            "end_line": 81,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\IsHorizontalFix.js": {
        "function_1": {
            "signature": "/**\n* A component that makes sure that each created or updated\n* Pool and Lane is assigned an isHorizontal property set to true.\n*\n* @param {EventBus} eventBus\n*/",
            "content": "export default function IsHorizontalFix(eventBus) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  var elementTypesToUpdate = [\n    'bpmn:Participant',\n    'bpmn:Lane'\n  ];\n\n  this.executed([ 'shape.move', 'shape.create', 'shape.resize' ], function(event) {\n    var bo = getBusinessObject(event.context.shape);\n\n    if (isAny(bo, elementTypesToUpdate) && !bo.di.get('isHorizontal')) {\n      // set attribute directly to avoid modeling#updateProperty side effects\n      bo.di.set('isHorizontal', true);\n    }\n  });\n\n}",
            "name": "IsHorizontalFix",
            "parameters": [
                "eventBus"
            ],
            "start_line": 19,
            "end_line": 37,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\LabelBehavior.js": {
        "function_1": {
            "signature": "/**\n* A component that makes sure that external labels are added\n* together with respective elements and properly updated (DI wise)\n* during move.\n*\n* @param {EventBus} eventBus\n* @param {Modeling} modeling\n* @param {BpmnFactory} bpmnFactory\n* @param {TextRenderer} textRenderer\n*/",
            "content": "export default function LabelBehavior(\n    eventBus, modeling, bpmnFactory,\n    textRenderer) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  // update label if name property was updated\n  this.postExecute('element.updateProperties', function(e) {\n    var context = e.context,\n        element = context.element,\n        properties = context.properties;\n\n    if (NAME_PROPERTY in properties) {\n      modeling.updateLabel(element, properties[NAME_PROPERTY]);\n    }\n\n    if (TEXT_PROPERTY in properties\n        && is(element, 'bpmn:TextAnnotation')) {\n\n      var newBounds = textRenderer.getTextAnnotationBounds(\n        {\n          x: element.x,\n          y: element.y,\n          width: element.width,\n          height: element.height\n        },\n        properties[TEXT_PROPERTY] || ''\n      );\n\n      modeling.updateLabel(element, properties.text, newBounds);\n    }\n  });\n\n  // create label shape after shape/connection was created\n  this.postExecute([ 'shape.create', 'connection.create' ], function(e) {\n    var context = e.context;\n\n    var element = context.shape || context.connection,\n        businessObject = element.businessObject;\n\n    if (!isLabelExternal(element)) {\n      return;\n    }\n\n    // only create label if name\n    if (!businessObject.name) {\n      return;\n    }\n\n    var labelCenter = getExternalLabelMid(element);\n\n    // we don't care about x and y\n    var labelDimensions = textRenderer.getExternalLabelBounds(\n      DEFAULT_LABEL_DIMENSIONS,\n      businessObject.name || ''\n    );\n\n    modeling.createLabel(element, labelCenter, {\n      id: businessObject.id + '_label',\n      businessObject: businessObject,\n      width: labelDimensions.width,\n      height: labelDimensions.height\n    });\n  });\n\n  // update label after label shape was deleted\n  this.postExecute('shape.delete', function(event) {\n    var context = event.context,\n        labelTarget = context.labelTarget,\n        hints = context.hints || {};\n\n    // check if label\n    if (labelTarget && hints.unsetLabel !== false) {\n      modeling.updateLabel(labelTarget, null, null, { removeShape: false });\n    }\n  });\n\n  // update di information on label creation\n  this.postExecute([ 'label.create' ], function(event) {\n\n    var context = event.context,\n        element = context.shape,\n        businessObject,\n        di;\n\n    // we want to trigger on real labels only\n    if (!element.labelTarget) {\n      return;\n    }\n\n    // we want to trigger on BPMN elements only\n    if (!is(element.labelTarget || element, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    businessObject = element.businessObject,\n    di = businessObject.di;\n\n\n    if (!di.label) {\n      di.label = bpmnFactory.create('bpmndi:BPMNLabel', {\n        bounds: bpmnFactory.create('dc:Bounds')\n      });\n    }\n\n    assign(di.label.bounds, {\n      x: element.x,\n      y: element.y,\n      width: element.width,\n      height: element.height\n    });\n  });\n\n  function getVisibleLabelAdjustment(event) {\n\n    var context = event.context,\n        connection = context.connection,\n        label = connection.label,\n        hints = assign({}, context.hints),\n        newWaypoints = context.newWaypoints || connection.waypoints,\n        oldWaypoints = context.oldWaypoints;\n\n\n    if (typeof hints.startChanged === 'undefined') {\n      hints.startChanged = !!hints.connectionStart;\n    }\n\n    if (typeof hints.endChanged === 'undefined') {\n      hints.endChanged = !!hints.connectionEnd;\n    }\n\n    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);\n  }\n\n  this.postExecute([\n    'connection.layout',\n    'connection.updateWaypoints'\n  ], function(event) {\n\n    var label = event.context.connection.label,\n        labelAdjustment;\n\n    if (!label) {\n      return;\n    }\n\n    labelAdjustment = getVisibleLabelAdjustment(event);\n\n    modeling.moveShape(label, labelAdjustment);\n  });\n\n\n  // keep label position on shape replace\n  this.postExecute([ 'shape.replace' ], function(event) {\n    var context = event.context,\n        newShape = context.newShape,\n        oldShape = context.oldShape;\n\n    var businessObject = getBusinessObject(newShape);\n\n    if (businessObject\n      && isLabelExternal(businessObject)\n      && oldShape.label\n      && newShape.label) {\n      newShape.label.x = oldShape.label.x;\n      newShape.label.y = oldShape.label.y;\n    }\n  });\n\n}",
            "name": "LabelBehavior",
            "parameters": [
                "eventBus",
                "modeling",
                "bpmnFactory",
                "textRenderer"
            ],
            "start_line": 41,
            "end_line": 210,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\ModelingFeedback.js": {
        "function_1": {
            "signature": "",
            "content": "export default function ModelingFeedback(eventBus, tooltips, translate) {\n\n  function showError(position, message, timeout) {\n    tooltips.add({\n      position: {\n        x: position.x + 5,\n        y: position.y + 5\n      },\n      type: 'error',\n      timeout: timeout || 2000,\n      html: '<div>' + message + '</div>'\n    });\n  }\n\n  eventBus.on([ 'shape.move.rejected', 'create.rejected' ], function(event) {\n    var context = event.context,\n        shape = context.shape,\n        target = context.target;\n\n    if (is(target, 'bpmn:Collaboration') && is(shape, 'bpmn:FlowNode')) {\n      showError(event, translate(COLLAB_ERR_MSG));\n    }\n  });\n\n  eventBus.on([ 'elements.paste.rejected' ], function(event) {\n    var context = event.context,\n        position = context.position,\n        target = context.target;\n\n    if (is(target, 'bpmn:Collaboration')) {\n      showError(position, translate(COLLAB_ERR_MSG));\n    }\n\n    if (is(target, 'bpmn:Process')) {\n      showError(position, translate(PROCESS_ERR_MSG), 3000);\n    }\n  });\n}",
            "name": "ModelingFeedback",
            "parameters": [
                "eventBus",
                "tooltips",
                "translate"
            ],
            "start_line": 7,
            "end_line": 44,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\RemoveElementBehavior.js": {
        "function_1": {
            "signature": "",
            "content": "export default function RemoveElementBehavior(eventBus, bpmnRules, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * Combine sequence flows when deleting an element\n   * if there is one incoming and one outgoing\n   * sequence flow\n   */\n  this.preExecute('shape.delete', function(e) {\n\n    var shape = e.context.shape;\n\n    // only handle [a] -> [shape] -> [b] patterns\n    if (shape.incoming.length !== 1 || shape.outgoing.length !== 1) {\n      return;\n    }\n\n    var inConnection = shape.incoming[0],\n        outConnection = shape.outgoing[0];\n\n    // only handle sequence flows\n    if (!is(inConnection, 'bpmn:SequenceFlow') || !is(outConnection, 'bpmn:SequenceFlow')) {\n      return;\n    }\n\n    if (bpmnRules.canConnect(inConnection.source, outConnection.target, inConnection)) {\n\n      // compute new, combined waypoints\n      var newWaypoints = getNewWaypoints(inConnection.waypoints, outConnection.waypoints);\n\n      modeling.reconnectEnd(inConnection, outConnection.target, newWaypoints);\n    }\n  });\n\n}",
            "name": "RemoveElementBehavior",
            "parameters": [
                "eventBus",
                "bpmnRules",
                "modeling"
            ],
            "start_line": 10,
            "end_line": 45,
            "return": true
        },
        "function_3": {
            "signature": "// helpers //////////////////////",
            "content": "function getDocking(point) {\n  return point.original || point;\n}",
            "name": "getDocking",
            "parameters": [
                "point"
            ],
            "start_line": 58,
            "end_line": 60,
            "return": true
        },
        "function_4": {
            "signature": "",
            "content": "function getNewWaypoints(inWaypoints, outWaypoints) {\n\n  var intersection = lineIntersect(\n    getDocking(inWaypoints[inWaypoints.length - 2]),\n    getDocking(inWaypoints[inWaypoints.length - 1]),\n    getDocking(outWaypoints[1]),\n    getDocking(outWaypoints[0]));\n\n  if (intersection) {\n    return [].concat(\n      inWaypoints.slice(0, inWaypoints.length - 1),\n      [ intersection ],\n      outWaypoints.slice(1));\n  } else {\n    return [\n      getDocking(inWaypoints[0]),\n      getDocking(outWaypoints[outWaypoints.length - 1])\n    ];\n  }\n}",
            "name": "getNewWaypoints",
            "parameters": [
                "inWaypoints",
                "outWaypoints"
            ],
            "start_line": 63,
            "end_line": 82,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\RemoveParticipantBehavior.js": {
        "function_1": {
            "signature": "/**\n* BPMN specific remove behavior\n*/",
            "content": "export default function RemoveParticipantBehavior(eventBus, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n\n  /**\n   * morph collaboration diagram into process diagram\n   * after the last participant has been removed\n   */\n\n  this.preExecute('shape.delete', function(context) {\n\n    var shape = context.shape,\n        parent = shape.parent;\n\n    // activate the behavior if the shape to be removed\n    // is a participant\n    if (is(shape, 'bpmn:Participant')) {\n      context.collaborationRoot = parent;\n    }\n  }, true);\n\n  this.postExecute('shape.delete', function(context) {\n\n    var collaborationRoot = context.collaborationRoot;\n\n    if (collaborationRoot && !collaborationRoot.businessObject.participants.length) {\n      // replace empty collaboration with process diagram\n      modeling.makeProcess();\n    }\n  }, true);\n\n}",
            "name": "RemoveParticipantBehavior",
            "parameters": [
                "eventBus",
                "modeling"
            ],
            "start_line": 11,
            "end_line": 43,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\ReplaceConnectionBehavior.js": {
        "function_1": {
            "signature": "",
            "content": "export default function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  function fixConnection(connection) {\n\n    var source = connection.source,\n        target = connection.target,\n        parent = connection.parent;\n\n    // do not do anything if connection\n    // is already deleted (may happen due to other\n    // behaviors plugged-in before)\n    if (!parent) {\n      return;\n    }\n\n    var replacementType,\n        remove;\n\n    /**\n     * Check if incoming or outgoing connections\n     * can stay or could be substituted with an\n     * appropriate replacement.\n     *\n     * This holds true for SequenceFlow <> MessageFlow.\n     */\n\n    if (is(connection, 'bpmn:SequenceFlow')) {\n      if (!bpmnRules.canConnectSequenceFlow(source, target)) {\n        remove = true;\n      }\n\n      if (bpmnRules.canConnectMessageFlow(source, target)) {\n        replacementType = 'bpmn:MessageFlow';\n      }\n    }\n\n    // transform message flows into sequence flows, if possible\n\n    if (is(connection, 'bpmn:MessageFlow')) {\n\n      if (!bpmnRules.canConnectMessageFlow(source, target)) {\n        remove = true;\n      }\n\n      if (bpmnRules.canConnectSequenceFlow(source, target)) {\n        replacementType = 'bpmn:SequenceFlow';\n      }\n    }\n\n    if (is(connection, 'bpmn:Association') && !bpmnRules.canConnectAssociation(source, target)) {\n      remove = true;\n    }\n\n\n    // remove invalid connection,\n    // unless it has been removed already\n    if (remove) {\n      modeling.removeConnection(connection);\n    }\n\n    // replace SequenceFlow <> MessageFlow\n\n    if (replacementType) {\n      modeling.connect(source, target, {\n        type: replacementType,\n        waypoints: connection.waypoints.slice()\n      });\n    }\n  }\n\n  this.postExecuted('elements.move', function(context) {\n\n    var closure = context.closure,\n        allConnections = closure.allConnections;\n\n    forEach(allConnections, fixConnection);\n  }, true);\n\n  this.postExecuted([\n    'connection.reconnectStart',\n    'connection.reconnectEnd'\n  ], function(event) {\n\n    var connection = event.context.connection;\n\n    fixConnection(connection);\n  });\n\n  this.postExecuted('element.updateProperties', function(event) {\n    var context = event.context,\n        properties = context.properties,\n        element = context.element,\n        businessObject = element.businessObject,\n        connection;\n\n    // remove condition expression when morphing to default flow\n    if (properties.default) {\n      connection = find(\n        element.outgoing,\n        matchPattern({ id: element.businessObject.default.id })\n      );\n\n      if (connection) {\n        modeling.updateProperties(connection, { conditionExpression: undefined });\n      }\n    }\n\n    // remove default property from source when morphing to conditional flow\n    if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {\n      modeling.updateProperties(element.source, { default: undefined });\n    }\n  });\n}",
            "name": "ReplaceConnectionBehavior",
            "parameters": [
                "eventBus",
                "modeling",
                "bpmnRules"
            ],
            "start_line": 14,
            "end_line": 128,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\ReplaceElementBehaviour.js": {
        "function_1": {
            "signature": "/**\n* Defines the behaviour of what happens to the elements inside a container\n* that morphs into another BPMN element\n*/",
            "content": "export default function ReplaceElementBehaviour(\n    eventBus, bpmnReplace, bpmnRules,\n    elementRegistry, selection, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this._bpmnReplace = bpmnReplace;\n  this._elementRegistry = elementRegistry;\n  this._selection = selection;\n  this._modeling = modeling;\n\n  this.postExecuted([ 'elements.move' ], 500, function(event) {\n\n    var context = event.context,\n        target = context.newParent,\n        newHost = context.newHost,\n        elements = [];\n\n    forEach(context.closure.topLevel, function(topLevelElements) {\n      if (isEventSubProcess(topLevelElements)) {\n        elements = elements.concat(topLevelElements.children);\n      } else {\n        elements = elements.concat(topLevelElements);\n      }\n    });\n\n    // Change target to host when the moving element is a `bpmn:BoundaryEvent`\n    if (elements.length === 1 && newHost) {\n      target = newHost;\n    }\n\n    var canReplace = bpmnRules.canReplace(elements, target);\n\n    if (canReplace) {\n      this.replaceElements(elements, canReplace.replacements, newHost);\n    }\n  }, this);\n\n  // update attachments if the host is replaced\n  this.postExecute([ 'shape.replace' ], 1500, function(e) {\n\n    var context = e.context,\n        oldShape = context.oldShape,\n        newShape = context.newShape,\n        attachers = oldShape.attachers,\n        canReplace;\n\n    if (attachers && attachers.length) {\n      canReplace = bpmnRules.canReplace(attachers, newShape);\n\n      this.replaceElements(attachers, canReplace.replacements);\n    }\n\n  }, this);\n\n  this.postExecuted([ 'shape.replace' ], 1500, function(e) {\n    var context = e.context,\n        oldShape = context.oldShape,\n        newShape = context.newShape;\n\n    modeling.unclaimId(oldShape.businessObject.id, oldShape.businessObject);\n    modeling.updateProperties(newShape, { id: oldShape.id });\n  });\n}",
            "name": "ReplaceElementBehaviour",
            "parameters": [
                "eventBus",
                "bpmnReplace",
                "bpmnRules",
                "elementRegistry",
                "selection",
                "modeling"
            ],
            "start_line": 20,
            "end_line": 83,
            "return": false
        },
        "function_6": {
            "signature": "",
            "content": "ReplaceElementBehaviour.prototype.replaceElements = function(elements, newElements, newHost) {\n  var elementRegistry = this._elementRegistry,\n      bpmnReplace = this._bpmnReplace,\n      selection = this._selection,\n      modeling = this._modeling;\n\n  forEach(newElements, function(replacement) {\n\n    var newElement = {\n      type: replacement.newElementType\n    };\n\n    var oldElement = elementRegistry.get(replacement.oldElementId);\n\n    if (newHost && is(oldElement, 'bpmn:BoundaryEvent')) {\n      modeling.updateAttachment(oldElement, null);\n    }\n\n    var idx = elements.indexOf(oldElement);\n\n    elements[idx] = bpmnReplace.replaceElement(oldElement, newElement, { select: false });\n\n    if (newHost && is(elements[idx], 'bpmn:BoundaryEvent')) {\n      modeling.updateAttachment(elements[idx], newHost);\n    }\n  });\n\n  if (newElements) {\n    selection.select(elements);\n  }\n};",
            "name": "function_6",
            "parameters": [
                "elements",
                "newElements",
                "newHost"
            ],
            "start_line": 88,
            "end_line": 118,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\ResizeLaneBehavior.js": {
        "function_1": {
            "signature": "/**\n* Invoke {@link Modeling#resizeLane} instead of\n* {@link Modeling#resizeShape} when resizing a Lane\n* or Participant shape.\n*/",
            "content": "export default function ResizeLaneBehavior(eventBus, modeling) {\n\n  eventBus.on('resize.start', SLIGHTLY_HIGHER_PRIORITY + 500, function(event) {\n    var context = event.context,\n        shape = context.shape;\n\n    if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {\n\n      // should we resize the opposite lane(s) in\n      // order to compensate for the resize operation?\n      context.balanced = !hasPrimaryModifier(event);\n    }\n  });\n\n  /**\n   * Intercept resize end and call resize lane function instead.\n   */\n  eventBus.on('resize.end', SLIGHTLY_HIGHER_PRIORITY, function(event) {\n    var context = event.context,\n        shape = context.shape,\n        canExecute = context.canExecute,\n        newBounds = context.newBounds;\n\n    if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {\n\n      if (canExecute) {\n        // ensure we have actual pixel values for new bounds\n        // (important when zoom level was > 1 during move)\n        newBounds = roundBounds(newBounds);\n\n        // perform the actual resize\n        modeling.resizeLane(shape, newBounds, context.balanced);\n      }\n\n      // stop propagation\n      return false;\n    }\n  });\n}",
            "name": "ResizeLaneBehavior",
            "parameters": [
                "eventBus",
                "modeling"
            ],
            "start_line": 19,
            "end_line": 57,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\ToggleElementCollapseBehaviour.js": {
        "function_1": {
            "signature": "",
            "content": "export default function ToggleElementCollapseBehaviour(\n    eventBus, elementFactory, modeling,\n    resize) {\n\n  CommandInterceptor.call(this, eventBus);\n\n\n  function hideEmptyLables(children) {\n    if (children.length) {\n      children.forEach(function(child) {\n        if (child.type === 'label' && !child.businessObject.name) {\n          child.hidden = true;\n        }\n      });\n    }\n  }\n\n  function expandedBounds(shape, defaultSize) {\n    var children = shape.children,\n        newBounds = defaultSize,\n        visibleElements,\n        visibleBBox;\n\n    visibleElements = filterVisible(children).concat([ shape ]);\n\n    visibleBBox = computeChildrenBBox(visibleElements);\n\n    if (visibleBBox) {\n      // center to visibleBBox with max(defaultSize, childrenBounds)\n      newBounds.width = Math.max(visibleBBox.width, newBounds.width);\n      newBounds.height = Math.max(visibleBBox.height, newBounds.height);\n\n      newBounds.x = visibleBBox.x + (visibleBBox.width - newBounds.width) / 2;\n      newBounds.y = visibleBBox.y + (visibleBBox.height - newBounds.height) / 2;\n    } else {\n      // center to collapsed shape with defaultSize\n      newBounds.x = shape.x + (shape.width - newBounds.width) / 2;\n      newBounds.y = shape.y + (shape.height - newBounds.height) / 2;\n    }\n\n    return newBounds;\n  }\n\n  function collapsedBounds(shape, defaultSize) {\n\n    return {\n      x: shape.x + (shape.width - defaultSize.width) / 2,\n      y: shape.y + (shape.height - defaultSize.height) / 2,\n      width: defaultSize.width,\n      height: defaultSize.height\n    };\n  }\n\n  this.executed([ 'shape.toggleCollapse' ], LOW_PRIORITY, function(e) {\n\n    var context = e.context,\n        shape = context.shape;\n\n    if (!is(shape, 'bpmn:SubProcess')) {\n      return;\n    }\n\n    if (!shape.collapsed) {\n      // all children got made visible through djs, hide empty labels\n      hideEmptyLables(shape.children);\n\n      // remove collapsed marker\n      getBusinessObject(shape).di.isExpanded = true;\n    } else {\n      // place collapsed marker\n      getBusinessObject(shape).di.isExpanded = false;\n    }\n  });\n\n  this.reverted([ 'shape.toggleCollapse' ], LOW_PRIORITY, function(e) {\n\n    var context = e.context;\n    var shape = context.shape;\n\n\n    // revert removing/placing collapsed marker\n    if (!shape.collapsed) {\n      getBusinessObject(shape).di.isExpanded = true;\n\n    } else {\n      getBusinessObject(shape).di.isExpanded = false;\n    }\n  });\n\n  this.postExecuted([ 'shape.toggleCollapse' ], LOW_PRIORITY, function(e) {\n    var shape = e.context.shape,\n        defaultSize = elementFactory._getDefaultSize(shape),\n        newBounds;\n\n    if (shape.collapsed) {\n\n      // resize to default size of collapsed shapes\n      newBounds = collapsedBounds(shape, defaultSize);\n    } else {\n\n      // resize to bounds of max(visible children, defaultSize)\n      newBounds = expandedBounds(shape, defaultSize);\n    }\n\n    modeling.resizeShape(shape, newBounds, null, {\n      autoResize: shape.collapsed ? false : 'nwse'\n    });\n  });\n\n}",
            "name": "ToggleElementCollapseBehaviour",
            "parameters": [
                "eventBus",
                "elementFactory",
                "modeling",
                "resize"
            ],
            "start_line": 18,
            "end_line": 127,
            "return": true
        },
        "function_9": {
            "signature": "// helpers //////////////////////",
            "content": "function filterVisible(elements) {\n  return elements.filter(function(e) {\n    return !e.hidden;\n  });\n}",
            "name": "filterVisible",
            "parameters": [
                "elements"
            ],
            "start_line": 141,
            "end_line": 145,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\UnclaimIdBehavior.js": {
        "function_1": {
            "signature": "/**\n* Unclaims model IDs on element deletion.\n*\n* @param {EventBus} eventBus\n* @param {Modeling} modeling\n*/",
            "content": "export default function UnclaimIdBehavior(eventBus, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this.preExecute('elements.delete', function(event) {\n    var context = event.context,\n        elements = context.elements;\n\n    forEach(elements, function(element) {\n      modeling.unclaimId(element.businessObject.id, element.businessObject);\n    });\n\n  });\n}",
            "name": "UnclaimIdBehavior",
            "parameters": [
                "eventBus",
                "modeling"
            ],
            "start_line": 16,
            "end_line": 29,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\UnsetDefaultFlowBehavior.js": {
        "function_1": {
            "signature": "/**\n* A behavior that unsets the Default property of\n* sequence flow source on element delete, if the\n* removed element is the Gateway or Task's default flow.\n*\n* @param {EventBus} eventBus\n* @param {Modeling} modeling\n*/",
            "content": "export default function DeleteSequenceFlowBehavior(eventBus, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n\n  this.preExecute('connection.delete', function(event) {\n    var context = event.context,\n        connection = context.connection,\n        source = connection.source;\n\n    if (isDefaultFlow(connection, source)) {\n      modeling.updateProperties(source, {\n        'default': null\n      });\n    }\n  });\n}",
            "name": "DeleteSequenceFlowBehavior",
            "parameters": [
                "eventBus",
                "modeling"
            ],
            "start_line": 19,
            "end_line": 35,
            "return": false
        },
        "function_3": {
            "signature": "// helpers //////////////////////",
            "content": "function isDefaultFlow(connection, source) {\n\n  if (!is(connection, 'bpmn:SequenceFlow')) {\n    return false;\n  }\n\n  var sourceBo = getBusinessObject(source),\n      sequenceFlow = getBusinessObject(connection);\n\n  return sourceBo.get('default') === sequenceFlow;\n}",
            "name": "isDefaultFlow",
            "parameters": [
                "connection",
                "source"
            ],
            "start_line": 47,
            "end_line": 57,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\UpdateFlowNodeRefsBehavior.js": {
        "function_1": {
            "signature": "/**\n* BPMN specific delete lane behavior\n*/",
            "content": "export default function UpdateFlowNodeRefsBehavior(eventBus, modeling, translate) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * Ok, this is it:\n   *\n   * We have to update the Lane#flowNodeRefs _and_\n   * FlowNode#lanes with every FlowNode move/resize and\n   * Lane move/resize.\n   *\n   * We want to group that stuff to recompute containments\n   * as efficient as possible.\n   *\n   * Yea!\n   */\n\n  // the update context\n  var context;\n\n\n  function initContext() {\n    context = context || new UpdateContext();\n    context.enter();\n\n    return context;\n  }\n\n  function getContext() {\n    if (!context) {\n      throw new Error(translate('out of bounds release'));\n    }\n\n    return context;\n  }\n\n  function releaseContext() {\n\n    if (!context) {\n      throw new Error(translate('out of bounds release'));\n    }\n\n    var triggerUpdate = context.leave();\n\n    if (triggerUpdate) {\n      modeling.updateLaneRefs(context.flowNodes, context.lanes);\n\n      context = null;\n    }\n\n    return triggerUpdate;\n  }\n\n\n  var laneRefUpdateEvents = [\n    'spaceTool',\n    'lane.add',\n    'lane.resize',\n    'lane.split',\n    'elements.move',\n    'elements.delete',\n    'shape.create',\n    'shape.delete',\n    'shape.move',\n    'shape.resize'\n  ];\n\n\n  // listen to a lot of stuff to group lane updates\n\n  this.preExecute(laneRefUpdateEvents, HIGH_PRIORITY, function(event) {\n    initContext();\n  });\n\n  this.postExecuted(laneRefUpdateEvents, LOW_PRIORITY, function(event) {\n    releaseContext();\n  });\n\n\n  // Mark flow nodes + lanes that need an update\n\n  this.preExecute([\n    'shape.create',\n    'shape.move',\n    'shape.delete',\n    'shape.resize'\n  ], function(event) {\n\n    var context = event.context,\n        shape = context.shape;\n\n    var updateContext = getContext();\n\n    // no need to update labels\n    if (shape.labelTarget) {\n      return;\n    }\n\n    if (is(shape, 'bpmn:Lane')) {\n      updateContext.addLane(shape);\n    }\n\n    if (is(shape, 'bpmn:FlowNode')) {\n      updateContext.addFlowNode(shape);\n    }\n  });\n}",
            "name": "UpdateFlowNodeRefsBehavior",
            "parameters": [
                "eventBus",
                "modeling",
                "translate"
            ],
            "start_line": 16,
            "end_line": 122,
            "return": true
        },
        "function_8": {
            "signature": "",
            "content": "function UpdateContext() {\n\n  this.flowNodes = [];\n  this.lanes = [];\n\n  this.counter = 0;\n\n  this.addLane = function(lane) {\n    this.lanes.push(lane);\n  };\n\n  this.addFlowNode = function(flowNode) {\n    this.flowNodes.push(flowNode);\n  };\n\n  this.enter = function() {\n    this.counter++;\n  };\n\n  this.leave = function() {\n    this.counter--;\n\n    return !this.counter;\n  };\n}",
            "name": "UpdateContext",
            "parameters": [],
            "start_line": 133,
            "end_line": 157,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\util\\GeometricUtil.js": {
        "function_1": {
            "signature": "/**\n* Returns the length of a vector\n*\n* @param {Vector}\n* @return {Float}\n*/",
            "content": "export function vectorLength(v) {\n  return Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2));\n}",
            "name": "vectorLength",
            "parameters": [
                "v"
            ],
            "start_line": 7,
            "end_line": 9,
            "return": true
        },
        "function_2": {
            "signature": "/**\n* Calculates the angle between a line a the yAxis\n*\n* @param {Array}\n* @return {Float}\n*/",
            "content": "export function getAngle(line) {\n  // return value is between 0, 180 and -180, -0\n  // @janstuemmel: maybe replace return a/b with b/a\n  return Math.atan((line[1].y - line[0].y) / (line[1].x - line[0].x));\n}",
            "name": "getAngle",
            "parameters": [
                "line"
            ],
            "start_line": 18,
            "end_line": 22,
            "return": true
        },
        "function_3": {
            "signature": "/**\n* Rotates a vector by a given angle\n*\n* @param {Vector}\n* @param {Float} Angle in radians\n* @return {Vector}\n*/",
            "content": "export function rotateVector(vector, angle) {\n  return (!angle) ? vector : {\n    x: Math.cos(angle) * vector.x - Math.sin(angle) * vector.y,\n    y: Math.sin(angle) * vector.x + Math.cos(angle) * vector.y\n  };\n}",
            "name": "rotateVector",
            "parameters": [
                "vector",
                "angle"
            ],
            "start_line": 32,
            "end_line": 37,
            "return": true
        },
        "function_4": {
            "signature": "/**\n* Solves a 2D equation system\n* a + r*b = c, where a,b,c are 2D vectors\n*\n* @param {Vector}\n* @param {Vector}\n* @param {Vector}\n* @return {Float}\n*/",
            "content": "function solveLambaSystem(a, b, c) {\n\n  // the 2d system\n  var system = [\n    { n: a[0] - c[0], lambda: b[0] },\n    { n: a[1] - c[1], lambda: b[1] }\n  ];\n\n  // solve\n  var n = system[0].n * b[0] + system[1].n * b[1],\n      l = system[0].lambda * b[0] + system[1].lambda * b[1];\n\n  return -n/l;\n}",
            "name": "solveLambaSystem",
            "parameters": [
                "a",
                "b",
                "c"
            ],
            "start_line": 49,
            "end_line": 62,
            "return": true
        },
        "function_5": {
            "signature": "/**\n* Position of perpendicular foot\n*\n* @param {Point}\n* @param [ {Point}, {Point} ] line defined throug two points\n* @return {Point} the perpendicular foot position\n*/",
            "content": "export function perpendicularFoot(point, line) {\n\n  var a = line[0], b = line[1];\n\n  // relative position of b from a\n  var bd = { x: b.x - a.x, y: b.y - a.y };\n\n  // solve equation system to the parametrized vectors param real value\n  var r = solveLambaSystem([ a.x, a.y ], [ bd.x, bd.y ], [ point.x, point.y ]);\n\n  return { x: a.x + r*bd.x, y: a.y + r*bd.y };\n}",
            "name": "perpendicularFoot",
            "parameters": [
                "point",
                "line"
            ],
            "start_line": 72,
            "end_line": 83,
            "return": true
        },
        "function_6": {
            "signature": "/**\n* Calculates the distance between a point and a line\n*\n* @param {Point}\n* @param [ {Point}, {Point} ] line defined throug two points\n* @return {Float} distance\n*/",
            "content": "export function getDistancePointLine(point, line) {\n\n  var pfPoint = perpendicularFoot(point, line);\n\n  // distance vector\n  var connectionVector = {\n    x: pfPoint.x - point.x,\n    y: pfPoint.y - point.y\n  };\n\n  return vectorLength(connectionVector);\n}",
            "name": "getDistancePointLine",
            "parameters": [
                "point",
                "line"
            ],
            "start_line": 93,
            "end_line": 104,
            "return": true
        },
        "function_7": {
            "signature": "/**\n* Calculates the distance between two points\n*\n* @param {Point}\n* @param {Point}\n* @return {Float} distance\n*/",
            "content": "export function getDistancePointPoint(point1, point2) {\n\n  return vectorLength({\n    x: point1.x - point2.x,\n    y: point1.y - point2.y\n  });\n}",
            "name": "getDistancePointPoint",
            "parameters": [
                "point1",
                "point2"
            ],
            "start_line": 114,
            "end_line": 120,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\util\\LabelLayoutUtil.js": {
        "function_1": {
            "signature": "",
            "content": "export function findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {\n\n  var index = attachment.segmentIndex;\n\n  var offset = newWaypoints.length - oldWaypoints.length;\n\n  // segmentMove happend\n  if (hints.segmentMove) {\n\n    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,\n        newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;\n\n    // if label was on moved segment return new segment index\n    if (index === oldSegmentStartIndex) {\n      return newSegmentStartIndex;\n    }\n\n    // label is after new segment index\n    if (index >= newSegmentStartIndex) {\n      return (index+offset < newSegmentStartIndex) ? newSegmentStartIndex : index+offset;\n    }\n\n    // if label is before new segment index\n    return index;\n  }\n\n  // bendpointMove happend\n  if (hints.bendpointMove) {\n\n    var insert = hints.bendpointMove.insert,\n        bendpointIndex = hints.bendpointMove.bendpointIndex,\n        newIndex;\n\n    // waypoints length didnt change\n    if (offset === 0) {\n      return index;\n    }\n\n    // label behind new/removed bendpoint\n    if (index >= bendpointIndex) {\n      newIndex = insert ? index + 1 : index - 1;\n    }\n\n    // label before new/removed bendpoint\n    if (index < bendpointIndex) {\n\n      newIndex = index;\n\n      // decide label should take right or left segment\n      if (insert && attachment.type !== 'bendpoint' && bendpointIndex-1 === index) {\n\n        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);\n\n        if (rel < attachment.relativeLocation) {\n          newIndex++;\n        }\n      }\n    }\n\n    return newIndex;\n  }\n\n  // start/end changed\n  if (offset === 0) {\n    return index;\n  }\n\n  if (hints.connectionStart) {\n    return (index === 0) ? 0 : null;\n  }\n\n  if (hints.connectionEnd) {\n    return (index === oldWaypoints.length - 2) ? newWaypoints.length - 2 : null;\n  }\n\n  // if nothing fits, return null\n  return null;\n}",
            "name": "findNewLabelLineStartIndex",
            "parameters": [
                "oldWaypoints",
                "newWaypoints",
                "attachment",
                "hints"
            ],
            "start_line": 16,
            "end_line": 93,
            "return": true
        },
        "function_2": {
            "signature": "/**\n* Calculate the required adjustment (move delta) for the given label\n* after the connection waypoints got updated.\n*\n* @param {djs.model.Label} label\n* @param {Array<Point>} newWaypoints\n* @param {Array<Point>} oldWaypoints\n* @param {Object} hints\n*\n* @return {Point} delta\n*/",
            "content": "export function getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {\n\n  var x = 0,\n      y = 0;\n\n  var labelPosition = getLabelMid(label);\n\n  // get closest attachment\n  var attachment = getAttachment(labelPosition, oldWaypoints),\n      oldLabelLineIndex = attachment.segmentIndex,\n      newLabelLineIndex = findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);\n\n  if (newLabelLineIndex === null) {\n    return { x: x, y: y };\n  }\n\n  // should never happen\n  // TODO(@janstuemmel): throw an error here when connectionSegmentMove is refactored\n  if (newLabelLineIndex < 0 ||\n      newLabelLineIndex > newWaypoints.length - 2) {\n    return { x: x, y: y };\n  }\n\n  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),\n      newLabelLine = getLine(newWaypoints, newLabelLineIndex),\n      oldFoot = attachment.position;\n\n  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),\n      angleDelta = getAngleDelta(oldLabelLine, newLabelLine);\n\n  // special rule if label on bendpoint\n  if (attachment.type === 'bendpoint') {\n\n    var offset = newWaypoints.length - oldWaypoints.length,\n        oldBendpointIndex = attachment.bendpointIndex,\n        oldBendpoint = oldWaypoints[oldBendpointIndex];\n\n    // bendpoint position hasnt changed, return same position\n    if (newWaypoints.indexOf(oldBendpoint) !== -1) {\n      return { x: x, y: y };\n    }\n\n    // new bendpoint and old bendpoint have same index, then just return the offset\n    if (offset === 0) {\n      var newBendpoint = newWaypoints[oldBendpointIndex];\n\n      return {\n        x: newBendpoint.x - attachment.position.x,\n        y: newBendpoint.y - attachment.position.y\n      };\n    }\n\n    // if bendpoints get removed\n    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {\n      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);\n    }\n  }\n\n  var newFoot = {\n    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,\n    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y\n  };\n\n  // the rotated vector to label\n  var newLabelVector = rotateVector({\n    x: labelPosition.x - oldFoot.x,\n    y: labelPosition.y - oldFoot.y\n  }, angleDelta);\n\n  // the new relative position\n  x = newFoot.x + newLabelVector.x - labelPosition.x;\n  y = newFoot.y + newLabelVector.y - labelPosition.y;\n\n  return roundPoint({\n    x: x,\n    y: y\n  });\n}",
            "name": "getLabelAdjustment",
            "parameters": [
                "label",
                "newWaypoints",
                "oldWaypoints",
                "hints"
            ],
            "start_line": 107,
            "end_line": 184,
            "return": true
        },
        "function_3": {
            "signature": "// HELPERS //////////////////////",
            "content": "function relativePositionMidWaypoint(waypoints, idx) {\n\n  var distanceSegment1 = getDistancePointPoint(waypoints[idx-1], waypoints[idx]),\n      distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx+1]);\n\n  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);\n\n  return relativePosition;\n}",
            "name": "relativePositionMidWaypoint",
            "parameters": [
                "waypoints",
                "idx"
            ],
            "start_line": 189,
            "end_line": 197,
            "return": true
        },
        "function_4": {
            "signature": "",
            "content": "function getLabelMid(label) {\n  return {\n    x: label.x + label.width / 2,\n    y: label.y + label.height / 2\n  };\n}",
            "name": "getLabelMid",
            "parameters": [
                "label"
            ],
            "start_line": 199,
            "end_line": 204,
            "return": true
        },
        "function_5": {
            "signature": "",
            "content": "function getAngleDelta(l1, l2) {\n  var a1 = getAngle(l1),\n      a2 = getAngle(l2);\n  return a2 - a1;\n}",
            "name": "getAngleDelta",
            "parameters": [
                "l1",
                "l2"
            ],
            "start_line": 206,
            "end_line": 210,
            "return": true
        },
        "function_6": {
            "signature": "",
            "content": "function getLine(waypoints, idx) {\n  return [ waypoints[idx], waypoints[idx+1] ];\n}",
            "name": "getLine",
            "parameters": [
                "waypoints",
                "idx"
            ],
            "start_line": 212,
            "end_line": 214,
            "return": true
        },
        "function_7": {
            "signature": "",
            "content": "function getRelativeFootPosition(line, foot) {\n\n  var length = getDistancePointPoint(line[0], line[1]),\n      lengthToFoot = getDistancePointPoint(line[0], foot);\n\n  return length === 0 ? 0 : lengthToFoot / length;\n}",
            "name": "getRelativeFootPosition",
            "parameters": [
                "line",
                "foot"
            ],
            "start_line": 216,
            "end_line": 222,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\util\\LineAttachmentUtil.js": {
        "function_1": {
            "signature": "/**\n* Calculate the square (power to two) of a number.\n*\n* @param {Number} n\n*\n* @return {Number}\n*/",
            "content": "function sq(n) {\n  return Math.pow(n, 2);\n}",
            "name": "sq",
            "parameters": [
                "n"
            ],
            "start_line": 13,
            "end_line": 15,
            "return": true
        },
        "function_2": {
            "signature": "/**\n* Get distance between two points.\n*\n* @param {Point} p1\n* @param {Point} p2\n*\n* @return {Number}\n*/",
            "content": "function getDistance(p1, p2) {\n  return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));\n}",
            "name": "getDistance",
            "parameters": [
                "p1",
                "p2"
            ],
            "start_line": 25,
            "end_line": 27,
            "return": true
        },
        "function_3": {
            "signature": "/**\n* Return the attachment of the given point on the specified line.\n*\n* The attachment is either a bendpoint (attached to the given point)\n* or segment (attached to a location on a line segment) attachment:\n*\n* ```javascript\n* var pointAttachment = {\n*   type: 'bendpoint',\n*   bendpointIndex: 3,\n*   position: { x: 10, y: 10 } // the attach point on the line\n* };\n*\n* var segmentAttachment = {\n*   type: 'segment',\n*   segmentIndex: 2,\n*   relativeLocation: 0.31, // attach point location between 0 (at start) and 1 (at end)\n*   position: { x: 10, y: 10 } // the attach point on the line\n* };\n* ```\n*\n* @param {Point} point\n* @param {Array<Point>} line\n*\n* @return {Object} attachment\n*/",
            "content": "export function getAttachment(point, line) {\n\n  var idx = 0,\n      segmentStart,\n      segmentEnd,\n      segmentStartDistance,\n      segmentEndDistance,\n      attachmentPosition,\n      minDistance,\n      intersections,\n      attachment,\n      attachmentDistance,\n      closestAttachmentDistance,\n      closestAttachment;\n\n  for (idx = 0; idx < line.length - 1; idx++) {\n\n    segmentStart = line[idx];\n    segmentEnd = line[idx + 1];\n\n    if (pointsEqual(segmentStart, segmentEnd)) {\n      intersections = [ segmentStart ];\n    } else {\n      segmentStartDistance = getDistance(point, segmentStart);\n      segmentEndDistance = getDistance(point, segmentEnd);\n\n      minDistance = min(segmentStartDistance, segmentEndDistance);\n\n      intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);\n    }\n\n    if (intersections.length < 1) {\n      throw new Error('expected between [1, 2] circle -> line intersections');\n    }\n\n    // one intersection -> bendpoint attachment\n    if (intersections.length === 1) {\n      attachment = {\n        type: 'bendpoint',\n        position: intersections[0],\n        segmentIndex: idx,\n        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1\n      };\n    }\n\n    // two intersections -> segment attachment\n    if (intersections.length === 2) {\n\n      attachmentPosition = mid(intersections[0], intersections[1]);\n\n      attachment = {\n        type: 'segment',\n        position: attachmentPosition,\n        segmentIndex: idx,\n        relativeLocation: getDistance(segmentStart, attachmentPosition) / getDistance(segmentStart, segmentEnd)\n      };\n    }\n\n    attachmentDistance = getDistance(attachment.position, point);\n\n    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {\n      closestAttachment = attachment;\n      closestAttachmentDistance = attachmentDistance;\n    }\n  }\n\n  return closestAttachment;\n}",
            "name": "getAttachment",
            "parameters": [
                "point",
                "line"
            ],
            "start_line": 55,
            "end_line": 122,
            "return": true
        },
        "function_4": {
            "signature": "/**\n* Gets the intersection between a circle and a line segment.\n*\n* @param {Point} s1 segment start\n* @param {Point} s2 segment end\n* @param {Point} cc circle center\n* @param {Number} cr circle radius\n*\n* @return {Array<Point>} intersections\n*/",
            "content": "function getCircleSegmentIntersections(s1, s2, cc, cr) {\n\n  var baX = s2.x - s1.x;\n  var baY = s2.y - s1.y;\n  var caX = cc.x - s1.x;\n  var caY = cc.y - s1.y;\n\n  var a = baX * baX + baY * baY;\n  var bBy2 = baX * caX + baY * caY;\n  var c = caX * caX + caY * caY - cr * cr;\n\n  var pBy2 = bBy2 / a;\n  var q = c / a;\n\n  var disc = pBy2 * pBy2 - q;\n\n  // check against negative value to work around\n  // negative, very close to zero results (-4e-15)\n  // being produced in some environments\n  if (disc < 0 && disc > -0.000001) {\n    disc = 0;\n  }\n\n  if (disc < 0) {\n    return [];\n  }\n\n  // if disc == 0 ... dealt with later\n  var tmpSqrt = sqrt(disc);\n  var abScalingFactor1 = -pBy2 + tmpSqrt;\n  var abScalingFactor2 = -pBy2 - tmpSqrt;\n\n  var i1 = {\n    x: s1.x - baX * abScalingFactor1,\n    y: s1.y - baY * abScalingFactor1\n  };\n\n  if (disc === 0) { // abScalingFactor1 == abScalingFactor2\n    return [ i1 ];\n  }\n\n  var i2 = {\n    x: s1.x - baX * abScalingFactor2,\n    y: s1.y - baY * abScalingFactor2\n  };\n\n  // return only points on line segment\n  return [ i1, i2 ].filter(function(p) {\n    return isPointInSegment(p, s1, s2);\n  });\n}",
            "name": "getCircleSegmentIntersections",
            "parameters": [
                "s1",
                "s2",
                "cc",
                "cr"
            ],
            "start_line": 134,
            "end_line": 184,
            "return": true
        },
        "function_6": {
            "signature": "",
            "content": "function isPointInSegment(p, segmentStart, segmentEnd) {\n  return (\n    fenced(p.x, segmentStart.x, segmentEnd.x) &&\n    fenced(p.y, segmentStart.y, segmentEnd.y)\n  );\n}",
            "name": "isPointInSegment",
            "parameters": [
                "p",
                "segmentStart",
                "segmentEnd"
            ],
            "start_line": 187,
            "end_line": 192,
            "return": true
        },
        "function_7": {
            "signature": "",
            "content": "function fenced(n, rangeStart, rangeEnd) {\n\n  // use matching threshold to work around\n  // precisison errors in intersection computation\n\n  return (\n    n >= min(rangeStart, rangeEnd) - EQUAL_THRESHOLD &&\n    n <= max(rangeStart, rangeEnd) + EQUAL_THRESHOLD\n  );\n}",
            "name": "fenced",
            "parameters": [
                "n",
                "rangeStart",
                "rangeEnd"
            ],
            "start_line": 194,
            "end_line": 203,
            "return": true
        },
        "function_8": {
            "signature": "/**\n* Calculate mid of two points.\n*\n* @param {Point} p1\n* @param {Point} p2\n*\n* @return {Point}\n*/",
            "content": "function mid(p1, p2) {\n\n  return {\n    x: (p1.x + p2.x) / 2,\n    y: (p1.y + p2.y) / 2\n  };\n}",
            "name": "mid",
            "parameters": [
                "p1",
                "p2"
            ],
            "start_line": 213,
            "end_line": 219,
            "return": true
        },
        "function_9": {
            "signature": "",
            "content": "function pointsEqual(p1, p2) {\n\n  return (\n    abs(p1.x - p2.x) <= EQUAL_THRESHOLD &&\n    abs(p1.y - p2.y) <= EQUAL_THRESHOLD\n  );\n}",
            "name": "pointsEqual",
            "parameters": [
                "p1",
                "p2"
            ],
            "start_line": 223,
            "end_line": 229,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\behavior\\util\\LineIntersect.js": {
        "function_1": {
            "signature": "/**\n* Returns the intersection between two line segments a and b.\n*\n* @param {Point} l1s\n* @param {Point} l1e\n* @param {Point} l2s\n* @param {Point} l2e\n*\n* @return {Point}\n*/",
            "content": "export default function lineIntersect(l1s, l1e, l2s, l2e) {\n  // if the lines intersect, the result contains the x and y of the\n  // intersection (treating the lines as infinite) and booleans for\n  // whether line segment 1 or line segment 2 contain the point\n  var denominator, a, b, c, numerator;\n\n  denominator = ((l2e.y - l2s.y) * (l1e.x - l1s.x)) - ((l2e.x - l2s.x) * (l1e.y - l1s.y));\n\n  if (denominator == 0) {\n    return null;\n  }\n\n  a = l1s.y - l2s.y;\n  b = l1s.x - l2s.x;\n  numerator = ((l2e.x - l2s.x) * a) - ((l2e.y - l2s.y) * b);\n\n  c = numerator / denominator;\n\n  // if we cast these lines infinitely in\n  // both directions, they intersect here\n  return {\n    x: Math.round(l1s.x + (c * (l1e.x - l1s.x))),\n    y: Math.round(l1s.y + (c * (l1e.y - l1s.y)))\n  };\n}",
            "name": "lineIntersect",
            "parameters": [
                "l1s",
                "l1e",
                "l2s",
                "l2e"
            ],
            "start_line": 11,
            "end_line": 35,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\cmd\\AddLaneHandler.js": {
        "function_1": {
            "signature": "/**\n* A handler that allows us to add a new lane\n* above or below an existing one.\n*\n* @param {Modeling} modeling\n*/",
            "content": "export default function AddLaneHandler(modeling, spaceTool) {\n  this._modeling = modeling;\n  this._spaceTool = spaceTool;\n}",
            "name": "AddLaneHandler",
            "parameters": [
                "modeling",
                "spaceTool"
            ],
            "start_line": 22,
            "end_line": 25,
            "return": false
        },
        "function_2": {
            "signature": "",
            "content": "AddLaneHandler.prototype.preExecute = function(context) {\n\n  var spaceTool = this._spaceTool,\n      modeling = this._modeling;\n\n  var shape = context.shape,\n      location = context.location;\n\n  var lanesRoot = getLanesRoot(shape);\n\n  var isRoot = lanesRoot === shape,\n      laneParent = isRoot ? shape : shape.parent;\n\n  var existingChildLanes = getChildLanes(laneParent);\n\n  // (0) add a lane if we currently got none and are adding to root\n  if (!existingChildLanes.length) {\n    modeling.createShape({ type: 'bpmn:Lane' }, {\n      x: shape.x + LANE_INDENTATION,\n      y: shape.y,\n      width: shape.width - LANE_INDENTATION,\n      height: shape.height\n    }, laneParent);\n  }\n\n  // (1) collect affected elements to create necessary space\n  var allAffected = [];\n\n  eachElement(lanesRoot, function(element) {\n    allAffected.push(element);\n\n    if (element === shape) {\n      return [];\n    }\n\n    return filter(element.children, function(c) {\n      return c !== shape;\n    });\n  });\n\n  var offset = location === 'top' ? -120 : 120,\n      lanePosition = location === 'top' ? shape.y : shape.y + shape.height,\n      spacePos = lanePosition + (location === 'top' ? 10 : -10),\n      direction = location === 'top' ? 'n' : 's';\n\n  var adjustments = spaceTool.calculateAdjustments(allAffected, 'y', offset, spacePos);\n\n  spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: offset }, direction);\n\n  // (2) create new lane at open space\n  context.newLane = modeling.createShape({ type: 'bpmn:Lane' }, {\n    x: shape.x + (isRoot ? LANE_INDENTATION : 0),\n    y: lanePosition - (location === 'top' ? 120 : 0),\n    width: shape.width - (isRoot ? LANE_INDENTATION : 0),\n    height: 120\n  }, laneParent);\n};",
            "name": "function_2",
            "parameters": [
                "context"
            ],
            "start_line": 33,
            "end_line": 89,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\cmd\\IdClaimHandler.js": {
        "function_1": {
            "signature": "",
            "content": "export default function IdClaimHandler(moddle) {\n  this._moddle = moddle;\n}",
            "name": "IdClaimHandler",
            "parameters": [
                "moddle"
            ],
            "start_line": 1,
            "end_line": 3,
            "return": false
        },
        "function_2": {
            "signature": "",
            "content": "IdClaimHandler.prototype.execute = function(context) {\n  var ids = this._moddle.ids,\n      id = context.id,\n      element = context.element,\n      claiming = context.claiming;\n\n  if (claiming) {\n    ids.claim(id, element);\n  } else {\n    ids.unclaim(id);\n  }\n};",
            "name": "function_2",
            "parameters": [
                "context"
            ],
            "start_line": 8,
            "end_line": 19,
            "return": false
        },
        "function_3": {
            "signature": "/**\n* Command revert implementation.\n*/",
            "content": "IdClaimHandler.prototype.revert = function(context) {\n  var ids = this._moddle.ids,\n      id = context.id,\n      element = context.element,\n      claiming = context.claiming;\n\n  if (claiming) {\n    ids.unclaim(id);\n  } else {\n    ids.claim(id, element);\n  }\n};",
            "name": "function_3",
            "parameters": [
                "context"
            ],
            "start_line": 24,
            "end_line": 35,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\cmd\\ResizeLaneHandler.js": {
        "function_1": {
            "signature": "/**\n* A handler that resizes a lane.\n*\n* @param {Modeling} modeling\n*/",
            "content": "export default function ResizeLaneHandler(modeling, spaceTool) {\n  this._modeling = modeling;\n  this._spaceTool = spaceTool;\n}",
            "name": "ResizeLaneHandler",
            "parameters": [
                "modeling",
                "spaceTool"
            ],
            "start_line": 26,
            "end_line": 29,
            "return": false
        },
        "function_2": {
            "signature": "",
            "content": "ResizeLaneHandler.prototype.preExecute = function(context) {\n\n  var shape = context.shape,\n      newBounds = context.newBounds,\n      balanced = context.balanced;\n\n  if (balanced !== false) {\n    this.resizeBalanced(shape, newBounds);\n  } else {\n    this.resizeSpace(shape, newBounds);\n  }\n};",
            "name": "function_2",
            "parameters": [
                "context"
            ],
            "start_line": 37,
            "end_line": 48,
            "return": false
        },
        "function_3": {
            "signature": "/**\n* Resize balanced, adjusting next / previous lane sizes.\n*\n* @param {djs.model.Shape} shape\n* @param {Bounds} newBounds\n*/",
            "content": "ResizeLaneHandler.prototype.resizeBalanced = function(shape, newBounds) {\n\n  var modeling = this._modeling;\n\n  var resizeNeeded = computeLanesResize(shape, newBounds);\n\n  // resize the lane\n  modeling.resizeShape(shape, newBounds);\n\n  // resize other lanes as needed\n  resizeNeeded.forEach(function(r) {\n    modeling.resizeShape(r.shape, r.newBounds);\n  });\n};",
            "name": "function_3",
            "parameters": [
                "shape",
                "newBounds"
            ],
            "start_line": 57,
            "end_line": 70,
            "return": false
        },
        "function_5": {
            "signature": "/**\n* Resize, making actual space and moving below / above elements.\n*\n* @param {djs.model.Shape} shape\n* @param {Bounds} newBounds\n*/",
            "content": "ResizeLaneHandler.prototype.resizeSpace = function(shape, newBounds) {\n  var spaceTool = this._spaceTool;\n\n  var shapeTrbl = asTRBL(shape),\n      newTrbl = asTRBL(newBounds);\n\n  var trblDiff = substractTRBL(newTrbl, shapeTrbl);\n\n  var lanesRoot = getLanesRoot(shape);\n\n  var allAffected = [],\n      allLanes = [];\n\n  eachElement(lanesRoot, function(element) {\n    allAffected.push(element);\n\n    if (is(element, 'bpmn:Lane') || is(element, 'bpmn:Participant')) {\n      allLanes.push(element);\n    }\n\n    return element.children;\n  });\n\n  var change,\n      spacePos,\n      direction,\n      offset,\n      adjustments;\n\n  if (trblDiff.bottom || trblDiff.top) {\n\n    change = trblDiff.bottom || trblDiff.top;\n    spacePos = shape.y + (trblDiff.bottom ? shape.height : 0) + (trblDiff.bottom ? -10 : 10);\n    direction = trblDiff.bottom ? 's' : 'n';\n\n    offset = trblDiff.top > 0 || trblDiff.bottom < 0 ? -change : change;\n\n    adjustments = spaceTool.calculateAdjustments(allAffected, 'y', offset, spacePos);\n\n    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: change }, direction);\n  }\n\n\n  if (trblDiff.left || trblDiff.right) {\n\n    change = trblDiff.right || trblDiff.left;\n    spacePos = shape.x + (trblDiff.right ? shape.width : 0) + (trblDiff.right ? -10 : 100);\n    direction = trblDiff.right ? 'e' : 'w';\n\n    offset = trblDiff.left > 0 || trblDiff.right < 0 ? -change : change;\n\n    adjustments = spaceTool.calculateAdjustments(allLanes, 'x', offset, spacePos);\n\n    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: change, y: 0 }, direction);\n  }\n};",
            "name": "function_5",
            "parameters": [
                "shape",
                "newBounds"
            ],
            "start_line": 79,
            "end_line": 134,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\cmd\\SetColorHandler.js": {
        "function_1": {
            "signature": "",
            "content": "export default function SetColorHandler(commandStack) {\n  this._commandStack = commandStack;\n}",
            "name": "SetColorHandler",
            "parameters": [
                "commandStack"
            ],
            "start_line": 13,
            "end_line": 15,
            "return": false
        },
        "function_2": {
            "signature": "",
            "content": "SetColorHandler.prototype.postExecute = function(context) {\n  var elements = context.elements,\n      colors = context.colors || DEFAULT_COLORS;\n\n  var self = this;\n\n  var di = {};\n\n  if ('fill' in colors) {\n    assign(di, { fill: colors.fill });\n  }\n\n  if ('stroke' in colors) {\n    assign(di, { stroke: colors.stroke });\n  }\n\n  forEach(elements, function(element) {\n\n    self._commandStack.execute('element.updateProperties', {\n      element: element,\n      properties: {\n        di: di\n      }\n    });\n  });\n\n};",
            "name": "function_2",
            "parameters": [
                "context"
            ],
            "start_line": 22,
            "end_line": 48,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\cmd\\SplitLaneHandler.js": {
        "function_1": {
            "signature": "/**\n* A handler that splits a lane into a number of sub-lanes,\n* creating new sub lanes, if neccessary.\n*\n* @param {Modeling} modeling\n*/",
            "content": "export default function SplitLaneHandler(modeling, translate) {\n  this._modeling = modeling;\n  this._translate = translate;\n}",
            "name": "SplitLaneHandler",
            "parameters": [
                "modeling",
                "translate"
            ],
            "start_line": 13,
            "end_line": 16,
            "return": false
        },
        "function_2": {
            "signature": "",
            "content": "SplitLaneHandler.prototype.preExecute = function(context) {\n\n  var modeling = this._modeling,\n      translate = this._translate;\n\n  var shape = context.shape,\n      newLanesCount = context.count;\n\n  var childLanes = getChildLanes(shape),\n      existingLanesCount = childLanes.length;\n\n  if (existingLanesCount > newLanesCount) {\n    throw new Error(translate('more than {count} child lanes', { count: newLanesCount }));\n  }\n\n  var newLanesHeight = Math.round(shape.height / newLanesCount);\n\n  // Iterate from top to bottom in child lane order,\n  // resizing existing lanes and creating new ones\n  // so that they split the parent proportionally.\n  //\n  // Due to rounding related errors, the bottom lane\n  // needs to take up all the remaining space.\n  var laneY,\n      laneHeight,\n      laneBounds,\n      newLaneAttrs,\n      idx;\n\n  for (idx = 0; idx < newLanesCount; idx++) {\n\n    laneY = shape.y + idx * newLanesHeight;\n\n    // if bottom lane\n    if (idx === newLanesCount - 1) {\n      laneHeight = shape.height - (newLanesHeight * idx);\n    } else {\n      laneHeight = newLanesHeight;\n    }\n\n    laneBounds = {\n      x: shape.x + LANE_INDENTATION,\n      y: laneY,\n      width: shape.width - LANE_INDENTATION,\n      height: laneHeight\n    };\n\n    if (idx < existingLanesCount) {\n      // resize existing lane\n      modeling.resizeShape(childLanes[idx], laneBounds);\n    } else {\n      // create a new lane at position\n      newLaneAttrs = {\n        type: 'bpmn:Lane'\n      };\n\n      modeling.createShape(newLaneAttrs, laneBounds, shape);\n    }\n  }\n};",
            "name": "function_2",
            "parameters": [
                "context"
            ],
            "start_line": 24,
            "end_line": 83,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\cmd\\UpdateCanvasRootHandler.js": {
        "function_1": {
            "signature": "",
            "content": "export default function UpdateCanvasRootHandler(canvas, modeling) {\n  this._canvas = canvas;\n  this._modeling = modeling;\n}",
            "name": "UpdateCanvasRootHandler",
            "parameters": [
                "canvas",
                "modeling"
            ],
            "start_line": 7,
            "end_line": 10,
            "return": false
        },
        "function_2": {
            "signature": "",
            "content": "UpdateCanvasRootHandler.prototype.execute = function(context) {\n\n  var canvas = this._canvas;\n\n  var newRoot = context.newRoot,\n      newRootBusinessObject = newRoot.businessObject,\n      oldRoot = canvas.getRootElement(),\n      oldRootBusinessObject = oldRoot.businessObject,\n      bpmnDefinitions = oldRootBusinessObject.$parent,\n      diPlane = oldRootBusinessObject.di;\n\n  // (1) replace process old <> new root\n  canvas.setRootElement(newRoot, true);\n\n  // (2) update root elements\n  collectionAdd(bpmnDefinitions.rootElements, newRootBusinessObject);\n  newRootBusinessObject.$parent = bpmnDefinitions;\n\n  collectionRemove(bpmnDefinitions.rootElements, oldRootBusinessObject);\n  oldRootBusinessObject.$parent = null;\n\n  // (3) wire di\n  oldRootBusinessObject.di = null;\n\n  diPlane.bpmnElement = newRootBusinessObject;\n  newRootBusinessObject.di = diPlane;\n\n  context.oldRoot = oldRoot;\n\n  // TODO(nikku): return changed elements?\n  // return [ newRoot, oldRoot ];\n};",
            "name": "function_2",
            "parameters": [
                "context"
            ],
            "start_line": 18,
            "end_line": 49,
            "return": false
        },
        "function_3": {
            "signature": "",
            "content": "UpdateCanvasRootHandler.prototype.revert = function(context) {\n\n  var canvas = this._canvas;\n\n  var newRoot = context.newRoot,\n      newRootBusinessObject = newRoot.businessObject,\n      oldRoot = context.oldRoot,\n      oldRootBusinessObject = oldRoot.businessObject,\n      bpmnDefinitions = newRootBusinessObject.$parent,\n      diPlane = newRootBusinessObject.di;\n\n  // (1) replace process old <> new root\n  canvas.setRootElement(oldRoot, true);\n\n  // (2) update root elements\n  collectionRemove(bpmnDefinitions.rootElements, newRootBusinessObject);\n  newRootBusinessObject.$parent = null;\n\n  collectionAdd(bpmnDefinitions.rootElements, oldRootBusinessObject);\n  oldRootBusinessObject.$parent = bpmnDefinitions;\n\n  // (3) wire di\n  newRootBusinessObject.di = null;\n\n  diPlane.bpmnElement = oldRootBusinessObject;\n  oldRootBusinessObject.di = diPlane;\n\n  // TODO(nikku): return changed elements?\n  // return [ newRoot, oldRoot ];\n};",
            "name": "function_3",
            "parameters": [
                "context"
            ],
            "start_line": 52,
            "end_line": 81,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\cmd\\UpdateFlowNodeRefsHandler.js": {
        "function_1": {
            "signature": "/**\n* A handler that updates lane refs on changed elements\n*/",
            "content": "export default function UpdateFlowNodeRefsHandler(elementRegistry) {\n  this._elementRegistry = elementRegistry;\n}",
            "name": "UpdateFlowNodeRefsHandler",
            "parameters": [
                "elementRegistry"
            ],
            "start_line": 26,
            "end_line": 28,
            "return": false
        },
        "function_2": {
            "signature": "",
            "content": "UpdateFlowNodeRefsHandler.prototype.computeUpdates = function(flowNodeShapes, laneShapes) {\n\n  var handledNodes = {};\n\n  var updates = [];\n\n  var participantCache = {};\n\n  var allFlowNodeShapes = [];\n\n  function isInLaneShape(element, laneShape) {\n\n    var laneTrbl = asTRBL(laneShape);\n\n    var elementMid = {\n      x: element.x + element.width / 2,\n      y: element.y + element.height / 2\n    };\n\n    return elementMid.x > laneTrbl.left &&\n           elementMid.x < laneTrbl.right &&\n           elementMid.y > laneTrbl.top &&\n           elementMid.y < laneTrbl.bottom;\n  }\n\n  function addFlowNodeShape(flowNodeShape) {\n    if (!handledNodes[flowNodeShape.id]) {\n      allFlowNodeShapes.push(flowNodeShape);\n      handledNodes[flowNodeShape.id] = flowNodeShape;\n    }\n  }\n\n  function getAllLaneShapes(flowNodeShape) {\n\n    var root = getLanesRoot(flowNodeShape);\n\n    if (!participantCache[root.id]) {\n      participantCache[root.id] = collectLanes(root);\n    }\n\n    return participantCache[root.id];\n  }\n\n  function getNewLanes(flowNodeShape) {\n    if (!flowNodeShape.parent) {\n      return [];\n    }\n\n    var allLaneShapes = getAllLaneShapes(flowNodeShape);\n\n    return allLaneShapes.filter(function(l) {\n      return isInLaneShape(flowNodeShape, l);\n    }).map(function(shape) {\n      return shape.businessObject;\n    });\n  }\n\n  laneShapes.forEach(function(laneShape) {\n    var root = getLanesRoot(laneShape);\n\n    if (!root || handledNodes[root.id]) {\n      return;\n    }\n\n    var children = root.children.filter(function(c) {\n      return is(c, 'bpmn:FlowNode');\n    });\n\n    children.forEach(addFlowNodeShape);\n\n    handledNodes[root.id] = root;\n  });\n\n  flowNodeShapes.forEach(addFlowNodeShape);\n\n\n  allFlowNodeShapes.forEach(function(flowNodeShape) {\n\n    var flowNode = flowNodeShape.businessObject;\n\n    var lanes = flowNode.get(LANES_ATTR),\n        remove = lanes.slice(),\n        add = getNewLanes(flowNodeShape);\n\n    updates.push({ flowNode: flowNode, remove: remove, add: add });\n  });\n\n  laneShapes.forEach(function(laneShape) {\n\n    var lane = laneShape.businessObject;\n\n    // lane got removed XX-)\n    if (!laneShape.parent) {\n      lane.get(FLOW_NODE_REFS_ATTR).forEach(function(flowNode) {\n        updates.push({ flowNode: flowNode, remove: [ lane ], add: [] });\n      });\n    }\n  });\n\n  return updates;\n};",
            "name": "function_2",
            "parameters": [
                "flowNodeShapes",
                "laneShapes"
            ],
            "start_line": 35,
            "end_line": 135,
            "return": true
        },
        "function_14": {
            "signature": "",
            "content": "UpdateFlowNodeRefsHandler.prototype.execute = function(context) {\n\n  var updates = context.updates;\n\n  if (!updates) {\n    updates = context.updates = this.computeUpdates(context.flowNodeShapes, context.laneShapes);\n  }\n\n\n  updates.forEach(function(update) {\n\n    var flowNode = update.flowNode,\n        lanes = flowNode.get(LANES_ATTR);\n\n    // unwire old\n    update.remove.forEach(function(oldLane) {\n      collectionRemove(lanes, oldLane);\n      collectionRemove(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n\n    // wire new\n    update.add.forEach(function(newLane) {\n      collectionAdd(lanes, newLane);\n      collectionAdd(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n  });\n\n  // TODO(nikku): return changed elements\n  // return [ ... ];\n};",
            "name": "function_14",
            "parameters": [
                "context"
            ],
            "start_line": 137,
            "end_line": 166,
            "return": false
        },
        "function_18": {
            "signature": "",
            "content": "UpdateFlowNodeRefsHandler.prototype.revert = function(context) {\n\n  var updates = context.updates;\n\n  updates.forEach(function(update) {\n\n    var flowNode = update.flowNode,\n        lanes = flowNode.get(LANES_ATTR);\n\n    // unwire new\n    update.add.forEach(function(newLane) {\n      collectionRemove(lanes, newLane);\n      collectionRemove(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n\n    // wire old\n    update.remove.forEach(function(oldLane) {\n      collectionAdd(lanes, oldLane);\n      collectionAdd(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n  });\n\n  // TODO(nikku): return changed elements\n  // return [ ... ];\n};",
            "name": "function_18",
            "parameters": [
                "context"
            ],
            "start_line": 169,
            "end_line": 193,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\cmd\\UpdatePropertiesHandler.js": {
        "function_1": {
            "signature": "/**\n* A handler that implements a BPMN 2.0 property update.\n*\n* This should be used to set simple properties on elements with\n* an underlying BPMN business object.\n*\n* Use respective diagram-js provided handlers if you would\n* like to perform automated modeling.\n*/",
            "content": "export default function UpdatePropertiesHandler(\n    elementRegistry, moddle, translate,\n    modeling, textRenderer) {\n\n  this._elementRegistry = elementRegistry;\n  this._moddle = moddle;\n  this._translate = translate;\n  this._modeling = modeling;\n  this._textRenderer = textRenderer;\n}",
            "name": "UpdatePropertiesHandler",
            "parameters": [
                "elementRegistry",
                "moddle",
                "translate",
                "modeling",
                "textRenderer"
            ],
            "start_line": 30,
            "end_line": 39,
            "return": false
        },
        "function_2": {
            "signature": "/**\n* Updates a BPMN element with a list of new properties\n*\n* @param {Object} context\n* @param {djs.model.Base} context.element the element to update\n* @param {Object} context.properties a list of properties to set on the element's\n*                                    businessObject (the BPMN model element)\n*\n* @return {Array<djs.model.Base>} the updated element\n*/",
            "content": "UpdatePropertiesHandler.prototype.execute = function(context) {\n\n  var element = context.element,\n      changed = [ element ],\n      translate = this._translate;\n\n  if (!element) {\n    throw new Error(translate('element required'));\n  }\n\n  var elementRegistry = this._elementRegistry,\n      ids = this._moddle.ids;\n\n  var businessObject = element.businessObject,\n      properties = unwrapBusinessObjects(context.properties),\n      oldProperties = context.oldProperties || getProperties(businessObject, properties);\n\n  if (isIdChange(properties, businessObject)) {\n    ids.unclaim(businessObject[ID]);\n\n    elementRegistry.updateId(element, properties[ID]);\n\n    ids.claim(properties[ID], businessObject);\n  }\n\n  // correctly indicate visual changes on default flow updates\n  if (DEFAULT_FLOW in properties) {\n\n    if (properties[DEFAULT_FLOW]) {\n      changed.push(elementRegistry.get(properties[DEFAULT_FLOW].id));\n    }\n\n    if (businessObject[DEFAULT_FLOW]) {\n      changed.push(elementRegistry.get(businessObject[DEFAULT_FLOW].id));\n    }\n  }\n\n  // update properties\n  setProperties(businessObject, properties);\n\n  // store old values\n  context.oldProperties = oldProperties;\n  context.changed = changed;\n\n  // indicate changed on objects affected by the update\n  return changed;\n};",
            "name": "function_2",
            "parameters": [
                "context"
            ],
            "start_line": 62,
            "end_line": 108,
            "return": true
        },
        "function_3": {
            "signature": "",
            "content": "UpdatePropertiesHandler.prototype.postExecute = function(context) {\n  var element = context.element,\n      label = element.label;\n\n  var text = label && getBusinessObject(label).name;\n\n  if (!text) {\n    return;\n  }\n\n  // get layouted text bounds and resize external\n  // external label accordingly\n  var newLabelBounds = this._textRenderer.getExternalLabelBounds(label, text);\n\n  this._modeling.resizeShape(label, newLabelBounds, NULL_DIMENSIONS);\n};",
            "name": "function_3",
            "parameters": [
                "context"
            ],
            "start_line": 111,
            "end_line": 126,
            "return": true
        },
        "function_4": {
            "signature": "/**\n* Reverts the update on a BPMN elements properties.\n*\n* @param  {Object} context\n*\n* @return {djs.model.Base} the updated element\n*/",
            "content": "UpdatePropertiesHandler.prototype.revert = function(context) {\n\n  var element = context.element,\n      properties = context.properties,\n      oldProperties = context.oldProperties,\n      businessObject = element.businessObject,\n      elementRegistry = this._elementRegistry,\n      ids = this._moddle.ids;\n\n  // update properties\n  setProperties(businessObject, oldProperties);\n\n  if (isIdChange(properties, businessObject)) {\n    ids.unclaim(properties[ID]);\n\n    elementRegistry.updateId(element, oldProperties[ID]);\n\n    ids.claim(oldProperties[ID], businessObject);\n  }\n\n  return context.changed;\n};",
            "name": "function_4",
            "parameters": [
                "context"
            ],
            "start_line": 135,
            "end_line": 156,
            "return": true
        },
        "function_5": {
            "signature": "",
            "content": "function isIdChange(properties, businessObject) {\n  return ID in properties && properties[ID] !== businessObject[ID];\n}",
            "name": "isIdChange",
            "parameters": [
                "properties",
                "businessObject"
            ],
            "start_line": 159,
            "end_line": 161,
            "return": true
        },
        "function_6": {
            "signature": "",
            "content": "function getProperties(businessObject, properties) {\n  var propertyNames = keys(properties);\n\n  return reduce(propertyNames, function(result, key) {\n\n    // handle DI seperately\n    if (key !== DI) {\n      result[key] = businessObject.get(key);\n    } else {\n      result[key] = getDiProperties(businessObject.di, keys(properties.di));\n    }\n\n    return result;\n  }, {});\n}",
            "name": "getProperties",
            "parameters": [
                "businessObject",
                "properties"
            ],
            "start_line": 164,
            "end_line": 178,
            "return": true
        },
        "function_8": {
            "signature": "",
            "content": "function getDiProperties(di, propertyNames) {\n  return reduce(propertyNames, function(result, key) {\n    result[key] = di.get(key);\n\n    return result;\n  }, {});\n}",
            "name": "getDiProperties",
            "parameters": [
                "di",
                "propertyNames"
            ],
            "start_line": 181,
            "end_line": 187,
            "return": true
        },
        "function_10": {
            "signature": "",
            "content": "function setProperties(businessObject, properties) {\n  forEach(properties, function(value, key) {\n\n    if (key !== DI) {\n      businessObject.set(key, value);\n    } else {\n      // only update, if businessObject.di exists\n      if (businessObject.di) {\n        setDiProperties(businessObject.di, value);\n      }\n    }\n  });\n}",
            "name": "setProperties",
            "parameters": [
                "businessObject",
                "properties"
            ],
            "start_line": 190,
            "end_line": 202,
            "return": false
        },
        "function_12": {
            "signature": "",
            "content": "function setDiProperties(di, properties) {\n  forEach(properties, function(value, key) {\n    di.set(key, value);\n  });\n}",
            "name": "setDiProperties",
            "parameters": [
                "di",
                "properties"
            ],
            "start_line": 205,
            "end_line": 209,
            "return": false
        },
        "function_14": {
            "signature": "/**\n* Make sure we unwrap the actual business object\n* behind diagram element that may have been\n* passed as arguments.\n*\n* @param  {Object} properties\n*\n* @return {Object} unwrappedProps\n*/",
            "content": "function unwrapBusinessObjects(properties) {\n\n  var unwrappedProps = assign({}, properties);\n\n  referencePropertyNames.forEach(function(name) {\n    if (name in properties) {\n      unwrappedProps[name] = getBusinessObject(unwrappedProps[name]);\n    }\n  });\n\n  return unwrappedProps;\n}",
            "name": "unwrapBusinessObjects",
            "parameters": [
                "properties"
            ],
            "start_line": 223,
            "end_line": 234,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\cmd\\UpdateSemanticParentHandler.js": {
        "function_1": {
            "signature": "",
            "content": "export default function UpdateSemanticParentHandler(bpmnUpdater) {\n  this._bpmnUpdater = bpmnUpdater;\n}",
            "name": "UpdateSemanticParentHandler",
            "parameters": [
                "bpmnUpdater"
            ],
            "start_line": 1,
            "end_line": 3,
            "return": false
        },
        "function_2": {
            "signature": "",
            "content": "UpdateSemanticParentHandler.prototype.execute = function(context) {\n  var dataStoreBo = context.dataStoreBo,\n      newSemanticParent = context.newSemanticParent,\n      newDiParent = context.newDiParent;\n\n  context.oldSemanticParent = dataStoreBo.$parent;\n  context.oldDiParent = dataStoreBo.di.$parent;\n\n  // update semantic parent\n  this._bpmnUpdater.updateSemanticParent(dataStoreBo, newSemanticParent);\n\n  // update DI parent\n  this._bpmnUpdater.updateDiParent(dataStoreBo.di, newDiParent);\n};",
            "name": "function_2",
            "parameters": [
                "context"
            ],
            "start_line": 8,
            "end_line": 21,
            "return": false
        },
        "function_3": {
            "signature": "",
            "content": "UpdateSemanticParentHandler.prototype.revert = function(context) {\n  var dataStoreBo = context.dataStoreBo,\n      oldSemanticParent = context.oldSemanticParent,\n      oldDiParent = context.oldDiParent;\n\n  // update semantic parent\n  this._bpmnUpdater.updateSemanticParent(dataStoreBo, oldSemanticParent);\n\n  // update DI parent\n  this._bpmnUpdater.updateDiParent(dataStoreBo.di, oldDiParent);\n};",
            "name": "function_3",
            "parameters": [
                "context"
            ],
            "start_line": 23,
            "end_line": 33,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\util\\LaneUtil.js": {
        "function_1": {
            "signature": "",
            "content": "function getTRBLResize(oldBounds, newBounds) {\n  return substractTRBL(asTRBL(newBounds), asTRBL(oldBounds));\n}",
            "name": "getTRBLResize",
            "parameters": [
                "oldBounds",
                "newBounds"
            ],
            "start_line": 19,
            "end_line": 21,
            "return": true
        },
        "function_2": {
            "signature": "/**\n* Collect all lane shapes in the given paren\n*\n* @param  {djs.model.Shape} shape\n* @param  {Array<djs.model.Base>} [collectedShapes]\n*\n* @return {Array<djs.model.Base>}\n*/",
            "content": "export function collectLanes(shape, collectedShapes) {\n\n  collectedShapes = collectedShapes || [];\n\n  shape.children.filter(function(s) {\n    if (is(s, 'bpmn:Lane')) {\n      collectLanes(s, collectedShapes);\n\n      collectedShapes.push(s);\n    }\n  });\n\n  return collectedShapes;\n}",
            "name": "collectLanes",
            "parameters": [
                "shape",
                "collectedShapes"
            ],
            "start_line": 41,
            "end_line": 54,
            "return": true
        },
        "function_4": {
            "signature": "/**\n* Return the lane children of the given element.\n*\n* @param {djs.model.Shape} shape\n*\n* @return {Array<djs.model.Shape>}\n*/",
            "content": "export function getChildLanes(shape) {\n  return shape.children.filter(function(c) {\n    return is(c, 'bpmn:Lane');\n  });\n}",
            "name": "getChildLanes",
            "parameters": [
                "shape"
            ],
            "start_line": 64,
            "end_line": 68,
            "return": true
        },
        "function_6": {
            "signature": "/**\n* Return the root element containing the given lane shape\n*\n* @param {djs.model.Shape} shape\n*\n* @return {djs.model.Shape}\n*/",
            "content": "export function getLanesRoot(shape) {\n  return getParent(shape, LANE_PARENTS) || shape;\n}",
            "name": "getLanesRoot",
            "parameters": [
                "shape"
            ],
            "start_line": 78,
            "end_line": 80,
            "return": true
        },
        "function_7": {
            "signature": "/**\n* Compute the required resize operations for lanes\n* adjacent to the given shape, assuming it will be\n* resized to the given new bounds.\n*\n* @param {djs.model.Shape} shape\n* @param {Bounds} newBounds\n*\n* @return {Array<Object>}\n*/",
            "content": "export function computeLanesResize(shape, newBounds) {\n\n  var rootElement = getLanesRoot(shape);\n\n  var initialShapes = is(rootElement, 'bpmn:Process') ? [] : [ rootElement ];\n\n  var allLanes = collectLanes(rootElement, initialShapes),\n      shapeTrbl = asTRBL(shape),\n      shapeNewTrbl = asTRBL(newBounds),\n      trblResize = getTRBLResize(shape, newBounds),\n      resizeNeeded = [];\n\n  allLanes.forEach(function(other) {\n\n    if (other === shape) {\n      return;\n    }\n\n    var topResize = 0,\n        rightResize = trblResize.right,\n        bottomResize = 0,\n        leftResize = trblResize.left;\n\n    var otherTrbl = asTRBL(other);\n\n    if (trblResize.top) {\n      if (abs(otherTrbl.bottom - shapeTrbl.top) < 10) {\n        bottomResize = shapeNewTrbl.top - otherTrbl.bottom;\n      }\n\n      if (abs(otherTrbl.top - shapeTrbl.top) < 5) {\n        topResize = shapeNewTrbl.top - otherTrbl.top;\n      }\n    }\n\n    if (trblResize.bottom) {\n      if (abs(otherTrbl.top - shapeTrbl.bottom) < 10) {\n        topResize = shapeNewTrbl.bottom - otherTrbl.top;\n      }\n\n      if (abs(otherTrbl.bottom - shapeTrbl.bottom) < 5) {\n        bottomResize = shapeNewTrbl.bottom - otherTrbl.bottom;\n      }\n    }\n\n    if (topResize || rightResize || bottomResize || leftResize) {\n\n      resizeNeeded.push({\n        shape: other,\n        newBounds: resizeTRBL(other, {\n          top: topResize,\n          right: rightResize,\n          bottom: bottomResize,\n          left: leftResize\n        })\n      });\n    }\n\n  });\n\n  return resizeNeeded;\n}",
            "name": "computeLanesResize",
            "parameters": [
                "shape",
                "newBounds"
            ],
            "start_line": 93,
            "end_line": 154,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\modeling\\util\\ModelingUtil.js": {
        "function_1": {
            "signature": "/**\n* Return true if element has any of the given types.\n*\n* @param {djs.model.Base} element\n* @param {Array<String>} types\n*\n* @return {Boolean}\n*/",
            "content": "export function isAny(element, types) {\n  return some(types, function(t) {\n    return is(element, t);\n  });\n}",
            "name": "isAny",
            "parameters": [
                "element",
                "types"
            ],
            "start_line": 16,
            "end_line": 20,
            "return": true
        },
        "function_3": {
            "signature": "/**\n* Return the parent of the element with any of the given types.\n*\n* @param {djs.model.Base} element\n* @param {String|Array<String>} anyType\n*\n* @return {djs.model.Base}\n*/",
            "content": "export function getParent(element, anyType) {\n\n  if (typeof anyType === 'string') {\n    anyType = [ anyType ];\n  }\n\n  while ((element = element.parent)) {\n    if (isAny(element, anyType)) {\n      return element;\n    }\n  }\n\n  return null;\n}",
            "name": "getParent",
            "parameters": [
                "element",
                "anyType"
            ],
            "start_line": 31,
            "end_line": 44,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\ordering\\BpmnOrderingProvider.js": {
        "function_1": {
            "signature": "/**\n* a simple ordering provider that makes sure:\n*\n* (0) labels are rendered always on top\n* (1) elements are ordered by a {level} property\n*/",
            "content": "export default function BpmnOrderingProvider(eventBus, canvas, translate) {\n\n  OrderingProvider.call(this, eventBus);\n\n  var orders = [\n    { type: 'bpmn:SubProcess', order: { level: 6 } },\n    {\n      type: 'bpmn:SequenceFlow',\n      order: {\n        level: 3,\n        containers: [\n          'bpmn:Participant',\n          'bpmn:FlowElementsContainer'\n        ]\n      }\n    },\n    // handle DataAssociation(s) like message flows and render them always on top\n    {\n      type: 'bpmn:DataAssociation',\n      order: {\n        level: 9,\n        containers: [\n          'bpmn:Collaboration',\n          'bpmn:Process'\n        ]\n      }\n    },\n    {\n      type: 'bpmn:MessageFlow', order: {\n        level: 9,\n        containers: [ 'bpmn:Collaboration' ]\n      }\n    },\n    {\n      type: 'bpmn:Association',\n      order: {\n        level: 6,\n        containers: [\n          'bpmn:Participant',\n          'bpmn:FlowElementsContainer',\n          'bpmn:Collaboration'\n        ]\n      }\n    },\n    { type: 'bpmn:BoundaryEvent', order: { level: 8 } },\n    { type: 'bpmn:FlowElement', order: { level: 5 } },\n    { type: 'bpmn:Participant', order: { level: -2 } },\n    { type: 'bpmn:Lane', order: { level: -1 } }\n  ];\n\n  function computeOrder(element) {\n    if (element.labelTarget) {\n      return { level: 10 };\n    }\n\n    var entry = find(orders, function(o) {\n      return isAny(element, [ o.type ]);\n    });\n\n    return entry && entry.order || { level: 1 };\n  }\n\n  function getOrder(element) {\n\n    var order = element.order;\n\n    if (!order) {\n      element.order = order = computeOrder(element);\n    }\n\n    return order;\n  }\n\n  function findActualParent(element, newParent, containers) {\n\n    var actualParent = newParent;\n\n    while (actualParent) {\n\n      if (isAny(actualParent, containers)) {\n        break;\n      }\n\n      actualParent = actualParent.parent;\n    }\n\n    if (!actualParent) {\n      throw new Error(translate('no parent for {element} in {parent}', {\n        element: element.id,\n        parent: newParent.id\n      }));\n    }\n\n    return actualParent;\n  }\n\n  this.getOrdering = function(element, newParent) {\n\n    // render labels always on top\n    if (element.labelTarget) {\n      return {\n        parent: canvas.getRootElement(),\n        index: -1\n      };\n    }\n\n    var elementOrder = getOrder(element);\n\n\n    if (elementOrder.containers) {\n      newParent = findActualParent(element, newParent, elementOrder.containers);\n    }\n\n\n    var currentIndex = newParent.children.indexOf(element);\n\n    var insertIndex = findIndex(newParent.children, function(child) {\n\n      // do not compare with labels, they are created\n      // in the wrong order (right after elements) during import and\n      // mess up the positioning.\n      if (!element.labelTarget && child.labelTarget) {\n        return false;\n      }\n\n      return elementOrder.level < getOrder(child).level;\n    });\n\n\n    // if the element is already in the child list at\n    // a smaller index, we need to adjust the inser index.\n    // this takes into account that the element is being removed\n    // before being re-inserted\n    if (insertIndex !== -1) {\n      if (currentIndex !== -1 && currentIndex < insertIndex) {\n        insertIndex -= 1;\n      }\n    }\n\n    return {\n      index: insertIndex,\n      parent: newParent\n    };\n  };\n}",
            "name": "BpmnOrderingProvider",
            "parameters": [
                "eventBus",
                "canvas",
                "translate"
            ],
            "start_line": 21,
            "end_line": 165,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\ordering\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\palette\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\palette\\PaletteProvider.js": {
        "function_1": {
            "signature": "/**\n* A palette provider for BPMN 2.0 elements.\n*/",
            "content": "export default function PaletteProvider(\n    palette, create, elementFactory,\n    spaceTool, lassoTool, handTool,\n    globalConnect, translate) {\n\n  this._palette = palette;\n  this._create = create;\n  this._elementFactory = elementFactory;\n  this._spaceTool = spaceTool;\n  this._lassoTool = lassoTool;\n  this._handTool = handTool;\n  this._globalConnect = globalConnect;\n  this._translate = translate;\n\n  palette.registerProvider(this);\n}",
            "name": "PaletteProvider",
            "parameters": [
                "palette",
                "create",
                "elementFactory",
                "spaceTool",
                "lassoTool",
                "handTool",
                "globalConnect",
                "translate"
            ],
            "start_line": 9,
            "end_line": 24,
            "return": false
        },
        "function_2": {
            "signature": "",
            "content": "PaletteProvider.prototype.getPaletteEntries = function(element) {\n\n  var actions = {},\n      create = this._create,\n      elementFactory = this._elementFactory,\n      spaceTool = this._spaceTool,\n      lassoTool = this._lassoTool,\n      handTool = this._handTool,\n      globalConnect = this._globalConnect,\n      translate = this._translate;\n\n  function createAction(type, group, className, title, options) {\n\n    function createListener(event) {\n      var shape = elementFactory.createShape(assign({ type: type }, options));\n\n      if (options) {\n        shape.businessObject.di.isExpanded = options.isExpanded;\n      }\n\n      create.start(event, shape);\n    }\n\n    var shortType = type.replace(/^bpmn:/, '');\n\n    return {\n      group: group,\n      className: className,\n      title: title || translate('Create {type}', { type: shortType }),\n      action: {\n        dragstart: createListener,\n        click: createListener\n      }\n    };\n  }\n\n  function createParticipant(event, collapsed) {\n    create.start(event, elementFactory.createParticipantShape(collapsed));\n  }\n\n  assign(actions, {\n    'hand-tool': {\n      group: 'tools',\n      className: 'bpmn-icon-hand-tool',\n      title: translate('Activate the hand tool'),\n      action: {\n        click: function(event) {\n          handTool.activateHand(event);\n        }\n      }\n    },\n    'lasso-tool': {\n      group: 'tools',\n      className: 'bpmn-icon-lasso-tool',\n      title: translate('Activate the lasso tool'),\n      action: {\n        click: function(event) {\n          lassoTool.activateSelection(event);\n        }\n      }\n    },\n    'space-tool': {\n      group: 'tools',\n      className: 'bpmn-icon-space-tool',\n      title: translate('Activate the create/remove space tool'),\n      action: {\n        click: function(event) {\n          spaceTool.activateSelection(event);\n        }\n      }\n    },\n    'global-connect-tool': {\n      group: 'tools',\n      className: 'bpmn-icon-connection-multi',\n      title: translate('Activate the global connect tool'),\n      action: {\n        click: function(event) {\n          globalConnect.toggle(event);\n        }\n      }\n    },\n    'tool-separator': {\n      group: 'tools',\n      separator: true\n    },\n    'create.start-event': createAction(\n      'bpmn:StartEvent', 'event', 'bpmn-icon-start-event-none'\n    ),\n    'create.intermediate-event': createAction(\n      'bpmn:IntermediateThrowEvent', 'event', 'bpmn-icon-intermediate-event-none',\n      translate('Create Intermediate/Boundary Event')\n    ),\n    'create.end-event': createAction(\n      'bpmn:EndEvent', 'event', 'bpmn-icon-end-event-none'\n    ),\n    'create.exclusive-gateway': createAction(\n      'bpmn:ExclusiveGateway', 'gateway', 'bpmn-icon-gateway-none',\n      translate('Create Gateway')\n    ),\n    'create.task': createAction(\n      'bpmn:Task', 'activity', 'bpmn-icon-task'\n    ),\n    'create.data-object': createAction(\n      'bpmn:DataObjectReference', 'data-object', 'bpmn-icon-data-object'\n    ),\n    'create.data-store': createAction(\n      'bpmn:DataStoreReference', 'data-store', 'bpmn-icon-data-store'\n    ),\n    'create.subprocess-expanded': createAction(\n      'bpmn:SubProcess', 'activity', 'bpmn-icon-subprocess-expanded',\n      translate('Create expanded SubProcess'),\n      { isExpanded: true }\n    ),\n    'create.participant-expanded': {\n      group: 'collaboration',\n      className: 'bpmn-icon-participant',\n      title: translate('Create Pool/Participant'),\n      action: {\n        dragstart: createParticipant,\n        click: createParticipant\n      }\n    }\n  });\n\n  return actions;\n};",
            "name": "function_2",
            "parameters": [
                "element"
            ],
            "start_line": 38,
            "end_line": 163,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\popup-menu\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\popup-menu\\ReplaceMenuProvider.js": {
        "function_1": {
            "signature": "/**\n* This module is an element agnostic replace menu provider for the popup menu.\n*/",
            "content": "export default function ReplaceMenuProvider(\n    popupMenu, modeling, moddle,\n    bpmnReplace, rules, translate) {\n\n  this._popupMenu = popupMenu;\n  this._modeling = modeling;\n  this._moddle = moddle;\n  this._bpmnReplace = bpmnReplace;\n  this._rules = rules;\n  this._translate = translate;\n\n  this.register();\n}",
            "name": "ReplaceMenuProvider",
            "parameters": [
                "popupMenu",
                "modeling",
                "moddle",
                "bpmnReplace",
                "rules",
                "translate"
            ],
            "start_line": 26,
            "end_line": 38,
            "return": false
        },
        "function_2": {
            "signature": "/**\n* Register replace menu provider in the popup menu\n*/",
            "content": "ReplaceMenuProvider.prototype.register = function() {\n  this._popupMenu.registerProvider('bpmn-replace', this);\n};",
            "name": "function_2",
            "parameters": [],
            "start_line": 53,
            "end_line": 55,
            "return": false
        },
        "function_3": {
            "signature": "/**\n* Get all entries from replaceOptions for the given element and apply filters\n* on them. Get for example only elements, which are different from the current one.\n*\n* @param {djs.model.Base} element\n*\n* @return {Array<Object>} a list of menu entry items\n*/",
            "content": "ReplaceMenuProvider.prototype.getEntries = function(element) {\n\n  var businessObject = element.businessObject;\n\n  var rules = this._rules;\n\n  var entries;\n\n  if (!rules.allowed('shape.replace', { element: element })) {\n    return [];\n  }\n\n  var differentType = isDifferentType(element);\n\n  // start events outside event sub processes\n  if (is(businessObject, 'bpmn:StartEvent') && !isEventSubProcess(businessObject.$parent)) {\n\n    entries = filter(replaceOptions.START_EVENT, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // expanded/collapsed pools\n  if (is(businessObject, 'bpmn:Participant')) {\n\n    entries = filter(replaceOptions.PARTICIPANT, function(entry) {\n      return isExpanded(businessObject) !== entry.target.isExpanded;\n    });\n\n    return this._createEntries(element, entries);\n  }\n\n  // start events inside event sub processes\n  if (is(businessObject, 'bpmn:StartEvent') && isEventSubProcess(businessObject.$parent)) {\n\n    entries = filter(replaceOptions.EVENT_SUB_PROCESS_START_EVENT, function(entry) {\n\n      var target = entry.target;\n\n      var isInterrupting = target.isInterrupting !== false;\n\n      var isInterruptingEqual = getBusinessObject(element).isInterrupting === isInterrupting;\n\n      // filters elements which types and event definition are equal but have have different interrupting types\n      return differentType(entry) || !differentType(entry) && !isInterruptingEqual;\n\n    });\n\n    return this._createEntries(element, entries);\n  }\n\n  // end events\n  if (is(businessObject, 'bpmn:EndEvent')) {\n\n    entries = filter(replaceOptions.END_EVENT, function(entry) {\n      var target = entry.target;\n\n      // hide cancel end events outside transactions\n      if (target.eventDefinitionType == 'bpmn:CancelEventDefinition' && !is(businessObject.$parent, 'bpmn:Transaction')) {\n        return false;\n      }\n\n      return differentType(entry);\n    });\n\n    return this._createEntries(element, entries);\n  }\n\n  // boundary events\n  if (is(businessObject, 'bpmn:BoundaryEvent')) {\n\n    entries = filter(replaceOptions.BOUNDARY_EVENT, function(entry) {\n\n      var target = entry.target;\n\n      if (target.eventDefinition == 'bpmn:CancelEventDefinition' &&\n         !is(businessObject.attachedToRef, 'bpmn:Transaction')) {\n        return false;\n      }\n      var cancelActivity = target.cancelActivity !== false;\n\n      var isCancelActivityEqual = businessObject.cancelActivity == cancelActivity;\n\n      return differentType(entry) || !differentType(entry) && !isCancelActivityEqual;\n    });\n\n    return this._createEntries(element, entries);\n  }\n\n  // intermediate events\n  if (is(businessObject, 'bpmn:IntermediateCatchEvent') ||\n      is(businessObject, 'bpmn:IntermediateThrowEvent')) {\n\n    entries = filter(replaceOptions.INTERMEDIATE_EVENT, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // gateways\n  if (is(businessObject, 'bpmn:Gateway')) {\n\n    entries = filter(replaceOptions.GATEWAY, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // transactions\n  if (is(businessObject, 'bpmn:Transaction')) {\n\n    entries = filter(replaceOptions.TRANSACTION, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // expanded event sub processes\n  if (isEventSubProcess(businessObject) && isExpanded(businessObject)) {\n\n    entries = filter(replaceOptions.EVENT_SUB_PROCESS, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // expanded sub processes\n  if (is(businessObject, 'bpmn:SubProcess') && isExpanded(businessObject)) {\n\n    entries = filter(replaceOptions.SUBPROCESS_EXPANDED, differentType);\n\n    return this._createEntries(element, entries);\n  }\n\n  // collapsed ad hoc sub processes\n  if (is(businessObject, 'bpmn:AdHocSubProcess') && !isExpanded(businessObject)) {\n\n    entries = filter(replaceOptions.TASK, function(entry) {\n\n      var target = entry.target;\n\n      var isTargetSubProcess = target.type === 'bpmn:SubProcess';\n\n      var isTargetExpanded = target.isExpanded === true;\n\n      return isDifferentType(element, target) && (!isTargetSubProcess || isTargetExpanded);\n    });\n\n    return this._createEntries(element, entries);\n  }\n\n  // sequence flows\n  if (is(businessObject, 'bpmn:SequenceFlow')) {\n    return this._createSequenceFlowEntries(element, replaceOptions.SEQUENCE_FLOW);\n  }\n\n  // flow nodes\n  if (is(businessObject, 'bpmn:FlowNode')) {\n    entries = filter(replaceOptions.TASK, differentType);\n\n    // collapsed SubProcess can not be replaced with itself\n    if (is(businessObject, 'bpmn:SubProcess') && !isExpanded(businessObject)) {\n      entries = filter(entries, function(entry) {\n        return entry.label !== 'Sub Process (collapsed)';\n      });\n    }\n\n    return this._createEntries(element, entries);\n  }\n\n  return [];\n};",
            "name": "function_3",
            "parameters": [
                "element"
            ],
            "start_line": 66,
            "end_line": 233,
            "return": true
        },
        "function_10": {
            "signature": "/**\n* Get a list of header items for the given element. This includes buttons\n* for multi instance markers and for the ad hoc marker.\n*\n* @param {djs.model.Base} element\n*\n* @return {Array<Object>} a list of menu entry items\n*/",
            "content": "ReplaceMenuProvider.prototype.getHeaderEntries = function(element) {\n\n  var headerEntries = [];\n\n  if (is(element, 'bpmn:Activity') && !isEventSubProcess(element)) {\n    headerEntries = headerEntries.concat(this._getLoopEntries(element));\n  }\n\n  if (is(element, 'bpmn:SubProcess') &&\n      !is(element, 'bpmn:Transaction') &&\n      !isEventSubProcess(element)) {\n    headerEntries.push(this._getAdHocEntry(element));\n  }\n\n  return headerEntries;\n};",
            "name": "function_10",
            "parameters": [
                "element"
            ],
            "start_line": 244,
            "end_line": 259,
            "return": true
        },
        "function_11": {
            "signature": "/**\n* Creates an array of menu entry objects for a given element and filters the replaceOptions\n* according to a filter function.\n*\n* @param  {djs.model.Base} element\n* @param  {Object} replaceOptions\n*\n* @return {Array<Object>} a list of menu items\n*/",
            "content": "ReplaceMenuProvider.prototype._createEntries = function(element, replaceOptions) {\n  var menuEntries = [];\n\n  var self = this;\n\n  forEach(replaceOptions, function(definition) {\n    var entry = self._createMenuEntry(definition, element);\n\n    menuEntries.push(entry);\n  });\n\n  return menuEntries;\n};",
            "name": "function_11",
            "parameters": [
                "element",
                "replaceOptions"
            ],
            "start_line": 271,
            "end_line": 283,
            "return": true
        },
        "function_13": {
            "signature": "* @return {Array<Object>} a list of menu items\n*/",
            "content": "ReplaceMenuProvider.prototype._createSequenceFlowEntries = function(element, replaceOptions) {\n\n  var businessObject = getBusinessObject(element);\n\n  var menuEntries = [];\n\n  var modeling = this._modeling,\n      moddle = this._moddle;\n\n  var self = this;\n\n  forEach(replaceOptions, function(entry) {\n\n    switch (entry.actionName) {\n    case 'replace-with-default-flow':\n      if (businessObject.sourceRef.default !== businessObject &&\n            (is(businessObject.sourceRef, 'bpmn:ExclusiveGateway') ||\n             is(businessObject.sourceRef, 'bpmn:InclusiveGateway') ||\n             is(businessObject.sourceRef, 'bpmn:ComplexGateway') ||\n             is(businessObject.sourceRef, 'bpmn:Activity'))) {\n\n        menuEntries.push(self._createMenuEntry(entry, element, function() {\n          modeling.updateProperties(element.source, { default: businessObject });\n        }));\n      }\n      break;\n    case 'replace-with-conditional-flow':\n      if (!businessObject.conditionExpression && is(businessObject.sourceRef, 'bpmn:Activity')) {\n\n        menuEntries.push(self._createMenuEntry(entry, element, function() {\n          var conditionExpression = moddle.create('bpmn:FormalExpression', { body: '' });\n\n          modeling.updateProperties(element, { conditionExpression: conditionExpression });\n        }));\n      }\n      break;\n    default:\n      // default flows\n      if (is(businessObject.sourceRef, 'bpmn:Activity') && businessObject.conditionExpression) {\n        return menuEntries.push(self._createMenuEntry(entry, element, function() {\n          modeling.updateProperties(element, { conditionExpression: undefined });\n        }));\n      }\n      // conditional flows\n      if ((is(businessObject.sourceRef, 'bpmn:ExclusiveGateway') ||\n           is(businessObject.sourceRef, 'bpmn:InclusiveGateway') ||\n           is(businessObject.sourceRef, 'bpmn:ComplexGateway') ||\n           is(businessObject.sourceRef, 'bpmn:Activity')) &&\n           businessObject.sourceRef.default === businessObject) {\n\n        return menuEntries.push(self._createMenuEntry(entry, element, function() {\n          modeling.updateProperties(element.source, { default: undefined });\n        }));\n      }\n    }\n  });\n\n  return menuEntries;\n};",
            "name": "function_13",
            "parameters": [
                "element",
                "replaceOptions"
            ],
            "start_line": 293,
            "end_line": 351,
            "return": true
        },
        "function_19": {
            "signature": "/**\n* Creates and returns a single menu entry item.\n*\n* @param  {Object} definition a single replace options definition object\n* @param  {djs.model.Base} element\n* @param  {Function} [action] an action callback function which gets called when\n*                             the menu entry is being triggered.\n*\n* @return {Object} menu entry item\n*/",
            "content": "ReplaceMenuProvider.prototype._createMenuEntry = function(definition, element, action) {\n  var translate = this._translate;\n  var replaceElement = this._bpmnReplace.replaceElement;\n\n  var replaceAction = function() {\n    return replaceElement(element, definition.target);\n  };\n\n  action = action || replaceAction;\n\n  var menuEntry = {\n    label: translate(definition.label),\n    className: definition.className,\n    id: definition.actionName,\n    action: action\n  };\n\n  return menuEntry;\n};",
            "name": "function_19",
            "parameters": [
                "definition",
                "element",
                "action"
            ],
            "start_line": 364,
            "end_line": 382,
            "return": true
        },
        "function_21": {
            "signature": "/**\n* Get a list of menu items containing buttons for multi instance markers\n*\n* @param  {djs.model.Base} element\n*\n* @return {Array<Object>} a list of menu items\n*/",
            "content": "ReplaceMenuProvider.prototype._getLoopEntries = function(element) {\n\n  var self = this;\n  var translate = this._translate;\n\n  function toggleLoopEntry(event, entry) {\n    var loopCharacteristics;\n\n    if (entry.active) {\n      loopCharacteristics = undefined;\n    } else {\n      loopCharacteristics = self._moddle.create(entry.options.loopCharacteristics);\n\n      if (entry.options.isSequential) {\n        loopCharacteristics.isSequential = entry.options.isSequential;\n      }\n    }\n    self._modeling.updateProperties(element, { loopCharacteristics: loopCharacteristics });\n  }\n\n  var businessObject = getBusinessObject(element),\n      loopCharacteristics = businessObject.loopCharacteristics;\n\n  var isSequential,\n      isLoop,\n      isParallel;\n\n  if (loopCharacteristics) {\n    isSequential = loopCharacteristics.isSequential;\n    isLoop = loopCharacteristics.isSequential === undefined;\n    isParallel = loopCharacteristics.isSequential !== undefined && !loopCharacteristics.isSequential;\n  }\n\n\n  var loopEntries = [\n    {\n      id: 'toggle-parallel-mi',\n      className: 'bpmn-icon-parallel-mi-marker',\n      title: translate('Parallel Multi Instance'),\n      active: isParallel,\n      action: toggleLoopEntry,\n      options: {\n        loopCharacteristics: 'bpmn:MultiInstanceLoopCharacteristics',\n        isSequential: false\n      }\n    },\n    {\n      id: 'toggle-sequential-mi',\n      className: 'bpmn-icon-sequential-mi-marker',\n      title: translate('Sequential Multi Instance'),\n      active: isSequential,\n      action: toggleLoopEntry,\n      options: {\n        loopCharacteristics: 'bpmn:MultiInstanceLoopCharacteristics',\n        isSequential: true\n      }\n    },\n    {\n      id: 'toggle-loop',\n      className: 'bpmn-icon-loop-marker',\n      title: translate('Loop'),\n      active: isLoop,\n      action: toggleLoopEntry,\n      options: {\n        loopCharacteristics: 'bpmn:StandardLoopCharacteristics'\n      }\n    }\n  ];\n  return loopEntries;\n};",
            "name": "function_21",
            "parameters": [
                "element"
            ],
            "start_line": 391,
            "end_line": 460,
            "return": true
        },
        "function_23": {
            "signature": "/**\n* Get the menu items containing a button for the ad hoc marker\n*\n* @param  {djs.model.Base} element\n*\n* @return {Object} a menu item\n*/",
            "content": "ReplaceMenuProvider.prototype._getAdHocEntry = function(element) {\n  var translate = this._translate;\n  var businessObject = getBusinessObject(element);\n\n  var isAdHoc = is(businessObject, 'bpmn:AdHocSubProcess');\n\n  var replaceElement = this._bpmnReplace.replaceElement;\n\n  var adHocEntry = {\n    id: 'toggle-adhoc',\n    className: 'bpmn-icon-ad-hoc-marker',\n    title: translate('Ad-hoc'),\n    active: isAdHoc,\n    action: function(event, entry) {\n      if (isAdHoc) {\n        return replaceElement(element, { type: 'bpmn:SubProcess' });\n      } else {\n        return replaceElement(element, { type: 'bpmn:AdHocSubProcess' });\n      }\n    }\n  };\n\n  return adHocEntry;\n};",
            "name": "function_23",
            "parameters": [
                "element"
            ],
            "start_line": 470,
            "end_line": 493,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\popup-menu\\util\\TypeUtil.js": {
        "function_1": {
            "signature": "/**\n* Returns true, if an element is from a different type\n* than a target definition. Takes into account the type,\n* event definition type and triggeredByEvent property.\n*\n* @param {djs.model.Base} element\n*\n* @return {Boolean}\n*/",
            "content": "export function isDifferentType(element) {\n\n  return function(entry) {\n    var target = entry.target;\n\n    var businessObject = getBusinessObject(element),\n        eventDefinition = businessObject.eventDefinitions && businessObject.eventDefinitions[0];\n\n    var isTypeEqual = businessObject.$type === target.type;\n\n    var isEventDefinitionEqual = (\n      (eventDefinition && eventDefinition.$type) === target.eventDefinitionType\n    );\n\n    var isTriggeredByEventEqual = (\n      businessObject.triggeredByEvent === target.triggeredByEvent\n    );\n\n    var isExpandedEqual = (\n      target.isExpanded === undefined ||\n      target.isExpanded === isExpanded(businessObject)\n    );\n\n    return !isTypeEqual || !isEventDefinitionEqual || !isTriggeredByEventEqual || !isExpandedEqual;\n  };\n}",
            "name": "isDifferentType",
            "parameters": [
                "element"
            ],
            "start_line": 19,
            "end_line": 44,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\replace\\BpmnReplace.js": {
        "function_1": {
            "signature": "",
            "content": "function toggeling(element, target) {\n\n  var oldCollapsed = (\n    element && has(element, 'collapsed') ? element.collapsed : !isExpanded(element)\n  );\n\n  var targetCollapsed;\n\n  if (target && (has(target, 'collapsed') || has(target, 'isExpanded'))) {\n    // property is explicitly set so use it\n    targetCollapsed = (\n      has(target, 'collapsed') ? target.collapsed : !target.isExpanded\n    );\n  } else {\n    // keep old state\n    targetCollapsed = oldCollapsed;\n  }\n\n  if (oldCollapsed !== targetCollapsed) {\n    element.collapsed = oldCollapsed;\n    return true;\n  }\n\n  return false;\n}",
            "name": "toggeling",
            "parameters": [
                "element",
                "target"
            ],
            "start_line": 38,
            "end_line": 62,
            "return": true
        },
        "function_2": {
            "signature": "/**\n* This module takes care of replacing BPMN elements\n*/",
            "content": "export default function BpmnReplace(\n    bpmnFactory, elementFactory, replace,\n    selection, modeling, eventBus\n) {\n\n  var helper = new ModelCloneHelper(eventBus, bpmnFactory);\n\n  /**\n   * Prepares a new business object for the replacement element\n   * and triggers the replace operation.\n   *\n   * @param  {djs.model.Base} element\n   * @param  {Object} target\n   * @param  {Object} [hints]\n   *\n   * @return {djs.model.Base} the newly created element\n   */\n  function replaceElement(element, target, hints) {\n\n    hints = hints || {};\n\n    var type = target.type,\n        oldBusinessObject = element.businessObject;\n\n    if (isSubProcess(oldBusinessObject)) {\n      if (type === 'bpmn:SubProcess') {\n        if (toggeling(element, target)) {\n          // expanding or collapsing process\n          modeling.toggleCollapse(element);\n\n          return element;\n        }\n      }\n    }\n\n    var newBusinessObject = bpmnFactory.create(type);\n\n    var newElement = {\n      type: type,\n      businessObject: newBusinessObject\n    };\n\n    var elementProps = getProperties(oldBusinessObject.$descriptor),\n        newElementProps = getProperties(newBusinessObject.$descriptor, true),\n        copyProps = intersection(elementProps, newElementProps);\n\n    // initialize special properties defined in target definition\n    assign(newBusinessObject, pick(target, CUSTOM_PROPERTIES));\n\n    var properties = filter(copyProps, function(property) {\n      var propName = property.replace(/bpmn:/, '');\n\n      // copying event definitions, unless we replace\n      if (propName === 'eventDefinitions') {\n        return hasEventDefinition(element, target.eventDefinitionType);\n      }\n\n      // retain loop characteristics if the target element\n      // is not an event sub process\n      if (propName === 'loopCharacteristics') {\n        return !isEventSubProcess(newBusinessObject);\n      }\n\n      // so the applied properties from 'target' don't get lost\n      if (property in newBusinessObject) {\n        return false;\n      }\n\n      if (propName === 'processRef' && target.isExpanded === false) {\n        return false;\n      }\n\n      if (propName === 'triggeredByEvent') {\n        return false;\n      }\n\n      return IGNORED_PROPERTIES.indexOf(propName) === -1;\n    });\n\n    newBusinessObject = helper.clone(oldBusinessObject, newBusinessObject, properties);\n\n    // initialize custom BPMN extensions\n    if (target.eventDefinitionType) {\n\n      // only initialize with new eventDefinition\n      // if we did not set an event definition yet,\n      // i.e. because we cloned it\n      if (!hasEventDefinition(newBusinessObject, target.eventDefinitionType)) {\n        newElement.eventDefinitionType = target.eventDefinitionType;\n      }\n    }\n\n    if (is(oldBusinessObject, 'bpmn:Activity')) {\n\n      if (isSubProcess(oldBusinessObject)) {\n        // no toggeling, so keep old state\n        newElement.isExpanded = isExpanded(oldBusinessObject);\n      }\n      // else if property is explicitly set, use it\n      else if (target && has(target, 'isExpanded')) {\n        newElement.isExpanded = target.isExpanded;\n      }\n\n      // TODO: need also to respect min/max Size\n      // copy size, from an expanded subprocess to an expanded alternative subprocess\n      // except bpmn:Task, because Task is always expanded\n      if ((isExpanded(oldBusinessObject) && !is(oldBusinessObject, 'bpmn:Task')) && newElement.isExpanded) {\n        newElement.width = element.width;\n        newElement.height = element.height;\n      }\n    }\n\n    // remove children if not expanding sub process\n    if (isSubProcess(oldBusinessObject) && !isSubProcess(newBusinessObject)) {\n      hints.moveChildren = false;\n    }\n\n    // transform collapsed/expanded pools\n    if (is(oldBusinessObject, 'bpmn:Participant')) {\n\n      // create expanded pool\n      if (target.isExpanded === true) {\n        newBusinessObject.processRef = bpmnFactory.create('bpmn:Process');\n      } else {\n        // remove children when transforming to collapsed pool\n        hints.moveChildren = false;\n      }\n\n      // apply same width and default height\n      newElement.width = element.width;\n      newElement.height = elementFactory._getDefaultSize(newBusinessObject).height;\n    }\n\n    newBusinessObject.name = oldBusinessObject.name;\n\n    // retain default flow's reference between inclusive <-> exclusive gateways and activities\n    if (\n      isAny(oldBusinessObject, [\n        'bpmn:ExclusiveGateway',\n        'bpmn:InclusiveGateway',\n        'bpmn:Activity'\n      ]) &&\n      isAny(newBusinessObject, [\n        'bpmn:ExclusiveGateway',\n        'bpmn:InclusiveGateway',\n        'bpmn:Activity'\n      ])\n    ) {\n      newBusinessObject.default = oldBusinessObject.default;\n    }\n\n    if ('fill' in oldBusinessObject.di || 'stroke' in oldBusinessObject.di) {\n      assign(newElement, { colors: pick(oldBusinessObject.di, [ 'fill', 'stroke' ]) });\n    }\n\n    newElement = replace.replaceElement(element, newElement, hints);\n\n    if (hints.select !== false) {\n      selection.select(newElement);\n    }\n\n    return newElement;\n  }\n\n  this.replaceElement = replaceElement;\n}",
            "name": "BpmnReplace",
            "parameters": [
                "bpmnFactory",
                "elementFactory",
                "replace",
                "selection",
                "modeling",
                "eventBus"
            ],
            "start_line": 69,
            "end_line": 234,
            "return": true
        },
        "function_5": {
            "signature": "",
            "content": "function isSubProcess(bo) {\n  return is(bo, 'bpmn:SubProcess');\n}",
            "name": "isSubProcess",
            "parameters": [
                "bo"
            ],
            "start_line": 246,
            "end_line": 248,
            "return": true
        },
        "function_6": {
            "signature": "",
            "content": "function hasEventDefinition(element, type) {\n\n  var bo = getBusinessObject(element);\n\n  return type && bo.get('eventDefinitions').some(function(definition) {\n    return is(definition, type);\n  });\n}",
            "name": "hasEventDefinition",
            "parameters": [
                "element",
                "type"
            ],
            "start_line": 250,
            "end_line": 257,
            "return": true
        },
        "function_8": {
            "signature": "/**\n* Compute intersection between two arrays.\n*/",
            "content": "function intersection(a1, a2) {\n  return a1.filter(function(el) {\n    return a2.indexOf(el) !== -1;\n  });\n}",
            "name": "intersection",
            "parameters": [
                "a1",
                "a2"
            ],
            "start_line": 262,
            "end_line": 266,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\replace\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\replace\\ReplaceOptions.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\replace-preview\\BpmnReplacePreview.js": {
        "function_1": {
            "signature": "",
            "content": "export default function BpmnReplacePreview(\n    eventBus, elementRegistry, elementFactory,\n    canvas, previewSupport) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * Replace the visuals of all elements in the context which can be replaced\n   *\n   * @param  {Object} context\n   */\n  function replaceVisual(context) {\n\n    var replacements = context.canExecute.replacements;\n\n    forEach(replacements, function(replacement) {\n\n      var id = replacement.oldElementId;\n\n      var newElement = {\n        type: replacement.newElementType\n      };\n\n      // if the visual of the element is already replaced\n      if (context.visualReplacements[id]) {\n        return;\n      }\n\n      var element = elementRegistry.get(id);\n\n      assign(newElement, { x: element.x, y: element.y });\n\n      // create a temporary shape\n      var tempShape = elementFactory.createShape(newElement);\n\n      canvas.addShape(tempShape, element.parent);\n\n      // select the original SVG element related to the element and hide it\n      var gfx = domQuery('[data-element-id=\"' + cssEscape(element.id) + '\"]', context.dragGroup);\n\n      if (gfx) {\n        svgAttr(gfx, { display: 'none' });\n      }\n\n      // clone the gfx of the temporary shape and add it to the drag group\n      var dragger = previewSupport.addDragger(tempShape, context.dragGroup);\n\n      context.visualReplacements[id] = dragger;\n\n      canvas.removeShape(tempShape);\n    });\n  }\n\n  /**\n   * Restore the original visuals of the previously replaced elements\n   *\n   * @param  {Object} context\n   */\n  function restoreVisual(context) {\n\n    var visualReplacements = context.visualReplacements;\n\n    forEach(visualReplacements, function(dragger, id) {\n\n      var originalGfx = domQuery('[data-element-id=\"' + cssEscape(id) + '\"]', context.dragGroup);\n\n      if (originalGfx) {\n        svgAttr(originalGfx, { display: 'inline' });\n      }\n\n      dragger.remove();\n\n      if (visualReplacements[id]) {\n        delete visualReplacements[id];\n      }\n    });\n  }\n\n  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {\n\n    var context = event.context,\n        canExecute = context.canExecute;\n\n    if (!context.visualReplacements) {\n      context.visualReplacements = {};\n    }\n\n    if (canExecute.replacements) {\n      replaceVisual(context);\n    } else {\n      restoreVisual(context);\n    }\n  });\n}",
            "name": "BpmnReplacePreview",
            "parameters": [
                "eventBus",
                "elementRegistry",
                "elementFactory",
                "canvas",
                "previewSupport"
            ],
            "start_line": 23,
            "end_line": 116,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\replace-preview\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\rules\\BpmnRules.js": {
        "function_1": {
            "signature": "/**\n* BPMN specific modeling rule\n*/",
            "content": "export default function BpmnRules(eventBus) {\n  RuleProvider.call(this, eventBus);\n}",
            "name": "BpmnRules",
            "parameters": [
                "eventBus"
            ],
            "start_line": 42,
            "end_line": 44,
            "return": false
        },
        "function_2": {
            "signature": "",
            "content": "BpmnRules.prototype.init = function() {\n\n  this.addRule('connection.start', function(context) {\n    var source = context.source;\n\n    return canStartConnection(source);\n  });\n\n  this.addRule('connection.create', function(context) {\n    var source = context.source,\n        target = context.target,\n        hints = context.hints || {},\n        targetParent = hints.targetParent,\n        targetAttach = hints.targetAttach;\n\n    // don't allow incoming connections on\n    // newly created boundary events\n    // to boundary events\n    if (targetAttach) {\n      return false;\n    }\n\n    // temporarily set target parent for scoping\n    // checks to work\n    if (targetParent) {\n      target.parent = targetParent;\n    }\n\n    try {\n      return canConnect(source, target);\n    } finally {\n      // unset temporary target parent\n      if (targetParent) {\n        target.parent = null;\n      }\n    }\n  });\n\n  this.addRule('connection.reconnectStart', function(context) {\n\n    var connection = context.connection,\n        source = context.hover || context.source,\n        target = connection.target;\n\n    return canConnect(source, target, connection);\n  });\n\n  this.addRule('connection.reconnectEnd', function(context) {\n\n    var connection = context.connection,\n        source = connection.source,\n        target = context.hover || context.target;\n\n    return canConnect(source, target, connection);\n  });\n\n  this.addRule('connection.updateWaypoints', function(context) {\n    // OK! but visually ignore\n    return null;\n  });\n\n  this.addRule('shape.resize', function(context) {\n\n    var shape = context.shape,\n        newBounds = context.newBounds;\n\n    return canResize(shape, newBounds);\n  });\n\n  this.addRule('elements.move', function(context) {\n\n    var target = context.target,\n        shapes = context.shapes,\n        position = context.position;\n\n    return canAttach(shapes, target, null, position) ||\n           canReplace(shapes, target, position) ||\n           canMove(shapes, target, position) ||\n           canInsert(shapes, target, position);\n  });\n\n  this.addRule('shape.create', function(context) {\n    return canCreate(\n      context.shape,\n      context.target,\n      context.source,\n      context.position\n    );\n  });\n\n  this.addRule('shape.attach', function(context) {\n\n    return canAttach(\n      context.shape,\n      context.target,\n      null,\n      context.position\n    );\n  });\n\n  this.addRule('element.copy', function(context) {\n    var collection = context.collection,\n        element = context.element;\n\n    return canCopy(collection, element);\n  });\n\n  this.addRule('element.paste', function(context) {\n    var parent = context.parent,\n        element = context.element,\n        position = context.position,\n        source = context.source,\n        target = context.target;\n\n    if (source || target) {\n      return canConnect(source, target);\n    }\n\n    return canAttach([ element ], parent, null, position) || canCreate(element, parent, null, position);\n  });\n\n  this.addRule('elements.paste', function(context) {\n    var tree = context.tree,\n        target = context.target;\n\n    return canPaste(tree, target);\n  });\n};",
            "name": "function_2",
            "parameters": [],
            "start_line": 50,
            "end_line": 177,
            "return": true
        },
        "function_15": {
            "signature": "/**\n* Checks if given element can be used for starting connection.\n*\n* @param  {Element} source\n* @return {Boolean}\n*/",
            "content": "function canStartConnection(element) {\n  if (nonExistingOrLabel(element)) {\n    return null;\n  }\n\n  return isAny(element, [\n    'bpmn:FlowNode',\n    'bpmn:InteractionNode',\n    'bpmn:DataObjectReference',\n    'bpmn:DataStoreReference'\n  ]);\n}",
            "name": "canStartConnection",
            "parameters": [
                "element"
            ],
            "start_line": 215,
            "end_line": 226,
            "return": true
        },
        "function_16": {
            "signature": "",
            "content": "function nonExistingOrLabel(element) {\n  return !element || isLabel(element);\n}",
            "name": "nonExistingOrLabel",
            "parameters": [
                "element"
            ],
            "start_line": 228,
            "end_line": 230,
            "return": true
        },
        "function_17": {
            "signature": "",
            "content": "function isSame(a, b) {\n  return a === b;\n}",
            "name": "isSame",
            "parameters": [
                "a",
                "b"
            ],
            "start_line": 232,
            "end_line": 234,
            "return": true
        },
        "function_18": {
            "signature": "",
            "content": "function getOrganizationalParent(element) {\n\n  do {\n    if (is(element, 'bpmn:Process')) {\n      return getBusinessObject(element);\n    }\n\n    if (is(element, 'bpmn:Participant')) {\n      return (\n        getBusinessObject(element).processRef ||\n        getBusinessObject(element)\n      );\n    }\n  } while ((element = element.parent));\n\n}",
            "name": "getOrganizationalParent",
            "parameters": [
                "element"
            ],
            "start_line": 236,
            "end_line": 251,
            "return": true
        },
        "function_19": {
            "signature": "",
            "content": "function isTextAnnotation(element) {\n  return is(element, 'bpmn:TextAnnotation');\n}",
            "name": "isTextAnnotation",
            "parameters": [
                "element"
            ],
            "start_line": 253,
            "end_line": 255,
            "return": true
        },
        "function_20": {
            "signature": "",
            "content": "function isCompensationBoundary(element) {\n  return is(element, 'bpmn:BoundaryEvent') &&\n         hasEventDefinition(element, 'bpmn:CompensateEventDefinition');\n}",
            "name": "isCompensationBoundary",
            "parameters": [
                "element"
            ],
            "start_line": 257,
            "end_line": 260,
            "return": true
        },
        "function_21": {
            "signature": "",
            "content": "function isForCompensation(e) {\n  return getBusinessObject(e).isForCompensation;\n}",
            "name": "isForCompensation",
            "parameters": [
                "e"
            ],
            "start_line": 262,
            "end_line": 264,
            "return": true
        },
        "function_22": {
            "signature": "",
            "content": "function isSameOrganization(a, b) {\n  var parentA = getOrganizationalParent(a),\n      parentB = getOrganizationalParent(b);\n\n  return parentA === parentB;\n}",
            "name": "isSameOrganization",
            "parameters": [
                "a",
                "b"
            ],
            "start_line": 266,
            "end_line": 271,
            "return": true
        },
        "function_23": {
            "signature": "",
            "content": "function isMessageFlowSource(element) {\n  return (\n    is(element, 'bpmn:InteractionNode') && (\n      !is(element, 'bpmn:Event') || (\n        is(element, 'bpmn:ThrowEvent') &&\n        hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')\n      )\n    )\n  );\n}",
            "name": "isMessageFlowSource",
            "parameters": [
                "element"
            ],
            "start_line": 273,
            "end_line": 282,
            "return": true
        },
        "function_24": {
            "signature": "",
            "content": "function isMessageFlowTarget(element) {\n  return (\n    is(element, 'bpmn:InteractionNode') &&\n    !isForCompensation(element) && (\n      !is(element, 'bpmn:Event') || (\n        is(element, 'bpmn:CatchEvent') &&\n        hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')\n      )\n    )\n  );\n}",
            "name": "isMessageFlowTarget",
            "parameters": [
                "element"
            ],
            "start_line": 284,
            "end_line": 294,
            "return": true
        },
        "function_25": {
            "signature": "",
            "content": "function getScopeParent(element) {\n\n  var parent = element;\n\n  while ((parent = parent.parent)) {\n\n    if (is(parent, 'bpmn:FlowElementsContainer')) {\n      return getBusinessObject(parent);\n    }\n\n    if (is(parent, 'bpmn:Participant')) {\n      return getBusinessObject(parent).processRef;\n    }\n  }\n\n  return null;\n}",
            "name": "getScopeParent",
            "parameters": [
                "element"
            ],
            "start_line": 296,
            "end_line": 312,
            "return": true
        },
        "function_26": {
            "signature": "",
            "content": "function isSameScope(a, b) {\n  var scopeParentA = getScopeParent(a),\n      scopeParentB = getScopeParent(b);\n\n  return scopeParentA && (scopeParentA === scopeParentB);\n}",
            "name": "isSameScope",
            "parameters": [
                "a",
                "b"
            ],
            "start_line": 314,
            "end_line": 319,
            "return": true
        },
        "function_27": {
            "signature": "",
            "content": "function hasEventDefinition(element, eventDefinition) {\n  var bo = getBusinessObject(element);\n\n  return !!find(bo.eventDefinitions || [], function(definition) {\n    return is(definition, eventDefinition);\n  });\n}",
            "name": "hasEventDefinition",
            "parameters": [
                "element",
                "eventDefinition"
            ],
            "start_line": 321,
            "end_line": 327,
            "return": true
        },
        "function_29": {
            "signature": "",
            "content": "function hasEventDefinitionOrNone(element, eventDefinition) {\n  var bo = getBusinessObject(element);\n\n  return (bo.eventDefinitions || []).every(function(definition) {\n    return is(definition, eventDefinition);\n  });\n}",
            "name": "hasEventDefinitionOrNone",
            "parameters": [
                "element",
                "eventDefinition"
            ],
            "start_line": 329,
            "end_line": 335,
            "return": true
        },
        "function_31": {
            "signature": "",
            "content": "function isSequenceFlowSource(element) {\n  return (\n    is(element, 'bpmn:FlowNode') &&\n    !is(element, 'bpmn:EndEvent') &&\n    !isEventSubProcess(element) &&\n    !(is(element, 'bpmn:IntermediateThrowEvent') &&\n      hasEventDefinition(element, 'bpmn:LinkEventDefinition')\n    ) &&\n    !isCompensationBoundary(element) &&\n    !isForCompensation(element)\n  );\n}",
            "name": "isSequenceFlowSource",
            "parameters": [
                "element"
            ],
            "start_line": 337,
            "end_line": 348,
            "return": true
        },
        "function_32": {
            "signature": "",
            "content": "function isSequenceFlowTarget(element) {\n  return (\n    is(element, 'bpmn:FlowNode') &&\n    !is(element, 'bpmn:StartEvent') &&\n    !is(element, 'bpmn:BoundaryEvent') &&\n    !isEventSubProcess(element) &&\n    !(is(element, 'bpmn:IntermediateCatchEvent') &&\n      hasEventDefinition(element, 'bpmn:LinkEventDefinition')\n    ) &&\n    !isForCompensation(element)\n  );\n}",
            "name": "isSequenceFlowTarget",
            "parameters": [
                "element"
            ],
            "start_line": 350,
            "end_line": 361,
            "return": true
        },
        "function_33": {
            "signature": "",
            "content": "function isEventBasedTarget(element) {\n  return (\n    is(element, 'bpmn:ReceiveTask') || (\n      is(element, 'bpmn:IntermediateCatchEvent') && (\n        hasEventDefinition(element, 'bpmn:MessageEventDefinition') ||\n        hasEventDefinition(element, 'bpmn:TimerEventDefinition') ||\n        hasEventDefinition(element, 'bpmn:ConditionalEventDefinition') ||\n        hasEventDefinition(element, 'bpmn:SignalEventDefinition')\n      )\n    )\n  );\n}",
            "name": "isEventBasedTarget",
            "parameters": [
                "element"
            ],
            "start_line": 363,
            "end_line": 374,
            "return": true
        },
        "function_34": {
            "signature": "",
            "content": "function isConnection(element) {\n  return element.waypoints;\n}",
            "name": "isConnection",
            "parameters": [
                "element"
            ],
            "start_line": 376,
            "end_line": 378,
            "return": true
        },
        "function_35": {
            "signature": "",
            "content": "function getParents(element) {\n\n  var parents = [];\n\n  while (element) {\n    element = element.parent;\n\n    if (element) {\n      parents.push(element);\n    }\n  }\n\n  return parents;\n}",
            "name": "getParents",
            "parameters": [
                "element"
            ],
            "start_line": 380,
            "end_line": 393,
            "return": true
        },
        "function_36": {
            "signature": "",
            "content": "function isParent(possibleParent, element) {\n  var allParents = getParents(element);\n  return allParents.indexOf(possibleParent) !== -1;\n}",
            "name": "isParent",
            "parameters": [
                "possibleParent",
                "element"
            ],
            "start_line": 395,
            "end_line": 398,
            "return": true
        },
        "function_37": {
            "signature": "",
            "content": "function canConnect(source, target, connection) {\n\n  if (nonExistingOrLabel(source) || nonExistingOrLabel(target)) {\n    return null;\n  }\n\n  if (!is(connection, 'bpmn:DataAssociation')) {\n\n    if (canConnectMessageFlow(source, target)) {\n      return { type: 'bpmn:MessageFlow' };\n    }\n\n    if (canConnectSequenceFlow(source, target)) {\n      return { type: 'bpmn:SequenceFlow' };\n    }\n  }\n\n  var connectDataAssociation = canConnectDataAssociation(source, target);\n\n  if (connectDataAssociation) {\n    return connectDataAssociation;\n  }\n\n  if (isCompensationBoundary(source) && isForCompensation(target)) {\n    return {\n      type: 'bpmn:Association',\n      associationDirection: 'One'\n    };\n  }\n\n  if (canConnectAssociation(source, target)) {\n\n    return {\n      type: 'bpmn:Association'\n    };\n  }\n\n  return false;\n}",
            "name": "canConnect",
            "parameters": [
                "source",
                "target",
                "connection"
            ],
            "start_line": 400,
            "end_line": 438,
            "return": true
        },
        "function_38": {
            "signature": "/**\n* Can an element be dropped into the target element\n*\n* @return {Boolean}\n*/",
            "content": "function canDrop(element, target, position) {\n\n  // can move labels everywhere\n  if (isLabel(element)) {\n    return true;\n  }\n\n  // disallow to create elements on collapsed pools\n  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {\n    return false;\n  }\n\n  // allow to create new participants on\n  // on existing collaboration and process diagrams\n  if (is(element, 'bpmn:Participant')) {\n    return is(target, 'bpmn:Process') || is(target, 'bpmn:Collaboration');\n  }\n\n  // allow moving DataInput / DataOutput within its original container only\n  if (isAny(element, [ 'bpmn:DataInput', 'bpmn:DataOutput' ])) {\n\n    if (element.parent) {\n      return target === element.parent;\n    }\n  }\n\n  // allow creating lanes on participants and other lanes only\n  if (is(element, 'bpmn:Lane')) {\n    return is(target, 'bpmn:Participant') || is(target, 'bpmn:Lane');\n  }\n\n  if (is(element, 'bpmn:BoundaryEvent')) {\n    return false;\n  }\n\n  // drop flow elements onto flow element containers\n  // and participants\n  if (is(element, 'bpmn:FlowElement') && !is(element, 'bpmn:DataStoreReference')) {\n    if (is(target, 'bpmn:FlowElementsContainer')) {\n      return isExpanded(target);\n    }\n\n    return isAny(target, [ 'bpmn:Participant', 'bpmn:Lane' ]);\n  }\n\n  // account for the fact that data associations are always\n  // rendered and moved to top (Process or Collaboration level)\n  //\n  // artifacts may be placed wherever, too\n  if (isAny(element, [ 'bpmn:Artifact', 'bpmn:DataAssociation', 'bpmn:DataStoreReference' ])) {\n    return isAny(target, [\n      'bpmn:Collaboration',\n      'bpmn:Lane',\n      'bpmn:Participant',\n      'bpmn:Process',\n      'bpmn:SubProcess' ]);\n  }\n\n  if (is(element, 'bpmn:MessageFlow')) {\n    return is(target, 'bpmn:Collaboration')\n      || element.source.parent == target\n      || element.target.parent == target;\n  }\n\n  return false;\n}",
            "name": "canDrop",
            "parameters": [
                "element",
                "target",
                "position"
            ],
            "start_line": 445,
            "end_line": 510,
            "return": true
        },
        "function_39": {
            "signature": "",
            "content": "function canPaste(tree, target) {\n  var topLevel = tree[0],\n      participants;\n\n  if (is(target, 'bpmn:Collaboration')) {\n    return every(topLevel, function(e) {\n      return e.type === 'bpmn:Participant';\n    });\n  }\n\n  if (is(target, 'bpmn:Process')) {\n    participants = some(topLevel, function(e) {\n      return e.type === 'bpmn:Participant';\n    });\n\n    return !(participants && target.children.length > 0);\n  }\n\n  // disallow to create elements on collapsed pools\n  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {\n    return false;\n  }\n\n  if (is(target, 'bpmn:FlowElementsContainer')) {\n    return isExpanded(target);\n  }\n\n  return isAny(target, [\n    'bpmn:Collaboration',\n    'bpmn:Lane',\n    'bpmn:Participant',\n    'bpmn:Process',\n    'bpmn:SubProcess' ]);\n}",
            "name": "canPaste",
            "parameters": [
                "tree",
                "target"
            ],
            "start_line": 512,
            "end_line": 545,
            "return": true
        },
        "function_42": {
            "signature": "",
            "content": "function isBoundaryEvent(element) {\n  return !isLabel(element) && is(element, 'bpmn:BoundaryEvent');\n}",
            "name": "isBoundaryEvent",
            "parameters": [
                "element"
            ],
            "start_line": 547,
            "end_line": 549,
            "return": true
        },
        "function_43": {
            "signature": "",
            "content": "function isLane(element) {\n  return is(element, 'bpmn:Lane');\n}",
            "name": "isLane",
            "parameters": [
                "element"
            ],
            "start_line": 551,
            "end_line": 553,
            "return": true
        },
        "function_44": {
            "signature": "/**\n* We treat IntermediateThrowEvents as boundary events during create,\n* this must be reflected in the rules.\n*/",
            "content": "function isBoundaryCandidate(element) {\n  return isBoundaryEvent(element) ||\n        (is(element, 'bpmn:IntermediateThrowEvent') && !element.parent);\n}",
            "name": "isBoundaryCandidate",
            "parameters": [
                "element"
            ],
            "start_line": 559,
            "end_line": 562,
            "return": true
        },
        "function_45": {
            "signature": "",
            "content": "function isReceiveTaskAfterEventBasedGateway(element) {\n  return (\n    is(element, 'bpmn:ReceiveTask') &&\n    find(element.incoming, function(incoming) {\n      return is(incoming.source, 'bpmn:EventBasedGateway');\n    })\n  );\n}",
            "name": "isReceiveTaskAfterEventBasedGateway",
            "parameters": [
                "element"
            ],
            "start_line": 564,
            "end_line": 571,
            "return": true
        },
        "function_47": {
            "signature": "",
            "content": "function canAttach(elements, target, source, position) {\n\n  if (!Array.isArray(elements)) {\n    elements = [ elements ];\n  }\n\n  // disallow appending as boundary event\n  if (source) {\n    return false;\n  }\n\n  // only (re-)attach one element at a time\n  if (elements.length !== 1) {\n    return false;\n  }\n\n  var element = elements[0];\n\n  // do not attach labels\n  if (isLabel(element)) {\n    return false;\n  }\n\n  // only handle boundary events\n  if (!isBoundaryCandidate(element)) {\n    return false;\n  }\n\n  // allow default move operation\n  if (!target) {\n    return true;\n  }\n\n  // disallow drop on event sub processes\n  if (isEventSubProcess(target)) {\n    return false;\n  }\n\n  // only allow drop on non compensation activities\n  if (!is(target, 'bpmn:Activity') || isForCompensation(target)) {\n    return false;\n  }\n\n  // only attach to subprocess border\n  if (position && !isBoundaryAttachment(position, target)) {\n    return false;\n  }\n\n  // do not attach on receive tasks after event based gateways\n  if (isReceiveTaskAfterEventBasedGateway(target)) {\n    return false;\n  }\n\n  return 'attach';\n}",
            "name": "canAttach",
            "parameters": [
                "elements",
                "target",
                "source",
                "position"
            ],
            "start_line": 574,
            "end_line": 628,
            "return": true
        },
        "function_48": {
            "signature": "/**\n* Defines how to replace elements for a given target.\n*\n* Returns an array containing all elements which will be replaced.\n*\n* @example\n*\n*  [{ id: 'IntermediateEvent_2',\n*     type: 'bpmn:StartEvent'\n*   },\n*   { id: 'IntermediateEvent_5',\n*     type: 'bpmn:EndEvent'\n*   }]\n*\n* @param  {Array} elements\n* @param  {Object} target\n*\n* @return {Object} an object containing all elements which have to be replaced\n*/",
            "content": "function canReplace(elements, target, position) {\n\n  if (!target) {\n    return false;\n  }\n\n  var canExecute = {\n    replacements: []\n  };\n\n  forEach(elements, function(element) {\n\n    if (!isEventSubProcess(target)) {\n\n      if (is(element, 'bpmn:StartEvent') &&\n          element.type !== 'label' &&\n          canDrop(element, target)) {\n\n        // replace a non-interrupting start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (!isInterrupting(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n\n        // replace an error/escalation/compansate start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (hasErrorEventDefinition(element) ||\n            hasEscalationEventDefinition(element) ||\n            hasCompensateEventDefinition(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n      }\n    }\n\n    if (!is(target, 'bpmn:Transaction')) {\n      if (hasEventDefinition(element, 'bpmn:CancelEventDefinition') &&\n          element.type !== 'label') {\n\n        if (is(element, 'bpmn:EndEvent') && canDrop(element, target)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:EndEvent'\n          });\n        }\n\n        if (is(element, 'bpmn:BoundaryEvent') && canAttach(element, target, null, position)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:BoundaryEvent'\n          });\n        }\n      }\n    }\n  });\n\n  return canExecute.replacements.length ? canExecute : false;\n}",
            "name": "canReplace",
            "parameters": [
                "elements",
                "target",
                "position"
            ],
            "start_line": 650,
            "end_line": 712,
            "return": true
        },
        "function_50": {
            "signature": "",
            "content": "function canMove(elements, target) {\n\n  // do not move selection containing boundary events\n  if (some(elements, isBoundaryEvent)) {\n    return false;\n  }\n\n  // do not move selection containing lanes\n  if (some(elements, isLane)) {\n    return false;\n  }\n\n  // allow default move check to start move operation\n  if (!target) {\n    return true;\n  }\n\n  return elements.every(function(element) {\n    return canDrop(element, target);\n  });\n}",
            "name": "canMove",
            "parameters": [
                "elements",
                "target"
            ],
            "start_line": 714,
            "end_line": 734,
            "return": true
        },
        "function_52": {
            "signature": "",
            "content": "function canCreate(shape, target, source, position) {\n\n  if (!target) {\n    return false;\n  }\n\n  if (isLabel(target)) {\n    return null;\n  }\n\n  if (isSame(source, target)) {\n    return false;\n  }\n\n  // ensure we do not drop the element\n  // into source\n  if (source && isParent(source, target)) {\n    return false;\n  }\n\n  return canDrop(shape, target, position) || canInsert(shape, target, position);\n}",
            "name": "canCreate",
            "parameters": [
                "shape",
                "target",
                "source",
                "position"
            ],
            "start_line": 736,
            "end_line": 757,
            "return": true
        },
        "function_53": {
            "signature": "",
            "content": "function canResize(shape, newBounds) {\n  if (is(shape, 'bpmn:SubProcess')) {\n    return (\n      isExpanded(shape) && (\n        !newBounds || (newBounds.width >= 100 && newBounds.height >= 80)\n      )\n    );\n  }\n\n  if (is(shape, 'bpmn:Lane')) {\n    return !newBounds || (newBounds.width >= 130 && newBounds.height >= 60);\n  }\n\n  if (is(shape, 'bpmn:Participant')) {\n    return !newBounds || (newBounds.width >= 250 && newBounds.height >= 50);\n  }\n\n  if (isTextAnnotation(shape)) {\n    return true;\n  }\n\n  return false;\n}",
            "name": "canResize",
            "parameters": [
                "shape",
                "newBounds"
            ],
            "start_line": 759,
            "end_line": 781,
            "return": true
        },
        "function_54": {
            "signature": "/**\n* Check, whether one side of the relationship\n* is a text annotation.\n*/",
            "content": "function isOneTextAnnotation(source, target) {\n\n  var sourceTextAnnotation = isTextAnnotation(source),\n      targetTextAnnotation = isTextAnnotation(target);\n\n  return (\n    (sourceTextAnnotation || targetTextAnnotation) &&\n    (sourceTextAnnotation !== targetTextAnnotation)\n  );\n}",
            "name": "isOneTextAnnotation",
            "parameters": [
                "source",
                "target"
            ],
            "start_line": 787,
            "end_line": 796,
            "return": true
        },
        "function_55": {
            "signature": "",
            "content": "function canConnectAssociation(source, target) {\n\n  // do not connect connections\n  if (isConnection(source) || isConnection(target)) {\n    return false;\n  }\n\n  // compensation boundary events are exception\n  if (isCompensationBoundary(source) && isForCompensation(target)) {\n    return true;\n  }\n\n  // don't connect parent <-> child\n  if (isParent(target, source) || isParent(source, target)) {\n    return false;\n  }\n\n  // allow connection of associations between <!TextAnnotation> and <TextAnnotation>\n  return isOneTextAnnotation(source, target);\n}",
            "name": "canConnectAssociation",
            "parameters": [
                "source",
                "target"
            ],
            "start_line": 799,
            "end_line": 818,
            "return": true
        },
        "function_56": {
            "signature": "",
            "content": "function canConnectMessageFlow(source, target) {\n\n  return isMessageFlowSource(source) &&\n         isMessageFlowTarget(target) &&\n        !isSameOrganization(source, target);\n}",
            "name": "canConnectMessageFlow",
            "parameters": [
                "source",
                "target"
            ],
            "start_line": 820,
            "end_line": 825,
            "return": true
        },
        "function_57": {
            "signature": "",
            "content": "function canConnectSequenceFlow(source, target) {\n\n  if (\n    isEventBasedTarget(target) &&\n    target.incoming.length > 0 &&\n    areOutgoingEventBasedGatewayConnections(target.incoming) &&\n    !is(source, 'bpmn:EventBasedGateway')\n  ) {\n    return false;\n  }\n\n  return isSequenceFlowSource(source) &&\n         isSequenceFlowTarget(target) &&\n         isSameScope(source, target) &&\n         !(is(source, 'bpmn:EventBasedGateway') && !isEventBasedTarget(target));\n}",
            "name": "canConnectSequenceFlow",
            "parameters": [
                "source",
                "target"
            ],
            "start_line": 827,
            "end_line": 842,
            "return": true
        },
        "function_58": {
            "signature": "",
            "content": "function canConnectDataAssociation(source, target) {\n\n  if (isAny(source, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ]) &&\n      isAny(target, [ 'bpmn:Activity', 'bpmn:ThrowEvent' ])) {\n    return { type: 'bpmn:DataInputAssociation' };\n  }\n\n  if (isAny(target, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ]) &&\n      isAny(source, [ 'bpmn:Activity', 'bpmn:CatchEvent' ])) {\n    return { type: 'bpmn:DataOutputAssociation' };\n  }\n\n  return false;\n}",
            "name": "canConnectDataAssociation",
            "parameters": [
                "source",
                "target"
            ],
            "start_line": 845,
            "end_line": 858,
            "return": true
        },
        "function_59": {
            "signature": "",
            "content": "function canInsert(shape, flow, position) {\n\n  if (!flow) {\n    return false;\n  }\n\n  if (Array.isArray(shape)) {\n    if (shape.length !== 1) {\n      return false;\n    }\n\n    shape = shape[0];\n  }\n\n  if (flow.source === shape ||\n      flow.target === shape) {\n    return false;\n  }\n\n  // return true if we can drop on the\n  // underlying flow parent\n  //\n  // at this point we are not really able to talk\n  // about connection rules (yet)\n\n  return (\n    isAny(flow, [ 'bpmn:SequenceFlow', 'bpmn:MessageFlow' ]) &&\n    !isLabel(flow) &&\n    is(shape, 'bpmn:FlowNode') &&\n    !is(shape, 'bpmn:BoundaryEvent') &&\n    canDrop(shape, flow.parent, position));\n}",
            "name": "canInsert",
            "parameters": [
                "shape",
                "flow",
                "position"
            ],
            "start_line": 860,
            "end_line": 891,
            "return": true
        },
        "function_60": {
            "signature": "",
            "content": "function contains(collection, element) {\n  return (collection && element) && collection.indexOf(element) !== -1;\n}",
            "name": "contains",
            "parameters": [
                "collection",
                "element"
            ],
            "start_line": 893,
            "end_line": 895,
            "return": true
        },
        "function_61": {
            "signature": "",
            "content": "function canCopy(collection, element) {\n  if (is(element, 'bpmn:Lane') && !contains(collection, element.parent)) {\n    return false;\n  }\n\n  if (is(element, 'bpmn:BoundaryEvent') && !contains(collection, element.host)) {\n    return false;\n  }\n\n  return true;\n}",
            "name": "canCopy",
            "parameters": [
                "collection",
                "element"
            ],
            "start_line": 897,
            "end_line": 907,
            "return": true
        },
        "function_62": {
            "signature": "",
            "content": "function isOutgoingEventBasedGatewayConnection(connection) {\n\n  if (connection && connection.source) {\n    return is(connection.source, 'bpmn:EventBasedGateway');\n  }\n}",
            "name": "isOutgoingEventBasedGatewayConnection",
            "parameters": [
                "connection"
            ],
            "start_line": 909,
            "end_line": 914,
            "return": true
        },
        "function_63": {
            "signature": "",
            "content": "function areOutgoingEventBasedGatewayConnections(connections) {\n\n  connections = connections || [];\n\n  return connections.some(isOutgoingEventBasedGatewayConnection);\n}",
            "name": "areOutgoingEventBasedGatewayConnections",
            "parameters": [
                "connections"
            ],
            "start_line": 916,
            "end_line": 921,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\rules\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\search\\BpmnSearchProvider.js": {
        "function_1": {
            "signature": "/**\n* Provides ability to search through BPMN elements\n*/",
            "content": "export default function BpmnSearchProvider(elementRegistry, searchPad, canvas) {\n\n  this._elementRegistry = elementRegistry;\n  this._canvas = canvas;\n\n  searchPad.registerProvider(this);\n}",
            "name": "BpmnSearchProvider",
            "parameters": [
                "elementRegistry",
                "searchPad",
                "canvas"
            ],
            "start_line": 15,
            "end_line": 21,
            "return": false
        },
        "function_2": {
            "signature": "/**\n* Finds all elements that match given pattern\n*\n* <Result> :\n*  {\n*    primaryTokens: <Array<Token>>,\n*    secondaryTokens: <Array<Token>>,\n*    element: <Element>\n*  }\n*\n* <Token> :\n*  {\n*    normal|matched: <String>\n*  }\n*\n* @param  {String} pattern\n* @return {Array<Result>}\n*/",
            "content": "BpmnSearchProvider.prototype.find = function(pattern) {\n  var rootElement = this._canvas.getRootElement();\n\n  var elements = this._elementRegistry.filter(function(element) {\n    if (element.labelTarget) {\n      return false;\n    }\n    return true;\n  });\n\n  // do not include root element\n  elements = filter(elements, function(element) {\n    return element !== rootElement;\n  });\n\n  elements = map(elements, function(element) {\n    return {\n      primaryTokens: matchAndSplit(getLabel(element), pattern),\n      secondaryTokens: matchAndSplit(element.id, pattern),\n      element: element\n    };\n  });\n\n  // exclude non-matched elements\n  elements = filter(elements, function(element) {\n    return hasMatched(element.primaryTokens) || hasMatched(element.secondaryTokens);\n  });\n\n  elements = sortBy(elements, function(element) {\n    return getLabel(element.element) + element.element.id;\n  });\n\n  return elements;\n};",
            "name": "function_2",
            "parameters": [
                "pattern"
            ],
            "start_line": 48,
            "end_line": 81,
            "return": true
        },
        "function_8": {
            "signature": "",
            "content": "function hasMatched(tokens) {\n  var matched = filter(tokens, function(t) {\n    return !!t.matched;\n  });\n\n  return matched.length > 0;\n}",
            "name": "hasMatched",
            "parameters": [
                "tokens"
            ],
            "start_line": 84,
            "end_line": 90,
            "return": true
        },
        "function_10": {
            "signature": "",
            "content": "function matchAndSplit(text, pattern) {\n  var tokens = [],\n      originalText = text;\n\n  if (!text) {\n    return tokens;\n  }\n\n  text = text.toLowerCase();\n  pattern = pattern.toLowerCase();\n\n  var i = text.indexOf(pattern);\n\n  if (i > -1) {\n    if (i !== 0) {\n      tokens.push({\n        normal: originalText.substr(0, i)\n      });\n    }\n\n    tokens.push({\n      matched: originalText.substr(i, pattern.length)\n    });\n\n    if (pattern.length + i < text.length) {\n      tokens.push({\n        normal: originalText.substr(pattern.length + i, text.length)\n      });\n    }\n  } else {\n    tokens.push({\n      normal: originalText\n    });\n  }\n\n  return tokens;\n}",
            "name": "matchAndSplit",
            "parameters": [
                "text",
                "pattern"
            ],
            "start_line": 93,
            "end_line": 129,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\search\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\snapping\\BpmnSnapping.js": {
        "function_1": {
            "signature": "/**\n* BPMN specific snapping functionality\n*\n*  * snap on process elements if a pool is created inside a\n*    process diagram\n*\n* @param {EventBus} eventBus\n* @param {Canvas} canvas\n*/",
            "content": "export default function BpmnSnapping(eventBus, canvas, bpmnRules, elementRegistry) {\n\n  // instantiate super\n  Snapping.call(this, eventBus, canvas);\n\n\n  /**\n   * Drop participant on process <> process elements snapping\n   */\n  eventBus.on('create.start', function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        rootElement = canvas.getRootElement();\n\n    // snap participant around existing elements (if any)\n    if (is(shape, 'bpmn:Participant') && is(rootElement, 'bpmn:Process')) {\n      initParticipantSnapping(context, shape, rootElement.children);\n    }\n  });\n\n  eventBus.on([ 'create.move', 'create.end' ], HIGH_PRIORITY, function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        participantSnapBox = context.participantSnapBox;\n\n    if (!isSnapped(event) && participantSnapBox) {\n      snapParticipant(participantSnapBox, shape, event);\n    }\n  });\n\n  eventBus.on('shape.move.start', function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        rootElement = canvas.getRootElement();\n\n    // snap participant around existing elements (if any)\n    if (is(shape, 'bpmn:Participant') && is(rootElement, 'bpmn:Process')) {\n      initParticipantSnapping(context, shape, rootElement.children);\n    }\n  });\n\n\n  function canAttach(shape, target, position) {\n    return bpmnRules.canAttach([ shape ], target, null, position) === 'attach';\n  }\n\n  function canConnect(source, target) {\n    return bpmnRules.canConnect(source, target);\n  }\n\n  /**\n   * Snap boundary events to elements border\n   */\n  eventBus.on([\n    'create.move',\n    'create.end',\n    'shape.move.move',\n    'shape.move.end'\n  ], HIGH_PRIORITY, function(event) {\n\n    var context = event.context,\n        target = context.target,\n        shape = context.shape;\n\n    if (target && !isSnapped(event) && canAttach(shape, target, event)) {\n      snapBoundaryEvent(event, shape, target);\n    }\n  });\n\n  /**\n   * Adjust parent for flowElements to the target participant\n   * when droping onto lanes.\n   */\n  eventBus.on([\n    'shape.move.hover',\n    'shape.move.move',\n    'shape.move.end',\n    'create.hover',\n    'create.move',\n    'create.end'\n  ], HIGH_PRIORITY, function(event) {\n    var context = event.context,\n        shape = context.shape,\n        hover = event.hover;\n\n    if (is(hover, 'bpmn:Lane') && !isAny(shape, [ 'bpmn:Lane', 'bpmn:Participant' ])) {\n      event.hover = getLanesRoot(hover);\n      event.hoverGfx = elementRegistry.getGraphics(event.hover);\n    }\n  });\n\n  /**\n   * Snap sequence flows.\n   */\n  eventBus.on([\n    'connect.move',\n    'connect.hover',\n    'connect.end'\n  ], HIGH_PRIORITY, function(event) {\n    var context = event.context,\n        source = context.source,\n        target = context.target;\n\n    var connection = canConnect(source, target) || {};\n\n    if (!context.initialSourcePosition) {\n      context.initialSourcePosition = context.sourcePosition;\n    }\n\n    if (\n      target && (\n        connection.type === 'bpmn:Association' ||\n        connection.type === 'bpmn:DataOutputAssociation' ||\n        connection.type === 'bpmn:DataInputAssociation' ||\n        connection.type === 'bpmn:SequenceFlow'\n      )\n    ) {\n      // snap source\n      context.sourcePosition = mid(source);\n\n      // snap target\n      snapToPosition(event, mid(target));\n    } else\n\n    if (connection.type === 'bpmn:MessageFlow') {\n\n      if (is(source, 'bpmn:Event')) {\n        // snap source\n        context.sourcePosition = mid(source);\n      }\n\n      if (is(target, 'bpmn:Event')) {\n        // snap target\n        snapToPosition(event, mid(target));\n      }\n    }\n\n    else {\n      // otherwise reset source snap\n      context.sourcePosition = context.initialSourcePosition;\n    }\n\n  });\n\n\n  eventBus.on('resize.start', HIGH_PRIORITY, function(event) {\n    var context = event.context,\n        shape = context.shape;\n\n    if (is(shape, 'bpmn:SubProcess') && isExpanded(shape)) {\n      context.minDimensions = { width: 140, height: 120 };\n    }\n\n    if (is(shape, 'bpmn:Participant')) {\n      context.minDimensions = { width: 300, height: 150 };\n    }\n\n    if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {\n      context.resizeConstraints = getParticipantSizeConstraints(\n        shape,\n        context.direction,\n        context.balanced\n      );\n    }\n\n    if (is(shape, 'bpmn:TextAnnotation')) {\n      context.minDimensions = { width: 50, height: 30 };\n    }\n  });\n\n}",
            "name": "BpmnSnapping",
            "parameters": [
                "eventBus",
                "canvas",
                "bpmnRules",
                "elementRegistry"
            ],
            "start_line": 57,
            "end_line": 230,
            "return": true
        },
        "function_11": {
            "signature": "",
            "content": "BpmnSnapping.prototype.initSnap = function(event) {\n\n  var context = event.context,\n      shape = event.shape,\n      shapeMid,\n      shapeBounds,\n      shapeTopLeft,\n      shapeBottomRight,\n      snapContext;\n\n\n  snapContext = Snapping.prototype.initSnap.call(this, event);\n\n  if (is(shape, 'bpmn:Participant')) {\n    // assign higher priority for outer snaps on participants\n    snapContext.setSnapLocations([ 'top-left', 'bottom-right', 'mid' ]);\n  }\n\n\n  if (shape) {\n\n    shapeMid = mid(shape, event);\n\n    shapeBounds = {\n      width: shape.width,\n      height: shape.height,\n      x: isNaN(shape.x) ? round(shapeMid.x - shape.width / 2) : shape.x,\n      y: isNaN(shape.y) ? round(shapeMid.y - shape.height / 2) : shape.y\n    };\n\n    shapeTopLeft = topLeft(shapeBounds);\n    shapeBottomRight = bottomRight(shapeBounds);\n\n    snapContext.setSnapOrigin('top-left', {\n      x: shapeTopLeft.x - event.x,\n      y: shapeTopLeft.y - event.y\n    });\n\n    snapContext.setSnapOrigin('bottom-right', {\n      x: shapeBottomRight.x - event.x,\n      y: shapeBottomRight.y - event.y\n    });\n\n    forEach(shape.outgoing, function(c) {\n      var docking = c.waypoints[0];\n\n      docking = docking.original || docking;\n\n      snapContext.setSnapOrigin(c.id + '-docking', {\n        x: docking.x - event.x,\n        y: docking.y - event.y\n      });\n    });\n\n    forEach(shape.incoming, function(c) {\n      var docking = c.waypoints[c.waypoints.length - 1];\n\n      docking = docking.original || docking;\n\n      snapContext.setSnapOrigin(c.id + '-docking', {\n        x: docking.x - event.x,\n        y: docking.y - event.y\n      });\n    });\n\n  }\n\n  var source = context.source;\n\n  if (source) {\n    snapContext.addDefaultSnap('mid', mid(source));\n  }\n};",
            "name": "function_11",
            "parameters": [
                "event"
            ],
            "start_line": 242,
            "end_line": 314,
            "return": false
        },
        "function_14": {
            "signature": "",
            "content": "BpmnSnapping.prototype.addTargetSnaps = function(snapPoints, shape, target) {\n\n  // use target parent as snap target\n  if (is(shape, 'bpmn:BoundaryEvent') && shape.type !== 'label') {\n    target = target.parent;\n  }\n\n  // add sequence flow parents as snap targets\n  if (is(target, 'bpmn:SequenceFlow')) {\n    this.addTargetSnaps(snapPoints, shape, target.parent);\n  }\n\n  var siblings = this.getSiblings(shape, target) || [];\n\n  forEach(siblings, function(sibling) {\n\n    // do not snap to lanes\n    if (is(sibling, 'bpmn:Lane')) {\n      return;\n    }\n\n    if (sibling.waypoints) {\n\n      forEach(sibling.waypoints.slice(1, -1), function(waypoint, i) {\n        var nextWaypoint = sibling.waypoints[i + 2],\n            previousWaypoint = sibling.waypoints[i];\n\n        if (!nextWaypoint || !previousWaypoint) {\n          throw new Error('waypoints must exist');\n        }\n\n        if (nextWaypoint.x === waypoint.x ||\n            nextWaypoint.y === waypoint.y ||\n            previousWaypoint.x === waypoint.x ||\n            previousWaypoint.y === waypoint.y) {\n          snapPoints.add('mid', waypoint);\n        }\n      });\n\n      return;\n    }\n\n    snapPoints.add('mid', mid(sibling));\n\n    if (is(sibling, 'bpmn:Participant')) {\n      snapPoints.add('top-left', topLeft(sibling));\n      snapPoints.add('bottom-right', bottomRight(sibling));\n    }\n  });\n\n\n  forEach(shape.incoming, function(c) {\n\n    if (siblings.indexOf(c.source) === -1) {\n      snapPoints.add('mid', mid(c.source));\n    }\n\n    var docking = c.waypoints[0];\n    snapPoints.add(c.id + '-docking', docking.original || docking);\n  });\n\n\n  forEach(shape.outgoing, function(c) {\n\n    if (siblings.indexOf(c.target) === -1) {\n      snapPoints.add('mid', mid(c.target));\n    }\n\n    var docking = c.waypoints[c.waypoints.length - 1];\n    snapPoints.add(c.id + '-docking', docking.original || docking);\n  });\n};",
            "name": "function_14",
            "parameters": [
                "snapPoints",
                "shape",
                "target"
            ],
            "start_line": 317,
            "end_line": 388,
            "return": true
        },
        "function_19": {
            "signature": "// participant snapping //////////////////////",
            "content": "function initParticipantSnapping(context, shape, elements) {\n\n  if (!elements.length) {\n    return;\n  }\n\n  var snapBox = getBoundingBox(elements.filter(function(e) {\n    return !e.labelTarget && !e.waypoints;\n  }));\n\n  snapBox.x -= 50;\n  snapBox.y -= 20;\n  snapBox.width += 70;\n  snapBox.height += 40;\n\n  // adjust shape height to include bounding box\n  shape.width = Math.max(shape.width, snapBox.width);\n  shape.height = Math.max(shape.height, snapBox.height);\n\n  context.participantSnapBox = snapBox;\n}",
            "name": "initParticipantSnapping",
            "parameters": [
                "context",
                "shape",
                "elements"
            ],
            "start_line": 393,
            "end_line": 413,
            "return": true
        },
        "function_21": {
            "signature": "",
            "content": "function snapParticipant(snapBox, shape, event, offset) {\n  offset = offset || 0;\n\n  var shapeHalfWidth = shape.width / 2 - offset,\n      shapeHalfHeight = shape.height / 2;\n\n  var currentTopLeft = {\n    x: event.x - shapeHalfWidth - offset,\n    y: event.y - shapeHalfHeight\n  };\n\n  var currentBottomRight = {\n    x: event.x + shapeHalfWidth + offset,\n    y: event.y + shapeHalfHeight\n  };\n\n  var snapTopLeft = snapBox,\n      snapBottomRight = bottomRight(snapBox);\n\n  if (currentTopLeft.x >= snapTopLeft.x) {\n    setSnapped(event, 'x', snapTopLeft.x + offset + shapeHalfWidth);\n  } else\n  if (currentBottomRight.x <= snapBottomRight.x) {\n    setSnapped(event, 'x', snapBottomRight.x - offset - shapeHalfWidth);\n  }\n\n  if (currentTopLeft.y >= snapTopLeft.y) {\n    setSnapped(event, 'y', snapTopLeft.y + shapeHalfHeight);\n  } else\n  if (currentBottomRight.y <= snapBottomRight.y) {\n    setSnapped(event, 'y', snapBottomRight.y - shapeHalfHeight);\n  }\n}",
            "name": "snapParticipant",
            "parameters": [
                "snapBox",
                "shape",
                "event",
                "offset"
            ],
            "start_line": 415,
            "end_line": 447,
            "return": false
        },
        "function_22": {
            "signature": "// boundary event snapping //////////////////////",
            "content": "function snapBoundaryEvent(event, shape, target) {\n  var targetTRBL = asTRBL(target);\n\n  var direction = getBoundaryAttachment(event, target);\n\n  if (/top/.test(direction)) {\n    setSnapped(event, 'y', targetTRBL.top);\n  } else\n  if (/bottom/.test(direction)) {\n    setSnapped(event, 'y', targetTRBL.bottom);\n  }\n\n  if (/left/.test(direction)) {\n    setSnapped(event, 'x', targetTRBL.left);\n  } else\n  if (/right/.test(direction)) {\n    setSnapped(event, 'x', targetTRBL.right);\n  }\n}",
            "name": "snapBoundaryEvent",
            "parameters": [
                "event",
                "shape",
                "target"
            ],
            "start_line": 452,
            "end_line": 470,
            "return": false
        },
        "function_23": {
            "signature": "",
            "content": "function snapToPosition(event, position) {\n  setSnapped(event, 'x', position.x);\n  setSnapped(event, 'y', position.y);\n}",
            "name": "snapToPosition",
            "parameters": [
                "event",
                "position"
            ],
            "start_line": 473,
            "end_line": 476,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\snapping\\BpmnSnappingUtil.js": {
        "function_1": {
            "signature": "",
            "content": "export function getBoundaryAttachment(position, targetBounds) {\n\n  var orientation = getOrientation(position, targetBounds, -15);\n\n  if (orientation !== 'intersect') {\n    return orientation;\n  } else {\n    return null;\n  }\n}",
            "name": "getBoundaryAttachment",
            "parameters": [
                "position",
                "targetBounds"
            ],
            "start_line": 6,
            "end_line": 15,
            "return": true
        },
        "function_2": {
            "signature": "",
            "content": "function addToTrbl(trbl, attr, value, choice) {\n\n  var current = trbl[attr];\n\n  // make sure to set the value if it does not exist\n  // or apply the correct value by comparing against\n  // choice(value, currentValue)\n  trbl[attr] = current === undefined ? value : choice(value, current);\n}",
            "name": "addToTrbl",
            "parameters": [
                "trbl",
                "attr",
                "value",
                "choice"
            ],
            "start_line": 36,
            "end_line": 44,
            "return": false
        },
        "function_3": {
            "signature": "",
            "content": "function addMin(trbl, attr, value) {\n  return addToTrbl(trbl, attr, value, min);\n}",
            "name": "addMin",
            "parameters": [
                "trbl",
                "attr",
                "value"
            ],
            "start_line": 46,
            "end_line": 48,
            "return": true
        },
        "function_4": {
            "signature": "",
            "content": "function addMax(trbl, attr, value) {\n  return addToTrbl(trbl, attr, value, max);\n}",
            "name": "addMax",
            "parameters": [
                "trbl",
                "attr",
                "value"
            ],
            "start_line": 50,
            "end_line": 52,
            "return": true
        },
        "function_5": {
            "signature": "",
            "content": "export function getParticipantSizeConstraints(laneShape, resizeDirection, balanced) {\n\n  var lanesRoot = getLanesRoot(laneShape);\n\n  var isFirst = true,\n      isLast = true;\n\n  // max top/bottom size for lanes\n\n  var allLanes = collectLanes(lanesRoot, [ lanesRoot ]);\n\n  var laneTrbl = asTRBL(laneShape);\n\n  var maxTrbl = {},\n      minTrbl = {};\n\n  if (/e/.test(resizeDirection)) {\n    minTrbl.right = laneTrbl.left + LANE_MIN_WIDTH;\n  } else\n  if (/w/.test(resizeDirection)) {\n    minTrbl.left = laneTrbl.right - LANE_MIN_WIDTH;\n  }\n\n  allLanes.forEach(function(other) {\n\n    var otherTrbl = asTRBL(other);\n\n    if (/n/.test(resizeDirection)) {\n\n      if (otherTrbl.top < (laneTrbl.top - 10)) {\n        isFirst = false;\n      }\n\n      // max top size (based on next element)\n      if (balanced && abs(laneTrbl.top - otherTrbl.bottom) < 10) {\n        addMax(maxTrbl, 'top', otherTrbl.top + LANE_MIN_HEIGHT);\n      }\n\n      // min top size (based on self or nested element)\n      if (abs(laneTrbl.top - otherTrbl.top) < 5) {\n        addMin(minTrbl, 'top', otherTrbl.bottom - LANE_MIN_HEIGHT);\n      }\n    }\n\n    if (/s/.test(resizeDirection)) {\n\n      if (otherTrbl.bottom > (laneTrbl.bottom + 10)) {\n        isLast = false;\n      }\n\n      // max bottom size (based on previous element)\n      if (balanced && abs(laneTrbl.bottom - otherTrbl.top) < 10) {\n        addMin(maxTrbl, 'bottom', otherTrbl.bottom - LANE_MIN_HEIGHT);\n      }\n\n      // min bottom size (based on self or nested element)\n      if (abs(laneTrbl.bottom - otherTrbl.bottom) < 5) {\n        addMax(minTrbl, 'bottom', otherTrbl.top + LANE_MIN_HEIGHT);\n      }\n    }\n  });\n\n\n  // max top/bottom/left/right size based on flow nodes\n\n  var flowElements = lanesRoot.children.filter(function(s) {\n    return !s.hidden && !s.waypoints && (is(s, 'bpmn:FlowElement') || is(s, 'bpmn:Artifact'));\n  });\n\n  flowElements.forEach(function(flowElement) {\n\n    var flowElementTrbl = asTRBL(flowElement);\n\n    if (isFirst && /n/.test(resizeDirection)) {\n      addMin(minTrbl, 'top', flowElementTrbl.top - LANE_TOP_PADDING);\n    }\n\n    if (/e/.test(resizeDirection)) {\n      addMax(minTrbl, 'right', flowElementTrbl.right + LANE_RIGHT_PADDING);\n    }\n\n    if (isLast && /s/.test(resizeDirection)) {\n      addMax(minTrbl, 'bottom', flowElementTrbl.bottom + LANE_BOTTOM_PADDING);\n    }\n\n    if (/w/.test(resizeDirection)) {\n      addMin(minTrbl, 'left', flowElementTrbl.left - LANE_LEFT_PADDING);\n    }\n  });\n\n\n  return {\n    min: minTrbl,\n    max: maxTrbl\n  };\n}",
            "name": "getParticipantSizeConstraints",
            "parameters": [
                "laneShape",
                "resizeDirection",
                "balanced"
            ],
            "start_line": 63,
            "end_line": 158,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\features\\snapping\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\import\\BpmnImporter.js": {
        "function_1": {
            "signature": "",
            "content": "function elementData(semantic, attrs) {\n  return assign({\n    id: semantic.id,\n    type: semantic.$type,\n    businessObject: semantic\n  }, attrs);\n}",
            "name": "elementData",
            "parameters": [
                "semantic",
                "attrs"
            ],
            "start_line": 25,
            "end_line": 31,
            "return": true
        },
        "function_2": {
            "signature": "",
            "content": "function getWaypoints(bo, source, target) {\n\n  var waypoints = bo.di.waypoint;\n\n  if (!waypoints || waypoints.length < 2) {\n    return [ getMid(source), getMid(target) ];\n  }\n\n  return waypoints.map(function(p) {\n    return { x: p.x, y: p.y };\n  });\n}",
            "name": "getWaypoints",
            "parameters": [
                "bo",
                "source",
                "target"
            ],
            "start_line": 33,
            "end_line": 44,
            "return": true
        },
        "function_4": {
            "signature": "",
            "content": "function notYetDrawn(translate, semantic, refSemantic, property) {\n  return new Error(translate('element {element} referenced by {referenced}#{property} not yet drawn', {\n    element: elementToString(refSemantic),\n    referenced: elementToString(semantic),\n    property: property\n  }));\n}",
            "name": "notYetDrawn",
            "parameters": [
                "translate",
                "semantic",
                "refSemantic",
                "property"
            ],
            "start_line": 46,
            "end_line": 52,
            "return": true
        },
        "function_5": {
            "signature": "/**\n* An importer that adds bpmn elements to the canvas\n*\n* @param {EventBus} eventBus\n* @param {Canvas} canvas\n* @param {ElementFactory} elementFactory\n* @param {ElementRegistry} elementRegistry\n* @param {Function} translate\n* @param {TextRenderer} textRenderer\n*/",
            "content": "export default function BpmnImporter(\n    eventBus, canvas, elementFactory,\n    elementRegistry, translate, textRenderer) {\n\n  this._eventBus = eventBus;\n  this._canvas = canvas;\n  this._elementFactory = elementFactory;\n  this._elementRegistry = elementRegistry;\n  this._translate = translate;\n  this._textRenderer = textRenderer;\n}",
            "name": "BpmnImporter",
            "parameters": [
                "eventBus",
                "canvas",
                "elementFactory",
                "elementRegistry",
                "translate",
                "textRenderer"
            ],
            "start_line": 65,
            "end_line": 75,
            "return": false
        },
        "function_6": {
            "signature": "/**\n* Add bpmn element (semantic) to the canvas onto the\n* specified parent shape.\n*/",
            "content": "BpmnImporter.prototype.add = function(semantic, parentElement) {\n\n  var di = semantic.di,\n      element,\n      translate = this._translate,\n      hidden;\n\n  var parentIndex;\n\n  // ROOT ELEMENT\n  // handle the special case that we deal with a\n  // invisible root element (process or collaboration)\n  if (is(di, 'bpmndi:BPMNPlane')) {\n\n    // add a virtual element (not being drawn)\n    element = this._elementFactory.createRoot(elementData(semantic));\n\n    this._canvas.setRootElement(element);\n  }\n\n  // SHAPE\n  else if (is(di, 'bpmndi:BPMNShape')) {\n\n    var collapsed = !isExpanded(semantic);\n    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\n\n    var bounds = semantic.di.bounds;\n\n    element = this._elementFactory.createShape(elementData(semantic, {\n      collapsed: collapsed,\n      hidden: hidden,\n      x: Math.round(bounds.x),\n      y: Math.round(bounds.y),\n      width: Math.round(bounds.width),\n      height: Math.round(bounds.height)\n    }));\n\n    if (is(semantic, 'bpmn:BoundaryEvent')) {\n      this._attachBoundary(semantic, element);\n    }\n\n    // insert lanes behind other flow nodes (cf. #727)\n    if (is(semantic, 'bpmn:Lane')) {\n      parentIndex = 0;\n    }\n\n    if (is(semantic, 'bpmn:DataStoreReference')) {\n\n      // check wether data store is inside our outside of its semantic parent\n      if (!isPointInsideBBox(parentElement, getMid(bounds))) {\n        parentElement = this._canvas.getRootElement();\n      }\n    }\n\n    this._canvas.addShape(element, parentElement, parentIndex);\n  }\n\n  // CONNECTION\n  else if (is(di, 'bpmndi:BPMNEdge')) {\n\n    var source = this._getSource(semantic),\n        target = this._getTarget(semantic);\n\n    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\n\n    element = this._elementFactory.createConnection(elementData(semantic, {\n      hidden: hidden,\n      source: source,\n      target: target,\n      waypoints: getWaypoints(semantic, source, target)\n    }));\n\n    if (is(semantic, 'bpmn:DataAssociation')) {\n\n      // render always on top; this ensures DataAssociations\n      // are rendered correctly across different \"hacks\" people\n      // love to model such as cross participant / sub process\n      // associations\n      parentElement = null;\n    }\n\n    // insert sequence flows behind other flow nodes (cf. #727)\n    if (is(semantic, 'bpmn:SequenceFlow')) {\n      parentIndex = 0;\n    }\n\n    this._canvas.addConnection(element, parentElement, parentIndex);\n  } else {\n    throw new Error(translate('unknown di {di} for element {semantic}', {\n      di: elementToString(di),\n      semantic: elementToString(semantic)\n    }));\n  }\n  // (optional) LABEL\n  if (isLabelExternal(semantic) && semantic.name) {\n    this.addLabel(semantic, element);\n  }\n\n\n  this._eventBus.fire('bpmnElement.added', { element: element });\n\n  return element;\n};",
            "name": "function_6",
            "parameters": [
                "semantic",
                "parentElement"
            ],
            "start_line": 91,
            "end_line": 193,
            "return": true
        },
        "function_7": {
            "signature": "/**\n* Attach the boundary element to the given host\n*\n* @param {ModdleElement} boundarySemantic\n* @param {djs.model.Base} boundaryElement\n*/",
            "content": "BpmnImporter.prototype._attachBoundary = function(boundarySemantic, boundaryElement) {\n  var translate = this._translate;\n  var hostSemantic = boundarySemantic.attachedToRef;\n\n  if (!hostSemantic) {\n    throw new Error(translate('missing {semantic}#attachedToRef', {\n      semantic: elementToString(boundarySemantic)\n    }));\n  }\n\n  var host = this._elementRegistry.get(hostSemantic.id),\n      attachers = host && host.attachers;\n\n  if (!host) {\n    throw notYetDrawn(translate, boundarySemantic, hostSemantic, 'attachedToRef');\n  }\n\n  // wire element.host <> host.attachers\n  boundaryElement.host = host;\n\n  if (!attachers) {\n    host.attachers = attachers = [];\n  }\n\n  if (attachers.indexOf(boundaryElement) === -1) {\n    attachers.push(boundaryElement);\n  }\n};",
            "name": "function_7",
            "parameters": [
                "boundarySemantic",
                "boundaryElement"
            ],
            "start_line": 202,
            "end_line": 229,
            "return": false
        },
        "function_8": {
            "signature": "/**\n* add label for an element\n*/",
            "content": "BpmnImporter.prototype.addLabel = function(semantic, element) {\n  var bounds,\n      text,\n      label;\n\n  bounds = getExternalLabelBounds(semantic, element);\n\n  text = semantic.name;\n\n  if (text) {\n    // get corrected bounds from actual layouted text\n    bounds = this._textRenderer.getExternalLabelBounds(bounds, text);\n  }\n\n  label = this._elementFactory.createLabel(elementData(semantic, {\n    id: semantic.id + '_label',\n    labelTarget: element,\n    type: 'label',\n    hidden: element.hidden || !semantic.name,\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  }));\n\n  return this._canvas.addShape(label, element.parent);\n};",
            "name": "function_8",
            "parameters": [
                "semantic",
                "element"
            ],
            "start_line": 235,
            "end_line": 261,
            "return": true
        },
        "function_9": {
            "signature": "/**\n* Return the drawn connection end based on the given side.\n*\n* @throws {Error} if the end is not yet drawn\n*/",
            "content": "BpmnImporter.prototype._getEnd = function(semantic, side) {\n\n  var element,\n      refSemantic,\n      type = semantic.$type,\n      translate = this._translate;\n\n  refSemantic = semantic[side + 'Ref'];\n\n  // handle mysterious isMany DataAssociation#sourceRef\n  if (side === 'source' && type === 'bpmn:DataInputAssociation') {\n    refSemantic = refSemantic && refSemantic[0];\n  }\n\n  // fix source / target for DataInputAssociation / DataOutputAssociation\n  if (side === 'source' && type === 'bpmn:DataOutputAssociation' ||\n      side === 'target' && type === 'bpmn:DataInputAssociation') {\n\n    refSemantic = semantic.$parent;\n  }\n\n  element = refSemantic && this._getElement(refSemantic);\n\n  if (element) {\n    return element;\n  }\n\n  if (refSemantic) {\n    throw notYetDrawn(translate, semantic, refSemantic, side + 'Ref');\n  } else {\n    throw new Error(translate('{semantic}#{side} Ref not specified', {\n      semantic: elementToString(semantic),\n      side: side\n    }));\n  }\n};",
            "name": "function_9",
            "parameters": [
                "semantic",
                "side"
            ],
            "start_line": 268,
            "end_line": 303,
            "return": true
        },
        "function_10": {
            "signature": "",
            "content": "BpmnImporter.prototype._getSource = function(semantic) {\n  return this._getEnd(semantic, 'source');\n};",
            "name": "function_10",
            "parameters": [
                "semantic"
            ],
            "start_line": 305,
            "end_line": 307,
            "return": true
        },
        "function_11": {
            "signature": "",
            "content": "BpmnImporter.prototype._getTarget = function(semantic) {\n  return this._getEnd(semantic, 'target');\n};",
            "name": "function_11",
            "parameters": [
                "semantic"
            ],
            "start_line": 309,
            "end_line": 311,
            "return": true
        },
        "function_12": {
            "signature": "",
            "content": "BpmnImporter.prototype._getElement = function(semantic) {\n  return this._elementRegistry.get(semantic.id);\n};",
            "name": "function_12",
            "parameters": [
                "semantic"
            ],
            "start_line": 314,
            "end_line": 316,
            "return": true
        },
        "function_13": {
            "signature": "// helpers ////////////////////",
            "content": "function isPointInsideBBox(bbox, point) {\n  var x = point.x,\n      y = point.y;\n\n  return x >= bbox.x &&\n    x <= bbox.x + bbox.width &&\n    y >= bbox.y &&\n    y <= bbox.y + bbox.height;\n}",
            "name": "isPointInsideBBox",
            "parameters": [
                "bbox",
                "point"
            ],
            "start_line": 321,
            "end_line": 329,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\import\\BpmnTreeWalker.js": {
        "function_1": {
            "signature": "/**\n* Returns true if an element has the given meta-model type\n*\n* @param  {ModdleElement}  element\n* @param  {String}         type\n*\n* @return {Boolean}\n*/",
            "content": "function is(element, type) {\n  return element.$instanceOf(type);\n}",
            "name": "is",
            "parameters": [
                "element",
                "type"
            ],
            "start_line": 26,
            "end_line": 28,
            "return": true
        },
        "function_2": {
            "signature": "/**\n* Find a suitable display candidate for definitions where the DI does not\n* correctly specify one.\n*/",
            "content": "function findDisplayCandidate(definitions) {\n  return find(definitions.rootElements, function(e) {\n    return is(e, 'bpmn:Process') || is(e, 'bpmn:Collaboration');\n  });\n}",
            "name": "findDisplayCandidate",
            "parameters": [
                "definitions"
            ],
            "start_line": 35,
            "end_line": 39,
            "return": true
        },
        "function_4": {
            "signature": "",
            "content": "export default function BpmnTreeWalker(handler, translate) {\n\n  // list of containers already walked\n  var handledElements = {};\n\n  // list of elements to handle deferred to ensure\n  // prerequisites are drawn\n  var deferred = [];\n\n  // Helpers //////////////////////\n\n  function contextual(fn, ctx) {\n    return function(e) {\n      fn(e, ctx);\n    };\n  }\n\n  function handled(element) {\n    handledElements[element.id] = element;\n  }\n\n  function isHandled(element) {\n    return handledElements[element.id];\n  }\n\n  function visit(element, ctx) {\n\n    var gfx = element.gfx;\n\n    // avoid multiple rendering of elements\n    if (gfx) {\n      throw new Error(\n        translate('already rendered {element}', { element: elementToString(element) })\n      );\n    }\n\n    // call handler\n    return handler.element(element, ctx);\n  }\n\n  function visitRoot(element, diagram) {\n    return handler.root(element, diagram);\n  }\n\n  function visitIfDi(element, ctx) {\n\n    try {\n      var gfx = element.di && visit(element, ctx);\n\n      handled(element);\n\n      return gfx;\n    } catch (e) {\n      logError(e.message, { element: element, error: e });\n\n      console.error(translate('failed to import {element}', { element: elementToString(element) }));\n      console.error(e);\n    }\n  }\n\n  function logError(message, context) {\n    handler.error(message, context);\n  }\n\n  // DI handling //////////////////////\n\n  function registerDi(di) {\n    var bpmnElement = di.bpmnElement;\n\n    if (bpmnElement) {\n      if (bpmnElement.di) {\n        logError(\n          translate('multiple DI elements defined for {element}', {\n            element: elementToString(bpmnElement)\n          }),\n          { element: bpmnElement }\n        );\n      } else {\n        diRefs.bind(bpmnElement, 'di');\n        bpmnElement.di = di;\n      }\n    } else {\n      logError(\n        translate('no bpmnElement referenced in {element}', {\n          element: elementToString(di)\n        }),\n        { element: di }\n      );\n    }\n  }\n\n  function handleDiagram(diagram) {\n    handlePlane(diagram.plane);\n  }\n\n  function handlePlane(plane) {\n    registerDi(plane);\n\n    forEach(plane.planeElement, handlePlaneElement);\n  }\n\n  function handlePlaneElement(planeElement) {\n    registerDi(planeElement);\n  }\n\n\n  // Semantic handling //////////////////////\n\n  /**\n   * Handle definitions and return the rendered diagram (if any)\n   *\n   * @param {ModdleElement} definitions to walk and import\n   * @param {ModdleElement} [diagram] specific diagram to import and display\n   *\n   * @throws {Error} if no diagram to display could be found\n   */\n  function handleDefinitions(definitions, diagram) {\n    // make sure we walk the correct bpmnElement\n\n    var diagrams = definitions.diagrams;\n\n    if (diagram && diagrams.indexOf(diagram) === -1) {\n      throw new Error(translate('diagram not part of bpmn:Definitions'));\n    }\n\n    if (!diagram && diagrams && diagrams.length) {\n      diagram = diagrams[0];\n    }\n\n    // no diagram -> nothing to import\n    if (!diagram) {\n      throw new Error(translate('no diagram to display'));\n    }\n\n    // load DI from selected diagram only\n    handleDiagram(diagram);\n\n\n    var plane = diagram.plane;\n\n    if (!plane) {\n      throw new Error(translate(\n        'no plane for {element}',\n        { element: elementToString(diagram) }\n      ));\n    }\n\n    var rootElement = plane.bpmnElement;\n\n    // ensure we default to a suitable display candidate (process or collaboration),\n    // even if non is specified in DI\n    if (!rootElement) {\n      rootElement = findDisplayCandidate(definitions);\n\n      if (!rootElement) {\n        throw new Error(translate('no process or collaboration to display'));\n      } else {\n\n        logError(\n          translate('correcting missing bpmnElement on {plane} to {rootElement}', {\n            plane: elementToString(plane),\n            rootElement: elementToString(rootElement)\n          })\n        );\n\n        // correct DI on the fly\n        plane.bpmnElement = rootElement;\n        registerDi(plane);\n      }\n    }\n\n\n    var ctx = visitRoot(rootElement, plane);\n\n    if (is(rootElement, 'bpmn:Process')) {\n      handleProcess(rootElement, ctx);\n    } else if (is(rootElement, 'bpmn:Collaboration')) {\n      handleCollaboration(rootElement, ctx);\n\n      // force drawing of everything not yet drawn that is part of the target DI\n      handleUnhandledProcesses(definitions.rootElements, ctx);\n    } else {\n      throw new Error(\n        translate('unsupported bpmnElement for {plane}: {rootElement}', {\n          plane: elementToString(plane),\n          rootElement: elementToString(rootElement)\n        })\n      );\n    }\n\n    // handle all deferred elements\n    handleDeferred(deferred);\n  }\n\n  function handleDeferred() {\n\n    var fn;\n\n    // drain deferred until empty\n    while (deferred.length) {\n      fn = deferred.shift();\n\n      fn();\n    }\n  }\n\n  function handleProcess(process, context) {\n    handleFlowElementsContainer(process, context);\n    handleIoSpecification(process.ioSpecification, context);\n\n    handleArtifacts(process.artifacts, context);\n\n    // log process handled\n    handled(process);\n  }\n\n  function handleUnhandledProcesses(rootElements, ctx) {\n\n    // walk through all processes that have not yet been drawn and draw them\n    // if they contain lanes with DI information.\n    // we do this to pass the free-floating lane test cases in the MIWG test suite\n    var processes = filter(rootElements, function(e) {\n      return !isHandled(e) && is(e, 'bpmn:Process') && e.laneSets;\n    });\n\n    processes.forEach(contextual(handleProcess, ctx));\n  }\n\n  function handleMessageFlow(messageFlow, context) {\n    visitIfDi(messageFlow, context);\n  }\n\n  function handleMessageFlows(messageFlows, context) {\n    forEach(messageFlows, contextual(handleMessageFlow, context));\n  }\n\n  function handleDataAssociation(association, context) {\n    visitIfDi(association, context);\n  }\n\n  function handleDataInput(dataInput, context) {\n    visitIfDi(dataInput, context);\n  }\n\n  function handleDataOutput(dataOutput, context) {\n    visitIfDi(dataOutput, context);\n  }\n\n  function handleArtifact(artifact, context) {\n\n    // bpmn:TextAnnotation\n    // bpmn:Group\n    // bpmn:Association\n\n    visitIfDi(artifact, context);\n  }\n\n  function handleArtifacts(artifacts, context) {\n\n    forEach(artifacts, function(e) {\n      if (is(e, 'bpmn:Association')) {\n        deferred.push(function() {\n          handleArtifact(e, context);\n        });\n      } else {\n        handleArtifact(e, context);\n      }\n    });\n  }\n\n  function handleIoSpecification(ioSpecification, context) {\n\n    if (!ioSpecification) {\n      return;\n    }\n\n    forEach(ioSpecification.dataInputs, contextual(handleDataInput, context));\n    forEach(ioSpecification.dataOutputs, contextual(handleDataOutput, context));\n  }\n\n  function handleSubProcess(subProcess, context) {\n    handleFlowElementsContainer(subProcess, context);\n    handleArtifacts(subProcess.artifacts, context);\n  }\n\n  function handleFlowNode(flowNode, context) {\n    var childCtx = visitIfDi(flowNode, context);\n\n    if (is(flowNode, 'bpmn:SubProcess')) {\n      handleSubProcess(flowNode, childCtx || context);\n    }\n\n    if (is(flowNode, 'bpmn:Activity')) {\n      handleIoSpecification(flowNode.ioSpecification, context);\n    }\n\n    // defer handling of associations\n    // affected types:\n    //\n    //   * bpmn:Activity\n    //   * bpmn:ThrowEvent\n    //   * bpmn:CatchEvent\n    //\n    deferred.push(function() {\n      forEach(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));\n      forEach(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));\n    });\n  }\n\n  function handleSequenceFlow(sequenceFlow, context) {\n    visitIfDi(sequenceFlow, context);\n  }\n\n  function handleDataElement(dataObject, context) {\n    visitIfDi(dataObject, context);\n  }\n\n  function handleBoundaryEvent(dataObject, context) {\n    visitIfDi(dataObject, context);\n  }\n\n  function handleLane(lane, context) {\n\n    deferred.push(function() {\n\n      var newContext = visitIfDi(lane, context);\n\n      if (lane.childLaneSet) {\n        handleLaneSet(lane.childLaneSet, newContext || context);\n      }\n\n      wireFlowNodeRefs(lane);\n    });\n  }\n\n  function handleLaneSet(laneSet, context) {\n    forEach(laneSet.lanes, contextual(handleLane, context));\n  }\n\n  function handleLaneSets(laneSets, context) {\n    forEach(laneSets, contextual(handleLaneSet, context));\n  }\n\n  function handleFlowElementsContainer(container, context) {\n    handleFlowElements(container.flowElements, context);\n\n    if (container.laneSets) {\n      handleLaneSets(container.laneSets, context);\n    }\n  }\n\n  function handleFlowElements(flowElements, context) {\n    forEach(flowElements, function(e) {\n      if (is(e, 'bpmn:SequenceFlow')) {\n        deferred.push(function() {\n          handleSequenceFlow(e, context);\n        });\n      } else if (is(e, 'bpmn:BoundaryEvent')) {\n        deferred.unshift(function() {\n          handleBoundaryEvent(e, context);\n        });\n      } else if (is(e, 'bpmn:FlowNode')) {\n        handleFlowNode(e, context);\n      } else if (is(e, 'bpmn:DataObject')) {\n        // SKIP (assume correct referencing via DataObjectReference)\n      } else if (is(e, 'bpmn:DataStoreReference')) {\n        handleDataElement(e, context);\n      } else if (is(e, 'bpmn:DataObjectReference')) {\n        handleDataElement(e, context);\n      } else {\n        logError(\n          translate('unrecognized flowElement {element} in context {context}', {\n            element: elementToString(e),\n            context: (context ? elementToString(context.businessObject) : 'null')\n          }),\n          { element: e, context: context }\n        );\n      }\n    });\n  }\n\n  function handleParticipant(participant, context) {\n    var newCtx = visitIfDi(participant, context);\n\n    var process = participant.processRef;\n    if (process) {\n      handleProcess(process, newCtx || context);\n    }\n  }\n\n  function handleCollaboration(collaboration) {\n\n    forEach(collaboration.participants, contextual(handleParticipant));\n\n    handleArtifacts(collaboration.artifacts);\n\n    // handle message flows latest in the process\n    deferred.push(function() {\n      handleMessageFlows(collaboration.messageFlows);\n    });\n  }\n\n\n  function wireFlowNodeRefs(lane) {\n    // wire the virtual flowNodeRefs <-> relationship\n    forEach(lane.flowNodeRef, function(flowNode) {\n      var lanes = flowNode.get('lanes');\n\n      if (lanes) {\n        lanes.push(lane);\n      }\n    });\n  }\n\n  // API //////////////////////\n\n  return {\n    handleDeferred: handleDeferred,\n    handleDefinitions: handleDefinitions,\n    handleSubProcess: handleSubProcess,\n    registerDi: registerDi\n  };\n}",
            "name": "BpmnTreeWalker",
            "parameters": [
                "handler",
                "translate"
            ],
            "start_line": 42,
            "end_line": 464,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\import\\Importer.js": {
        "function_1": {
            "signature": "/**\n* Import the definitions into a diagram.\n*\n* Errors and warnings are reported through the specified callback.\n*\n* @param  {djs.Diagram} diagram\n* @param  {ModdleElement<Definitions>} definitions\n* @param  {ModdleElement<BPMNDiagram>} [bpmnDiagram] the diagram to be rendered\n* (if not provided, the first one will be rendered)\n* @param  {Function} done the callback, invoked with (err, [ warning ]) once the import is done\n*/",
            "content": "export function importBpmnDiagram(diagram, definitions, bpmnDiagram, done) {\n\n  if (isFunction(bpmnDiagram)) {\n    done = bpmnDiagram;\n    bpmnDiagram = null;\n  }\n\n  var importer,\n      eventBus,\n      translate;\n\n  var error,\n      warnings = [];\n\n  /**\n   * Walk the diagram semantically, importing (=drawing)\n   * all elements you encounter.\n   *\n   * @param {ModdleElement<Definitions>} definitions\n   * @param {ModdleElement<BPMNDiagram>} bpmnDiagram\n   */\n  function render(definitions, bpmnDiagram) {\n\n    var visitor = {\n\n      root: function(element) {\n        return importer.add(element);\n      },\n\n      element: function(element, parentShape) {\n        return importer.add(element, parentShape);\n      },\n\n      error: function(message, context) {\n        warnings.push({ message: message, context: context });\n      }\n    };\n\n    var walker = new BpmnTreeWalker(visitor, translate);\n\n    // traverse BPMN 2.0 document model,\n    // starting at definitions\n    walker.handleDefinitions(definitions, bpmnDiagram);\n  }\n\n  try {\n    importer = diagram.get('bpmnImporter');\n    eventBus = diagram.get('eventBus');\n    translate = diagram.get('translate');\n\n    eventBus.fire('import.render.start', { definitions: definitions });\n\n    render(definitions, bpmnDiagram);\n\n    eventBus.fire('import.render.complete', {\n      error: error,\n      warnings: warnings\n    });\n  } catch (e) {\n    error = e;\n  }\n\n  done(error, warnings);\n}",
            "name": "importBpmnDiagram",
            "parameters": [
                "diagram",
                "definitions",
                "bpmnDiagram",
                "done"
            ],
            "start_line": 18,
            "end_line": 81,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\import\\index.js": {},
    "repo/bpmn-io/bpmn-js/1011\\lib\\import\\Util.js": {
        "function_1": {
            "signature": "",
            "content": "export function elementToString(e) {\n  if (!e) {\n    return '<null>';\n  }\n\n  return '<' + e.$type + (e.id ? ' id=\"' + e.id : '') + '\" />';\n}",
            "name": "elementToString",
            "parameters": [
                "e"
            ],
            "start_line": 1,
            "end_line": 7,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\util\\DiUtil.js": {
        "function_1": {
            "signature": "",
            "content": "export function isExpanded(element) {\n\n  if (is(element, 'bpmn:CallActivity')) {\n    return false;\n  }\n\n  if (is(element, 'bpmn:SubProcess')) {\n    return !!getBusinessObject(element).di.isExpanded;\n  }\n\n  if (is(element, 'bpmn:Participant')) {\n    return !!getBusinessObject(element).processRef;\n  }\n\n  return true;\n}",
            "name": "isExpanded",
            "parameters": [
                "element"
            ],
            "start_line": 11,
            "end_line": 26,
            "return": true
        },
        "function_2": {
            "signature": "",
            "content": "export function isInterrupting(element) {\n  return element && getBusinessObject(element).isInterrupting !== false;\n}",
            "name": "isInterrupting",
            "parameters": [
                "element"
            ],
            "start_line": 28,
            "end_line": 30,
            "return": true
        },
        "function_3": {
            "signature": "",
            "content": "export function isEventSubProcess(element) {\n  return element && !!getBusinessObject(element).triggeredByEvent;\n}",
            "name": "isEventSubProcess",
            "parameters": [
                "element"
            ],
            "start_line": 32,
            "end_line": 34,
            "return": true
        },
        "function_4": {
            "signature": "",
            "content": "export function hasEventDefinition(element, eventType) {\n  var bo = getBusinessObject(element),\n      hasEventDefinition = false;\n\n  if (bo.eventDefinitions) {\n    forEach(bo.eventDefinitions, function(event) {\n      if (is(event, eventType)) {\n        hasEventDefinition = true;\n      }\n    });\n  }\n\n  return hasEventDefinition;\n}",
            "name": "hasEventDefinition",
            "parameters": [
                "element",
                "eventType"
            ],
            "start_line": 36,
            "end_line": 49,
            "return": true
        },
        "function_6": {
            "signature": "",
            "content": "export function hasErrorEventDefinition(element) {\n  return hasEventDefinition(element, 'bpmn:ErrorEventDefinition');\n}",
            "name": "hasErrorEventDefinition",
            "parameters": [
                "element"
            ],
            "start_line": 51,
            "end_line": 53,
            "return": true
        },
        "function_7": {
            "signature": "",
            "content": "export function hasEscalationEventDefinition(element) {\n  return hasEventDefinition(element, 'bpmn:EscalationEventDefinition');\n}",
            "name": "hasEscalationEventDefinition",
            "parameters": [
                "element"
            ],
            "start_line": 55,
            "end_line": 57,
            "return": true
        },
        "function_8": {
            "signature": "",
            "content": "export function hasCompensateEventDefinition(element) {\n  return hasEventDefinition(element, 'bpmn:CompensateEventDefinition');\n}",
            "name": "hasCompensateEventDefinition",
            "parameters": [
                "element"
            ],
            "start_line": 59,
            "end_line": 61,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\util\\LabelUtil.js": {
        "function_1": {
            "signature": "/**\n* Returns true if the given semantic has an external label\n*\n* @param {BpmnElement} semantic\n* @return {Boolean} true if has label\n*/",
            "content": "export function isLabelExternal(semantic) {\n  return is(semantic, 'bpmn:Event') ||\n         is(semantic, 'bpmn:Gateway') ||\n         is(semantic, 'bpmn:DataStoreReference') ||\n         is(semantic, 'bpmn:DataObjectReference') ||\n         is(semantic, 'bpmn:DataInput') ||\n         is(semantic, 'bpmn:DataOutput') ||\n         is(semantic, 'bpmn:SequenceFlow') ||\n         is(semantic, 'bpmn:MessageFlow');\n}",
            "name": "isLabelExternal",
            "parameters": [
                "semantic"
            ],
            "start_line": 22,
            "end_line": 31,
            "return": true
        },
        "function_2": {
            "signature": "/**\n* Returns true if the given element has an external label\n*\n* @param {djs.model.shape} element\n* @return {Boolean} true if has label\n*/",
            "content": "export function hasExternalLabel(element) {\n  return isLabel(element.label);\n}",
            "name": "hasExternalLabel",
            "parameters": [
                "element"
            ],
            "start_line": 39,
            "end_line": 41,
            "return": true
        },
        "function_3": {
            "signature": "/**\n* Get the position for sequence flow labels\n*\n* @param  {Array<Point>} waypoints\n* @return {Point} the label position\n*/",
            "content": "export function getFlowLabelPosition(waypoints) {\n\n  // get the waypoints mid\n  var mid = waypoints.length / 2 - 1;\n\n  var first = waypoints[Math.floor(mid)];\n  var second = waypoints[Math.ceil(mid + 0.01)];\n\n  // get position\n  var position = getWaypointsMid(waypoints);\n\n  // calculate angle\n  var angle = Math.atan((second.y - first.y) / (second.x - first.x));\n\n  var x = position.x,\n      y = position.y;\n\n  if (Math.abs(angle) < Math.PI / 2) {\n    y -= FLOW_LABEL_INDENT;\n  } else {\n    x += FLOW_LABEL_INDENT;\n  }\n\n  return { x: x, y: y };\n}",
            "name": "getFlowLabelPosition",
            "parameters": [
                "waypoints"
            ],
            "start_line": 49,
            "end_line": 73,
            "return": true
        },
        "function_4": {
            "signature": "/**\n* Get the middle of a number of waypoints\n*\n* @param  {Array<Point>} waypoints\n* @return {Point} the mid point\n*/",
            "content": "export function getWaypointsMid(waypoints) {\n\n  var mid = waypoints.length / 2 - 1;\n\n  var first = waypoints[Math.floor(mid)];\n  var second = waypoints[Math.ceil(mid + 0.01)];\n\n  return {\n    x: first.x + (second.x - first.x) / 2,\n    y: first.y + (second.y - first.y) / 2\n  };\n}",
            "name": "getWaypointsMid",
            "parameters": [
                "waypoints"
            ],
            "start_line": 82,
            "end_line": 93,
            "return": true
        },
        "function_5": {
            "signature": "",
            "content": "export function getExternalLabelMid(element) {\n\n  if (element.waypoints) {\n    return getFlowLabelPosition(element.waypoints);\n  } else {\n    return {\n      x: element.x + element.width / 2,\n      y: element.y + element.height + DEFAULT_LABEL_SIZE.height / 2\n    };\n  }\n}",
            "name": "getExternalLabelMid",
            "parameters": [
                "element"
            ],
            "start_line": 96,
            "end_line": 106,
            "return": true
        },
        "function_6": {
            "signature": "/**\n* Returns the bounds of an elements label, parsed from the elements DI or\n* generated from its bounds.\n*\n* @param {BpmnElement} semantic\n* @param {djs.model.Base} element\n*/",
            "content": "export function getExternalLabelBounds(semantic, element) {\n\n  var mid,\n      size,\n      bounds,\n      di = semantic.di,\n      label = di.label;\n\n  if (label && label.bounds) {\n    bounds = label.bounds;\n\n    size = {\n      width: Math.max(DEFAULT_LABEL_SIZE.width, bounds.width),\n      height: bounds.height\n    };\n\n    mid = {\n      x: bounds.x + bounds.width / 2,\n      y: bounds.y + bounds.height / 2\n    };\n  } else {\n\n    mid = getExternalLabelMid(element);\n\n    size = DEFAULT_LABEL_SIZE;\n  }\n\n  return assign({\n    x: mid.x - size.width / 2,\n    y: mid.y - size.height / 2\n  }, size);\n}",
            "name": "getExternalLabelBounds",
            "parameters": [
                "semantic",
                "element"
            ],
            "start_line": 116,
            "end_line": 147,
            "return": true
        },
        "function_7": {
            "signature": "",
            "content": "export function isLabel(element) {\n  return element && element.labelTarget;\n}",
            "name": "isLabel",
            "parameters": [
                "element"
            ],
            "start_line": 149,
            "end_line": 151,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\util\\ModelUtil.js": {
        "function_1": {
            "signature": "/**\n* Is an element of the given BPMN type?\n*\n* @param  {djs.model.Base|ModdleElement} element\n* @param  {String} type\n*\n* @return {Boolean}\n*/",
            "content": "export function is(element, type) {\n  var bo = getBusinessObject(element);\n\n  return bo && (typeof bo.$instanceOf === 'function') && bo.$instanceOf(type);\n}",
            "name": "is",
            "parameters": [
                "element",
                "type"
            ],
            "start_line": 9,
            "end_line": 13,
            "return": true
        },
        "function_2": {
            "signature": "/**\n* Return the business object for a given element.\n*\n* @param  {djs.model.Base|ModdleElement} element\n*\n* @return {ModdleElement}\n*/",
            "content": "export function getBusinessObject(element) {\n  return (element && element.businessObject) || element;\n}",
            "name": "getBusinessObject",
            "parameters": [
                "element"
            ],
            "start_line": 23,
            "end_line": 25,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\util\\PoweredByUtil.js": {
        "function_1": {
            "signature": "",
            "content": "function css(attrs) {\n  return attrs.join(';');\n}",
            "name": "css",
            "parameters": [
                "attrs"
            ],
            "start_line": 20,
            "end_line": 22,
            "return": true
        },
        "function_2": {
            "signature": "",
            "content": "export function open() {\n\n  if (!lightbox) {\n    lightbox = domify(LIGHTBOX_MARKUP);\n\n    domDelegate.bind(lightbox, '.backdrop', 'click', function(event) {\n      document.body.removeChild(lightbox);\n    });\n  }\n\n  document.body.appendChild(lightbox);\n}",
            "name": "open",
            "parameters": [],
            "start_line": 69,
            "end_line": 80,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\util\\model\\ModelCloneHelper.js": {
        "function_1": {
            "signature": "",
            "content": "function isAllowedIn(extProp, type) {\n  var allowedIn = extProp.meta.allowedIn;\n\n  // '*' is a wildcard, which means any element is allowed to use this property\n  if (allowedIn.length === 1 && allowedIn[0] === '*') {\n    return true;\n  }\n\n  return allowedIn.indexOf(type) !== -1;\n}",
            "name": "isAllowedIn",
            "parameters": [
                "extProp",
                "type"
            ],
            "start_line": 14,
            "end_line": 23,
            "return": true
        },
        "function_2": {
            "signature": "",
            "content": "function isType(element, types) {\n  return some(types, function(type) {\n    return typeof element === type;\n  });\n}",
            "name": "isType",
            "parameters": [
                "element",
                "types"
            ],
            "start_line": 25,
            "end_line": 29,
            "return": true
        },
        "function_4": {
            "signature": "/**\n* A bpmn properties cloning interface\n*\n*/",
            "content": "export default function ModelCloneHelper(eventBus, bpmnFactory) {\n  this._eventBus = eventBus;\n  this._bpmnFactory = bpmnFactory;\n}",
            "name": "ModelCloneHelper",
            "parameters": [
                "eventBus",
                "bpmnFactory"
            ],
            "start_line": 35,
            "end_line": 38,
            "return": false
        },
        "function_5": {
            "signature": "",
            "content": "ModelCloneHelper.prototype.clone = function(refElement, newElement, properties) {\n\n  var self = this;\n\n  // hasNestedProperty: property allows us to avoid ending up with empty (xml) tags\n  // f.ex: if extensionElements.values is empty, don't set it\n  var context = {\n    newElement: newElement,\n    hasNestedProperty: false\n  };\n\n  // we want the extensionElements to be cloned last\n  // so that they can check certain properties\n  properties = sortBy(properties, function(prop) {\n    return prop === 'bpmn:extensionElements';\n  });\n\n  forEach(properties, function(propName) {\n    var refElementProp = refElement.get(propName),\n        newElementProp = newElement.get(propName),\n        propDescriptor = newElement.$model.getPropertyDescriptor(newElement, propName),\n        newProperty, name;\n\n    // we're not interested in cloning:\n    // - same values from simple types\n    // - cloning id's\n    // - cloning reference elements\n    if (newElementProp === refElementProp) {\n      return;\n    }\n\n    if (propDescriptor && (propDescriptor.isId || propDescriptor.isReference)) {\n      return;\n    }\n\n    // if the property is of type 'boolean', 'string', 'number' or 'null', just set it\n    if (isType(refElementProp, [ 'boolean', 'string', 'number' ]) || refElementProp === null) {\n      newElement.set(propName, refElementProp);\n\n      return;\n    }\n\n    if (isArray(refElementProp)) {\n\n      forEach(refElementProp, function(extElement) {\n        var newProp;\n\n        context.refTopLevelProperty = extElement;\n\n        newProp = self._deepClone(extElement, context);\n\n        if (context.hasNestedProperty) {\n          newProp.$parent = newElement;\n\n          newElementProp.push(newProp);\n        }\n\n        context.hasNestedProperty = false;\n      });\n\n    } else {\n      name = propName.replace(/bpmn:/, '');\n\n      context.refTopLevelProperty = refElementProp;\n\n      newProperty = self._deepClone(refElementProp, context);\n\n      if (context.hasNestedProperty) {\n        newProperty.$parent = newElement;\n\n        newElement.set(name, newProperty);\n      }\n\n      context.hasNestedProperty = false;\n    }\n  });\n\n  return newElement;\n};",
            "name": "function_5",
            "parameters": [
                "refElement",
                "newElement",
                "properties"
            ],
            "start_line": 41,
            "end_line": 119,
            "return": true
        },
        "function_9": {
            "signature": "",
            "content": "ModelCloneHelper.prototype._deepClone = function _deepClone(propertyElement, context) {\n  var self = this;\n\n  var eventBus = this._eventBus;\n  var bpmnFactory = this._bpmnFactory;\n\n  var newProp = bpmnFactory.create(propertyElement.$type);\n\n  var properties = filter(Object.keys(propertyElement), function(prop) {\n    var descriptor = newProp.$model.getPropertyDescriptor(newProp, prop);\n\n    if (descriptor && (descriptor.isId || descriptor.isReference)) {\n      return false;\n    }\n\n    // we need to make sure we don't clone certain properties\n    // which we cannot easily know if they hold references or not\n    if (IGNORED_PROPERTIES.indexOf(prop) !== -1) {\n      return false;\n    }\n\n    // make sure we don't copy the type\n    return prop !== '$type';\n  });\n\n  if (!properties.length) {\n    context.hasNestedProperty = true;\n  }\n\n  forEach(properties, function(propName) {\n    // check if the propertyElement has this property defined\n    if (propertyElement[propName] !== undefined &&\n       (propertyElement[propName].$type || isArray(propertyElement[propName]))) {\n\n      if (isArray(propertyElement[propName])) {\n        newProp[propName] = [];\n\n        forEach(propertyElement[propName], function(property) {\n          var extProp = propertyElement.$model.getTypeDescriptor(property.$type),\n              newDeepProp;\n\n          // we're not going to copy undefined types\n          if (!extProp) {\n            return;\n          }\n\n          var canClone = eventBus.fire('property.clone', {\n            newElement: context.newElement,\n            refTopLevelProperty: context.refTopLevelProperty,\n            propertyDescriptor: extProp\n          });\n\n          if (!canClone) {\n            // if can clone is 'undefined' or 'false'\n            // check for the meta information if it is allowed\n            if (propertyElement.$type === 'bpmn:ExtensionElements' &&\n                extProp.meta && extProp.meta.allowedIn &&\n                !isAllowedIn(extProp, context.newElement.$type)) {\n              return false;\n            }\n          }\n\n          newDeepProp = self._deepClone(property, context);\n\n          newDeepProp.$parent = newProp;\n\n          if (!newProp[propName]) {\n            newProp[propName] = [];\n          }\n\n          context.hasNestedProperty = true;\n\n          newProp[propName].push(newDeepProp);\n        });\n\n      } else if (propertyElement[propName].$type) {\n        newProp[propName] = self._deepClone(propertyElement[propName], context);\n\n        if (newProp[propName]) {\n          context.hasNestedProperty = true;\n\n          newProp[propName].$parent = newProp;\n        }\n      }\n    } else {\n      context.hasNestedProperty = true;\n\n      // just assign directly if it's a value\n      newProp[propName] = propertyElement[propName];\n    }\n  });\n\n  return newProp;\n};",
            "name": "_deepClone",
            "parameters": [
                "propertyElement",
                "context"
            ],
            "start_line": 121,
            "end_line": 214,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\lib\\util\\model\\ModelCloneUtils.js": {
        "function_1": {
            "signature": "",
            "content": "export function getProperties(descriptor, keepDefault) {\n  var properties = [];\n\n  forEach(descriptor.properties, function(property) {\n\n    if (keepDefault && property.default) {\n      return;\n    }\n\n    properties.push(property.ns.name);\n  });\n\n  return properties;\n}",
            "name": "getProperties",
            "parameters": [
                "descriptor",
                "keepDefault"
            ],
            "start_line": 23,
            "end_line": 36,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\tasks\\build-distro.js": {
        "function_1": {
            "signature": "",
            "content": "function resolve(module, sub) {\n  var pkg = require.resolve(module + '/package.json');\n\n  return path.dirname(pkg) + sub;\n}",
            "name": "resolve",
            "parameters": [
                "module",
                "sub"
            ],
            "start_line": 13,
            "end_line": 17,
            "return": true
        },
        "function_2": {
            "signature": "",
            "content": "[ 'production', 'development' ].forEach(function(env) {\n\n  try {\n    process.env.NODE_ENV = env;\n\n    exec('rollup', [ '-c' ]);\n  } catch (e) {\n    console.error('failed to build pre-package distributions', e);\n\n    process.exit(1);\n  }\n\n  process.env.NODE_ENV = NODE_ENV;\n});",
            "name": "function_2",
            "parameters": [
                "env"
            ],
            "start_line": 35,
            "end_line": 48,
            "return": false
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\tasks\\helpers.js": {
        "function_1": {
            "signature": "",
            "content": "module.exports.asyncSeries = function(fns, done) {\n\n  var idx = 0;\n\n  function next(err) {\n\n    if (err) {\n      return done(err);\n    }\n\n    var fn = fns[idx++];\n\n    if (!fn) {\n      return done();\n    } else {\n      fn(next);\n    }\n  }\n\n  next();\n};",
            "name": "function_1",
            "parameters": [
                "fns",
                "done"
            ],
            "start_line": 3,
            "end_line": 23,
            "return": true
        }
    },
    "repo/bpmn-io/bpmn-js/1011\\tasks\\test-distro.js": {
        "function_1": {
            "signature": "",
            "content": "function runTest(variant, env) {\n\n  var NODE_ENV = process.env.NODE_ENV;\n\n  process.env.VARIANT = variant;\n  process.env.NODE_ENV = env;\n\n  console.log('[TEST] ' + variant + '@' + env);\n\n  try {\n    execSync('karma', [ 'start', 'test/config/karma.distro.js' ]);\n  } catch (e) {\n    console.error('[TEST] FAILURE ' + variant + '@' + env);\n    console.error(e);\n\n    failures++;\n  } finally {\n    process.env.NODE_ENV = NODE_ENV;\n  }\n}",
            "name": "runTest",
            "parameters": [
                "variant",
                "env"
            ],
            "start_line": 5,
            "end_line": 24,
            "return": false
        },
        "function_2": {
            "signature": "",
            "content": "function test() {\n\n  runTest('bpmn-modeler', 'development');\n  runTest('bpmn-modeler', 'production');\n\n  runTest('bpmn-navigated-viewer', 'development');\n  runTest('bpmn-navigated-viewer', 'production');\n\n  runTest('bpmn-viewer', 'development');\n  runTest('bpmn-viewer', 'production');\n\n  if (failures) {\n    process.exit(1);\n  }\n}",
            "name": "test",
            "parameters": [],
            "start_line": 26,
            "end_line": 40,
            "return": false
        }
    }
}