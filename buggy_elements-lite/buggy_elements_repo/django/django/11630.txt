Let me analyze this step by step.

1. Wrong Behavior:
The error occurs when different Django apps with different models try to use the same table name in their respective databases. After upgrading to Django 2.2, Django throws an error: "table_name is used by multiple models: base.ModelName, app2.ModelName", even though these models are meant to interact with different databases.

2. Cause Analysis:
The issue stems from Django 2.2's stricter model validation. Even though the models are using different databases, Django's model registry is enforcing unique table names across all apps during the validation phase, regardless of database separation. This is likely a validation check introduced in Django 2.2 to prevent potential conflicts.

3. Relevant Files Analysis:

django/apps/config.py:
```
django/apps/config.py
class: AppConfig
```
This class is relevant as it handles app configuration and model registration.

django/apps/registry.py:
```
django/apps/registry.py
class: Apps
```
This class is highly relevant as it's the central registry that manages app configurations and model registration, where the table name validation likely occurs.

django/db/utils.py:
```
django/db/utils.py
class: ConnectionHandler
class: ConnectionRouter
```
These classes are relevant as they handle database routing and connections for multiple databases.

django/db/migrations/autodetector.py:
```
django/db/migrations/autodetector.py
class: MigrationAutodetector
```
This class is relevant as it detects model changes and could be involved in validating model configurations.

django/db/migrations/migration.py:
This file contains no relevant functions/classes.

The core issue likely lies in the Apps registry class, which performs model validation and registration. The ConnectionHandler and ConnectionRouter classes are also important as they manage the multiple database setup, but the validation happening in the Apps registry is preventing the intended multi-database functionality.
