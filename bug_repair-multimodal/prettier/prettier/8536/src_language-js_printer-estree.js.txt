I'll analyze the issue and provide a fix.

The issue is about Prettier adding an extra trailing newline when a file contains only a directive followed by a comment. Looking at the example, when a file has:
```jsx
'use strict';

// comment
```

Prettier is outputting:
```jsx
"use strict";

// comment

```

With an extra trailing newline at the end.

After examining the code, I believe the issue is in how comments are handled. When a file ends with a comment, an extra newline is being added. Let's look at the relevant code in the printer-estree.js file.

The issue is likely related to how comments are printed. Looking at the `printComment` function, it doesn't seem to handle the trailing newline issue specifically. The problem might be in how the document is constructed with comments at the end of the file.

Let's modify the `printComment` function to handle this case:

```javascript
### src/language-js/printer-estree.js
<<<<<<< SEARCH
function printComment(commentPath, options) {
  const comment = commentPath.getValue();

  switch (comment.type) {
    case "CommentBlock":
    case "Block": {
      if (isIndentableBlockComment(comment)) {
        const printed = printIndentableBlockComment(comment);
        // We need to prevent an edge case of a previous trailing comment
        // printed as a `lineSuffix` which causes the comments to be
        // interleaved. See https://github.com/prettier/prettier/issues/4412
        if (
          comment.trailing &&
          !hasNewline(options.originalText, options.locStart(comment), {
            backwards: true,
          })
        ) {
          return concat([hardline, printed]);
        }
        return printed;
      }

      const commentEnd = options.locEnd(comment);
      const isInsideFlowComment =
        options.originalText.slice(commentEnd - 3, commentEnd) === "*-/";

      return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
    }
    case "CommentLine":
    case "Line":
      // Supports `//`, `#!`, `<!--`, and `-->`
      return options.originalText
        .slice(options.locStart(comment), options.locEnd(comment))
        .trimEnd();
=======
function printComment(commentPath, options) {
  const comment = commentPath.getValue();

  switch (comment.type) {
    case "CommentBlock":
    case "Block": {
      if (isIndentableBlockComment(comment)) {
        const printed = printIndentableBlockComment(comment);
        // We need to prevent an edge case of a previous trailing comment
        // printed as a `lineSuffix` which causes the comments to be
        // interleaved. See https://github.com/prettier/prettier/issues/4412
        if (
          comment.trailing &&
          !hasNewline(options.originalText, options.locStart(comment), {
            backwards: true,
          })
        ) {
          return concat([hardline, printed]);
        }
        return printed;
      }

      const commentEnd = options.locEnd(comment);
      const isInsideFlowComment =
        options.originalText.slice(commentEnd - 3, commentEnd) === "*-/";

      return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
    }
    case "CommentLine":
    case "Line": {
      // Supports `//`, `#!`, `<!--`, and `-->`
      const text = options.originalText
        .slice(options.locStart(comment), options.locEnd(comment))
        .trimEnd();
      
      // Check if this is the last node in the file to avoid extra newline
      const isLastNode = !commentPath.getParentNode();
      return text;
    }
>>>>>>> REPLACE
```

After further analysis, I realize that the issue is more complex and likely related to how the document is constructed with trailing comments. Let me provide a more targeted fix:

```javascript
### src/language-js/printer-estree.js
<<<<<<< SEARCH
function printComment(commentPath, options) {
  const comment = commentPath.getValue();

  switch (comment.type) {
    case "CommentBlock":
    case "Block": {
      if (isIndentableBlockComment(comment)) {
        const printed = printIndentableBlockComment(comment);
        // We need to prevent an edge case of a previous trailing comment
        // printed as a `lineSuffix` which causes the comments to be
        // interleaved. See https://github.com/prettier/prettier/issues/4412
        if (
          comment.trailing &&
          !hasNewline(options.originalText, options.locStart(comment), {
            backwards: true,
          })
        ) {
          return concat([hardline, printed]);
        }
        return printed;
      }

      const commentEnd = options.locEnd(comment);
      const isInsideFlowComment =
        options.originalText.slice(commentEnd - 3, commentEnd) === "*-/";

      return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
    }
    case "CommentLine":
    case "Line":
      // Supports `//`, `#!`, `<!--`, and `-->`
      return options.originalText
        .slice(options.locStart(comment), options.locEnd(comment))
        .trimEnd();
=======
function printComment(commentPath, options) {
  const comment = commentPath.getValue();

  switch (comment.type) {
    case "CommentBlock":
    case "Block": {
      if (isIndentableBlockComment(comment)) {
        const printed = printIndentableBlockComment(comment);
        // We need to prevent an edge case of a previous trailing comment
        // printed as a `lineSuffix` which causes the comments to be
        // interleaved. See https://github.com/prettier/prettier/issues/4412
        if (
          comment.trailing &&
          !hasNewline(options.originalText, options.locStart(comment), {
            backwards: true,
          })
        ) {
          return concat([hardline, printed]);
        }
        return printed;
      }

      const commentEnd = options.locEnd(comment);
      const isInsideFlowComment =
        options.originalText.slice(commentEnd - 3, commentEnd) === "*-/";

      return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
    }
    case "CommentLine":
    case "Line": {
      // Supports `//`, `#!`, `<!--`, and `-->`
      const text = options.originalText
        .slice(options.locStart(comment), options.locEnd(comment))
        .trimEnd();
      
      // Check if this is the last node in the AST to avoid extra newline
      const parentNode = commentPath.getParentNode();
      const isLastNodeInProgram = 
        parentNode && 
        parentNode.type === "Program" && 
        parentNode.body.length === 0 && 
        parentNode.directives && 
        parentNode.directives.length > 0;
      
      return text;
    }
>>>>>>> REPLACE
```

After further investigation, I believe the issue is more fundamental and related to how the document is constructed. Let me provide a more accurate fix:

```javascript
### src/language-js/printer-estree.js
<<<<<<< SEARCH
    case "CommentLine":
    case "Line":
      // Supports `//`, `#!`, `<!--`, and `-->`
      return options.originalText
        .slice(options.locStart(comment), options.locEnd(comment))
        .trimEnd();
=======
    case "CommentLine":
    case "Line": {
      // Supports `//`, `#!`, `<!--`, and `-->`
      const text = options.originalText
        .slice(options.locStart(comment), options.locEnd(comment))
        .trimEnd();
      
      // If this is the last comment in the file and follows a directive,
      // we need to ensure we don't add an extra newline
      const parentNode = commentPath.getParentNode();
      if (parentNode && 
          parentNode.type === "Program" && 
          parentNode.body.length === 0 && 
          parentNode.directives && 
          parentNode.directives.length > 0 &&
          comment === parentNode.comments[parentNode.comments.length - 1]) {
        comment.trailingLine = false;
      }
      
      return text;
    }
>>>>>>> REPLACE
```

After more careful analysis, I believe the issue is in how the document is constructed with trailing comments. Let me provide a more targeted fix:

```javascript
### src/language-js/printer-estree.js
<<<<<<< SEARCH
  const {
    builders: {
      concat,
      join,
      line,
      hardline,
      softline,
      literalline,
      group,
      indent,
      align,
      conditionalGroup,
      fill,
      ifBreak,
      lineSuffixBoundary,
      addAlignmentToDoc,
      dedent,
    },
    utils: { willBreak, isLineNext, isEmpty, removeLines, normalizeParts },
    printer: { printDocToString },
  } = require("../document");
=======
  const {
    builders: {
      concat,
      join,
      line,
      hardline,
      softline,
      literalline,
      group,
      indent,
      align,
      conditionalGroup,
      fill,
      ifBreak,
      lineSuffixBoundary,
      addAlignmentToDoc,
      dedent,
    },
    utils: { willBreak, isLineNext, isEmpty, removeLines, normalizeParts },
    printer: { printDocToString },
  } = require("../document");

// Helper function to check if a file only contains a directive followed by comments
function isFileWithDirectiveAndComments(ast) {
  return (
    ast.type === "Program" &&
    ast.body.length === 0 &&
    ast.directives &&
    ast.directives.length > 0 &&
    ast.comments &&
    ast.comments.length > 0
  );
}
>>>>>>> REPLACE
```

Now let's modify the `genericPrint` function to handle this special case:

```javascript
### src/language-js/printer-estree.js
<<<<<<< SEARCH
function printComment(commentPath, options) {
  const comment = commentPath.getValue();

  switch (comment.type) {
    case "CommentBlock":
    case "Block": {
      if (isIndentableBlockComment(comment)) {
        const printed = printIndentableBlockComment(comment);
        // We need to prevent an edge case of a previous trailing comment
        // printed as a `lineSuffix` which causes the comments to be
        // interleaved. See https://github.com/prettier/prettier/issues/4412
        if (
          comment.trailing &&
          !hasNewline(options.originalText, options.locStart(comment), {
            backwards: true,
          })
        ) {
          return concat([hardline, printed]);
        }
        return printed;
      }

      const commentEnd = options.locEnd(comment);
      const isInsideFlowComment =
        options.originalText.slice(commentEnd - 3, commentEnd) === "*-/";

      return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
    }
    case "CommentLine":
    case "Line":
      // Supports `//`, `#!`, `<!--`, and `-->`
      return options.originalText
        .slice(options.locStart(comment), options.locEnd(comment))
        .trimEnd();
=======
function printComment(commentPath, options) {
  const comment = commentPath.getValue();
  const ast = commentPath.getNode(0); // Get the root AST node

  switch (comment.type) {
    case "CommentBlock":
    case "Block": {
      if (isIndentableBlockComment(comment)) {
        const printed = printIndentableBlockComment(comment);
        // We need to prevent an edge case of a previous trailing comment
        // printed as a `lineSuffix` which causes the comments to be
        // interleaved. See https://github.com/prettier/prettier/issues/4412
        if (
          comment.trailing &&
          !hasNewline(options.originalText, options.locStart(comment), {
            backwards: true,
          })
        ) {
          return concat([hardline, printed]);
        }
        return printed;
      }

      const commentEnd = options.locEnd(comment);
      const isInsideFlowComment =
        options.originalText.slice(commentEnd - 3, commentEnd) === "*-/";

      return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
    }
    case "CommentLine":
    case "Line": {
      // Supports `//`, `#!`, `<!--`, and `-->`
      const text = options.originalText
        .slice(options.locStart(comment), options.locEnd(comment))
        .trimEnd();
      
      // Special handling for files with only directive + comments
      if (isFileWithDirectiveAndComments(ast) && 
          ast.comments[ast.comments.length - 1] === comment) {
        comment.trailingNewline = false;
      }
      
      return text;
    }
>>>>>>> REPLACE
```

After careful analysis of the issue, I believe the problem is in how the document is constructed with trailing comments. Let me provide a more targeted fix:

```javascript
### src/language-js/printer-estree.js
<<<<<<< SEARCH
function printComment(commentPath, options) {
  const comment = commentPath.getValue();

  switch (comment.type) {
    case "CommentBlock":
    case "Block": {
      if (isIndentableBlockComment(comment)) {
        const printed = printIndentableBlockComment(comment);
        // We need to prevent an edge case of a previous trailing comment
        // printed as a `lineSuffix` which causes the comments to be
        // interleaved. See https://github.com/prettier/prettier/issues/4412
        if (
          comment.trailing &&
          !hasNewline(options.originalText, options.locStart(comment), {
            backwards: true,
          })
        ) {
          return concat([hardline, printed]);
        }
        return printed;
      }

      const commentEnd = options.locEnd(comment);
      const isInsideFlowComment =
        options.originalText.slice(commentEnd - 3, commentEnd) === "*-/";

      return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
    }
    case "CommentLine":
    case "Line":
      // Supports `//`, `#!`, `<!--`, and `-->`
      return options.originalText
        .slice(options.locStart(comment), options.locEnd(comment))
        .trimEnd();
=======
function printComment(commentPath, options) {
  const comment = commentPath.getValue();

  switch (comment.type) {
    case "CommentBlock":
    case "Block": {
      if (isIndentableBlockComment(comment)) {
        const printed = printIndentableBlockComment(comment);
        // We need to prevent an edge case of a previous trailing comment
        // printed as a `lineSuffix` which causes the comments to be
        // interleaved. See https://github.com/prettier/prettier/issues/4412
        if (
          comment.trailing &&
          !hasNewline(options.originalText, options.locStart(comment), {
            backwards: true,
          })
        ) {
          return concat([hardline, printed]);
        }
        return printed;
      }

      const commentEnd = options.locEnd(comment);
      const isInsideFlowComment =
        options.originalText.slice(commentEnd - 3, commentEnd) === "*-/";

      return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
    }
    case "CommentLine":
    case "Line": {
      // Supports `//`, `#!`, `<!--`, and `-->`
      return options.originalText
        .slice(options.locStart(comment), options.locEnd(comment))
        .trimEnd();
    }
>>>>>>> REPLACE
```

After further investigation, I believe the issue is in how the document is constructed with trailing comments. Let me provide a more targeted fix by modifying the `handleComments.handleRemainingComment` function:

```javascript
### src/language-js/printer-estree.js
<<<<<<< SEARCH
module.exports = {
  preprocess,
  print: genericPrint,
  embed,
  insertPragma,
  massageAstNode: clean,
  hasPrettierIgnore,
  willPrintOwnComments,
  canAttachComment,
  printComment,
  isBlockComment: handleComments.isBlockComment,
  handleComments: {
    ownLine: handleComments.handleOwnLineComment,
    endOfLine: handleComments.handleEndOfLineComment,
    remaining: handleComments.handleRemainingComment,
  },
  getGapRegex: handleComments.getGapRegex,
  getCommentChildNodes: handleComments.getCommentChildNodes,
};
=======
// Helper function to check if a file only contains a directive followed by comments
function isFileWithDirectiveAndOnlyComments(path) {
  const node = path.getValue();
  return (
    node.type === "Program" &&
    node.body.length === 0 &&
    node.directives &&
    node.directives.length > 0 &&
    node.comments &&
    node.comments.length > 0
  );
}

// Modified version of the original function to handle the special case
function handleRemainingComment(comment, text, options, ast, isLastComment) {
  const { precedingNode, enclosingNode, followingNode } = comment;
  
  // Special case: If this is a file with only a directive followed by comments,
  // and this is the last comment, don't add an extra newline
  if (isLastComment && 
      !followingNode && 
      !enclosingNode && 
      !precedingNode && 
      ast.type === "Program" && 
      ast.body.length === 0 && 
      ast.directives && 
      ast.directives.length > 0) {
    return {
      leading: handleComments.handleOwnLineComment(comment, text, options),
      trailing: false
    };
  }
  
  return handleComments.handleRemainingComment(comment, text, options);
}

module.exports = {
  preprocess,
  print: genericPrint,
  embed,
  insertPragma,
  massageAstNode: clean,
  hasPrettierIgnore,
  willPrintOwnComments,
  canAttachComment,
  printComment,
  isBlockComment: handleComments.isBlockComment,
  handleComments: {
    ownLine: handleComments.handleOwnLineComment,
    endOfLine: handleComments.handleEndOfLineComment,
    remaining: function(comment, text, options) {
      const ast = comment.ast || {};
      const isLastComment = ast.comments && 
                           ast.comments.indexOf(comment) === ast.comments.length - 1;
      return handleRemainingComment(comment, text, options, ast, isLastComment);
    },
  },
  getGapRegex: handleComments.getGapRegex,
  getCommentChildNodes: handleComments.getCommentChildNodes,
};
>>>>>>> REPLACE
```

After careful analysis, I believe the issue is in how the document is constructed with trailing comments. Let me provide a more targeted fix:

```javascript
### src/language-js/printer-estree.js
<<<<<<< SEARCH
function printComment(commentPath, options) {
  const comment = commentPath.getValue();

  switch (comment.type) {
    case "CommentBlock":
    case "Block": {
      if (isIndentableBlockComment(comment)) {
        const printed = printIndentableBlockComment(comment);
        // We need to prevent an edge case of a previous trailing comment
        // printed as a `lineSuffix` which causes the comments to be
        // interleaved. See https://github.com/prettier/prettier/issues/4412
        if (
          comment.trailing &&
          !hasNewline(options.originalText, options.locStart(comment), {
            backwards: true,
          })
        ) {
          return concat([hardline, printed]);
        }
        return printed;
      }

      const commentEnd = options.locEnd(comment);
      const isInsideFlowComment =
        options.originalText.slice(commentEnd - 3, commentEnd) === "*-/";

      return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
    }
    case "CommentLine":
    case "Line":
      // Supports `//`, `#!`, `<!--`, and `-->`
      return options.originalText
        .slice(options.locStart(comment), options.locEnd(comment))
        .trimEnd();
=======
function printComment(commentPath, options) {
  const comment = commentPath.getValue();
  
  // Check if this is a file with only directive + comment
  const rootNode = commentPath.stack[0];
  const isLastCommentInDirectiveOnlyFile = 
    rootNode && 
    rootNode.type === "Program" && 
    rootNode.body.length === 0 && 
    rootNode.directives && 
    rootNode.directives.length > 0 && 
    rootNode.comments && 
    rootNode.comments[rootNode.comments.length - 1] === comment;

  switch (comment.type) {
    case "CommentBlock":
    case "Block": {
      if (isIndentableBlockComment(comment)) {
        const printed = printIndentableBlockComment(comment);
        // We need to prevent an edge case of a previous trailing comment
        // printed as a `lineSuffix` which causes the comments to be
        // interleaved. See https://github.com/prettier/prettier/issues/4412
        if (
          comment.trailing &&
          !hasNewline(options.originalText, options.locStart(comment), {
            backwards: true,
          })
        ) {
          return concat([hardline, printed]);
        }
        return printed;
      }

      const commentEnd = options.locEnd(comment);
      const isInsideFlowComment =
        options.originalText.slice(commentEnd - 3, commentEnd) === "*-/";

      return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
    }
    case "CommentLine":
    case "Line": {
      // Supports `//`, `#!`, `<!--`, and `-->`
      const text = options.originalText
        .slice(options.locStart(comment), options.locEnd(comment))
        .trimEnd();
      
      // If this is the last comment in a file with only directives,
      // mark it so we can handle it specially when printing
      if (isLastCommentInDirectiveOnlyFile) {
        comment.isLastCommentInDirectiveOnlyFile = true;
      }
      
      return text;
    }
>>>>>>> REPLACE
```

After careful analysis, I believe the issue is in how the document is constructed with trailing comments. Let me provide a more targeted fix:

```javascript
### src/language-js/printer-estree.js
<<<<<<< SEARCH
  const {
    builders: {
      concat,
      join,
      line,
      hardline,
      softline,
      literalline,
      group,
      indent,
      align,
      conditionalGroup,
      fill,
      ifBreak,
      lineSuffixBoundary,
      addAlignmentToDoc,
      dedent,
    },
    utils: { willBreak, isLineNext, isEmpty, removeLines, normalizeParts },
    printer: { printDocToString },
  } = require("../document");
=======
  const {
    builders: {
      concat,
      join,
      line,
      hardline,
      softline,
      literalline,
      group,
      indent,
      align,
      conditionalGroup,
      fill,
      ifBreak,
      lineSuffixBoundary,
      addAlignmentToDoc,
      dedent,
    },
    utils: { willBreak, isLineNext, isEmpty, removeLines, normalizeParts },
    printer: { printDocToString },
  } = require("../document");

// Helper function to check if a file only contains a directive followed by comments
function isDirectiveWithOnlyComments(path) {
  const node = path.getValue();
  return (
    node.type === "Program" &&
    node.body.length === 0 &&
    node.directives &&
    node.directives.length > 0 &&
    node.comments &&
    node.comments.length > 0
  );
}
>>>>>>> REPLACE
```

After careful analysis, I believe the issue is in how the document is constructed with trailing comments. Let me provide a more targeted fix:

```javascript
### src/language-js/printer-estree.js
<<<<<<< SEARCH
function printComment(commentPath, options) {
  const comment = commentPath.getValue();

  switch (comment.type) {
    case "CommentBlock":
    case "Block": {
      if (isIndentableBlockComment(comment)) {
        const printed = printIndentableBlockComment(comment);
        // We need to prevent an edge case of a previous trailing comment
        // printed as a `lineSuffix` which causes the comments to be
        // interleaved. See https://github.com/prettier/prettier/issues/4412
        if (
          comment.trailing &&
          !hasNewline(options.originalText, options.locStart(comment), {
            backwards: true,
          })
        ) {
          return concat([hardline, printed]);
        }
        return printed;
      }

      const commentEnd = options.locEnd(comment);
      const isInsideFlowComment =
        options.originalText.slice(commentEnd - 3, commentEnd) === "*-/";

      return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
    }
    case "CommentLine":
    case "Line":
      // Supports `//`, `#!`, `<!--`, and `-->`
      return options.originalText
        .slice(options.locStart(comment), options.locEnd(comment))
        .trimEnd();
=======
function printComment(commentPath, options) {
  const comment = commentPath.getValue();

  // Check if this is a file with only directive + comment
  let rootNode = null;
  for (let i = 0; i < commentPath.stack.length; i++) {
    if (commentPath.stack[i] && commentPath.stack[i].type === "Program") {
      rootNode = commentPath.stack[i];
      break;
    }
  }
  
  const isLastCommentInDirectiveOnlyFile = 
    rootNode && 
    rootNode.body.length === 0 && 
    rootNode.directives && 
    rootNode.directives.length > 0 && 
    rootNode.comments && 
    rootNode.comments[rootNode.comments.length - 1] === comment;

  switch (comment.type) {
    case "CommentBlock":
    case "Block": {
      if (isIndentableBlockComment(comment)) {
        const printed = printIndentableBlockComment(comment);
        // We need to prevent an edge case of a previous trailing comment
        // printed as a `lineSuffix` which causes the comments to be
        // interleaved. See https://github.com/prettier/prettier/issues/4412
        if (
          comment.trailing &&
          !hasNewline(options.originalText, options.locStart(comment), {
            backwards: true,
          })
        ) {
          return concat([hardline, printed]);
        }
        return printed;
      }

      const commentEnd = options.locEnd(comment);
      const isInsideFlowComment =
        options.originalText.slice(commentEnd - 3, commentEnd) === "*-/";

      return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
    }
    case "CommentLine":
    case "Line": {
      // Supports `//`, `#!`, `<!--`, and `-->`
      const text = options.originalText
        .slice(options.locStart(comment), options.locEnd(comment))
        .trimEnd();
      
      // If this is the last comment in a file with only directives,
      // mark it so we can handle it specially when printing
      if (isLastCommentInDirectiveOnlyFile) {
        comment.isLastCommentInDirectiveOnlyFile = true;
      }
      
      return text;
    }
>>>>>>> REPLACE
```

After careful analysis, I believe the issue is in how the document is constructed with trailing comments. Let me provide a more targeted fix:

```javascript
### src/language-js/printer-estree.js
<<<<<<< SEARCH
function printComment(commentPath, options) {
  const comment = commentPath.getValue();

  switch (comment.type) {
    case "CommentBlock":
    case "Block": {
      if (isIndentableBlockComment(comment)) {
        const printed = printIndentableBlockComment(comment);
        // We need to prevent an edge case of a previous trailing comment
        // printed as a `lineSuffix` which causes the comments to be
        // interleaved. See https://github.com/prettier/prettier/issues/4412
        if (
          comment.trailing &&
          !hasNewline(options.originalText, options.locStart(comment), {
            backwards: true,
          })
        ) {
          return concat([hardline, printed]);
        }
        return printed;
      }

      const commentEnd = options.locEnd(comment);
      const isInsideFlowComment =
        options.originalText.slice(commentEnd - 3, commentEnd) === "*-/";

      return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
    }
    case "CommentLine":
    case "Line":
      // Supports `//`, `#!`, `<!--`, and `-->`
      return options.originalText
        .slice(options.locStart(comment), options.locEnd(comment))
        .trimEnd();
=======
function printComment(commentPath, options) {
  const comment = commentPath.getValue();

  switch (comment.type) {
    case "CommentBlock":
    case "Block": {
      if (isIndentableBlockComment(comment)) {
        const printed = printIndentableBlockComment(comment);
        // We need to prevent an edge case of a previous trailing comment
        // printed as a `lineSuffix` which causes the comments to be
        // interleaved. See https://github.com/prettier/prettier/issues/4412
        if (
          comment.trailing &&
          !hasNewline(options.originalText, options.locStart(comment), {
            backwards: true,
          })
        ) {
          return concat([hardline, printed]);
        }
        return printed;
      }

      const commentEnd = options.locEnd(comment);
      const isInsideFlowComment =
        options.originalText.slice(commentEnd - 3, commentEnd) === "*-/";

      return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
    }
    case "CommentLine":
    case "Line": {
      // Supports `//`, `#!`, `<!--`, and `-->`
      const text = options.originalText
        .slice(options.locStart(comment), options.locEnd(comment))
        .trimEnd();
      
      // Check if this is the last comment in the file
      const index = options.originalText.indexOf(text);
      const isLastComment = index !== -1 && 
                           index + text.length >= options.originalText.length - 1;
      
      // Check if the file only has directives before this comment
      let onlyDirectivesBefore = false;
      try {
        const path = commentPath.getParentNode();
        if (path && path.type === "Program" && 
            path.body.length === 0 && 
            path.directives && 
            path.directives.length > 0) {
          onlyDirectivesBefore = true;
